'use strict';

var cleanPositionalOperators = require('../schema/cleanPositionalOperators');

var get = require('../get');

var getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');

var updatedPathsByArrayFilter = require('../update/updatedPathsByArrayFilter');
/*!
 * Like `schema.path()`, except with a document, because impossible to
 * determine path type without knowing the embedded discriminator key.
 */


module.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {
  var parts = path.split('.');
  var schematype = null;
  var type = 'adhocOrUndefined';
  filter = filter || {};
  update = update || {};
  var arrayFilters = options != null && Array.isArray(options.arrayFilters) ? options.arrayFilters : [];
  var updatedPathsByFilter = updatedPathsByArrayFilter(update);

  for (var i = 0; i < parts.length; ++i) {
    var subpath = cleanPositionalOperators(parts.slice(0, i + 1).join('.'));
    schematype = schema.path(subpath);

    if (schematype == null) {
      continue;
    }

    type = schema.pathType(subpath);

    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {
      var key = get(schematype, 'schema.options.discriminatorKey');
      var discriminatorValuePath = subpath + '.' + key;
      var discriminatorFilterPath = discriminatorValuePath.replace(/\.\d+\./, '.');
      var discriminatorKey = null;

      if (discriminatorValuePath in filter) {
        discriminatorKey = filter[discriminatorValuePath];
      }

      if (discriminatorFilterPath in filter) {
        discriminatorKey = filter[discriminatorFilterPath];
      }

      var wrapperPath = subpath.replace(/\.\d+$/, '');

      if (schematype.$isMongooseDocumentArrayElement && get(filter[wrapperPath], '$elemMatch.' + key) != null) {
        discriminatorKey = filter[wrapperPath].$elemMatch[key];
      }

      if (discriminatorValuePath in update) {
        discriminatorKey = update[discriminatorValuePath];
      }

      var _loop = function _loop() {
        var filterKey = _Object$keys[_i];
        var schemaKey = updatedPathsByFilter[filterKey] + '.' + key;
        var arrayFilterKey = filterKey + '.' + key;

        if (schemaKey === discriminatorFilterPath) {
          var _filter = arrayFilters.find(function (filter) {
            return filter.hasOwnProperty(arrayFilterKey);
          });

          if (_filter != null) {
            discriminatorKey = _filter[arrayFilterKey];
          }
        }
      };

      for (var _i = 0, _Object$keys = Object.keys(updatedPathsByFilter); _i < _Object$keys.length; _i++) {
        _loop();
      }

      if (discriminatorKey == null) {
        continue;
      }

      var discriminatorSchema = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey).schema;
      var rest = parts.slice(i + 1).join('.');
      schematype = discriminatorSchema.path(rest);

      if (schematype != null) {
        type = discriminatorSchema._getPathType(rest);
        break;
      }
    }
  }

  return {
    type: type,
    schematype: schematype
  };
};