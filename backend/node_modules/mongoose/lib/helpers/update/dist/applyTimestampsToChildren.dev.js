'use strict';

var cleanPositionalOperators = require('../schema/cleanPositionalOperators');

var handleTimestampOption = require('../schema/handleTimestampOption');

module.exports = applyTimestampsToChildren;
/*!
 * ignore
 */

function applyTimestampsToChildren(now, update, schema) {
  if (update == null) {
    return;
  }

  var keys = Object.keys(update);
  var hasDollarKey = keys.some(function (key) {
    return key.startsWith('$');
  });

  if (hasDollarKey) {
    if (update.$push) {
      for (var _i = 0, _Object$keys = Object.keys(update.$push); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var $path = schema.path(key);

        if (update.$push[key] && $path && $path.$isMongooseDocumentArray && $path.schema.options.timestamps) {
          (function () {
            var timestamps = $path.schema.options.timestamps;
            var createdAt = handleTimestampOption(timestamps, 'createdAt');
            var updatedAt = handleTimestampOption(timestamps, 'updatedAt');

            if (update.$push[key].$each) {
              update.$push[key].$each.forEach(function (subdoc) {
                if (updatedAt != null) {
                  subdoc[updatedAt] = now;
                }

                if (createdAt != null) {
                  subdoc[createdAt] = now;
                }
              });
            } else {
              if (updatedAt != null) {
                update.$push[key][updatedAt] = now;
              }

              if (createdAt != null) {
                update.$push[key][createdAt] = now;
              }
            }
          })();
        }
      }
    }

    if (update.$set != null) {
      var _keys = Object.keys(update.$set);

      for (var _i2 = 0, _keys2 = _keys; _i2 < _keys2.length; _i2++) {
        var _key = _keys2[_i2];
        applyTimestampsToUpdateKey(schema, _key, update.$set, now);
      }
    }
  }

  var updateKeys = Object.keys(update).filter(function (key) {
    return !key.startsWith('$');
  });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = updateKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _key2 = _step.value;
      applyTimestampsToUpdateKey(schema, _key2, update, now);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function applyTimestampsToDocumentArray(arr, schematype, now) {
  var timestamps = schematype.schema.options.timestamps;

  if (!timestamps) {
    return;
  }

  var len = arr.length;
  var createdAt = handleTimestampOption(timestamps, 'createdAt');
  var updatedAt = handleTimestampOption(timestamps, 'updatedAt');

  for (var i = 0; i < len; ++i) {
    if (updatedAt != null) {
      arr[i][updatedAt] = now;
    }

    if (createdAt != null) {
      arr[i][createdAt] = now;
    }

    applyTimestampsToChildren(now, arr[i], schematype.schema);
  }
}

function applyTimestampsToSingleNested(subdoc, schematype, now) {
  var timestamps = schematype.schema.options.timestamps;

  if (!timestamps) {
    return;
  }

  var createdAt = handleTimestampOption(timestamps, 'createdAt');
  var updatedAt = handleTimestampOption(timestamps, 'updatedAt');

  if (updatedAt != null) {
    subdoc[updatedAt] = now;
  }

  if (createdAt != null) {
    subdoc[createdAt] = now;
  }

  applyTimestampsToChildren(now, subdoc, schematype.schema);
}

function applyTimestampsToUpdateKey(schema, key, update, now) {
  // Replace positional operator `$` and array filters `$[]` and `$[.*]`
  var keyToSearch = cleanPositionalOperators(key);
  var path = schema.path(keyToSearch);

  if (!path) {
    return;
  }

  var parentSchemaTypes = [];
  var pieces = keyToSearch.split('.');

  for (var i = pieces.length - 1; i > 0; --i) {
    var s = schema.path(pieces.slice(0, i).join('.'));

    if (s != null && (s.$isMongooseDocumentArray || s.$isSingleNested)) {
      parentSchemaTypes.push({
        parentPath: key.split('.').slice(0, i).join('.'),
        parentSchemaType: s
      });
    }
  }

  if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {
    applyTimestampsToDocumentArray(update[key], path, now);
  } else if (update[key] && path.$isSingleNested) {
    applyTimestampsToSingleNested(update[key], path, now);
  } else if (parentSchemaTypes.length > 0) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = parentSchemaTypes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var item = _step2.value;
        var parentPath = item.parentPath;
        var parentSchemaType = item.parentSchemaType;
        var timestamps = parentSchemaType.schema.options.timestamps;
        var updatedAt = handleTimestampOption(timestamps, 'updatedAt');

        if (!timestamps || updatedAt == null) {
          continue;
        }

        if (parentSchemaType.$isSingleNested) {
          // Single nested is easy
          update[parentPath + '.' + updatedAt] = now;
        } else if (parentSchemaType.$isMongooseDocumentArray) {
          var childPath = key.substr(parentPath.length + 1);

          if (/^\d+$/.test(childPath)) {
            update[parentPath + '.' + childPath][updatedAt] = now;
            continue;
          }

          var firstDot = childPath.indexOf('.');
          childPath = firstDot !== -1 ? childPath.substr(0, firstDot) : childPath;
          update[parentPath + '.' + childPath + '.' + updatedAt] = now;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  } else if (path.schema != null && path.schema != schema && update[key]) {
    var _timestamps = path.schema.options.timestamps;
    var createdAt = handleTimestampOption(_timestamps, 'createdAt');

    var _updatedAt = handleTimestampOption(_timestamps, 'updatedAt');

    if (!_timestamps) {
      return;
    }

    if (_updatedAt != null) {
      update[key][_updatedAt] = now;
    }

    if (createdAt != null) {
      update[key][createdAt] = now;
    }
  }
}