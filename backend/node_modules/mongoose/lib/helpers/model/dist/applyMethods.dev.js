'use strict';

var get = require('../get');
/*!
 * Register methods for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 */


module.exports = function applyMethods(model, schema) {
  function apply(method, schema) {
    Object.defineProperty(model.prototype, method, {
      get: function get() {
        var h = {};

        for (var k in schema.methods[method]) {
          h[k] = schema.methods[method][k].bind(this);
        }

        return h;
      },
      configurable: true
    });
  }

  for (var _i = 0, _Object$keys = Object.keys(schema.methods); _i < _Object$keys.length; _i++) {
    var method = _Object$keys[_i];
    var fn = schema.methods[method];

    if (schema.tree.hasOwnProperty(method)) {
      throw new Error('You have a method and a property in your schema both ' + 'named "' + method + '"');
    }

    if (schema.reserved[method] && !get(schema, "methodOptions.".concat(method, ".suppressWarning"), false)) {
      console.warn("mongoose: the method name \"".concat(method, "\" is used by mongoose ") + 'internally, overwriting it may cause bugs. If you\'re sure you know ' + 'what you\'re doing, you can suppress this error by using ' + "`schema.method('".concat(method, "', fn, { suppressWarning: true })`."));
    }

    if (typeof fn === 'function') {
      model.prototype[method] = fn;
    } else {
      apply(method, schema);
    }
  } // Recursively call `applyMethods()` on child schemas


  model.$appliedMethods = true;

  for (var _i2 = 0, _Object$keys2 = Object.keys(schema.paths); _i2 < _Object$keys2.length; _i2++) {
    var key = _Object$keys2[_i2];
    var type = schema.paths[key];

    if (type.$isSingleNested && !type.caster.$appliedMethods) {
      applyMethods(type.caster, type.schema);
    }

    if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {
      applyMethods(type.Constructor, type.schema);
    }
  }
};