'use strict';
/*!
 * ignore
 */

var Mixed = require('../../schema/mixed');

var get = require('../get');

var leanPopulateMap = require('./leanPopulateMap');

var mpath = require('mpath');

var populateModelSymbol = require('../symbols').populateModelSymbol;
/*!
 * @param {Schema} schema
 * @param {Object} doc POJO
 * @param {string} path
 */


module.exports = function getSchemaTypes(schema, doc, path) {
  var pathschema = schema.path(path);
  var topLevelDoc = doc;

  if (pathschema) {
    return pathschema;
  }

  function search(parts, schema, subdoc, nestedPath) {
    var p = parts.length + 1;
    var foundschema;
    var trypath;

    while (p--) {
      trypath = parts.slice(0, p).join('.');
      foundschema = schema.path(trypath);

      if (foundschema == null) {
        continue;
      }

      if (foundschema.caster) {
        // array of Mixed?
        if (foundschema.caster instanceof Mixed) {
          return foundschema.caster;
        }

        var schemas = null;

        if (foundschema.schema != null && foundschema.schema.discriminators != null) {
          (function () {
            var discriminators = foundschema.schema.discriminators;
            var discriminatorKeyPath = trypath + '.' + foundschema.schema.options.discriminatorKey;
            var keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];
            schemas = Object.keys(discriminators).reduce(function (cur, discriminator) {
              if (doc == null || keys.indexOf(discriminator) !== -1) {
                cur.push(discriminators[discriminator]);
              }

              return cur;
            }, []);
          })();
        } // Now that we found the array, we need to check if there
        // are remaining document paths to look up for casting.
        // Also we need to handle array.$.path since schema.path
        // doesn't work for that.
        // If there is no foundschema.schema we are dealing with
        // a path like array.$


        if (p !== parts.length && foundschema.schema) {
          var ret = void 0;

          if (parts[p] === '$') {
            if (p + 1 === parts.length) {
              // comments.$
              return foundschema;
            } // comments.$.comments.$.title


            ret = search(parts.slice(p + 1), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));

            if (ret) {
              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
            }

            return ret;
          }

          if (schemas != null && schemas.length > 0) {
            ret = [];
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = schemas[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _schema2 = _step.value;

                var _ret = search(parts.slice(p), _schema2, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));

                if (_ret != null) {
                  _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;

                  if (_ret.$isUnderneathDocArray) {
                    ret.$isUnderneathDocArray = true;
                  }

                  ret.push(_ret);
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            return ret;
          } else {
            ret = search(parts.slice(p), foundschema.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));

            if (ret) {
              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
            }

            return ret;
          }
        } else if (p !== parts.length && foundschema.$isMongooseArray && foundschema.casterConstructor.$isMongooseArray) {
          // Nested arrays. Drill down to the bottom of the nested array.
          var type = foundschema;

          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {
            type = type.casterConstructor;
          }

          var _ret2 = search(parts.slice(p), type.schema, null, nestedPath.concat(parts.slice(0, p)));

          if (_ret2 != null) {
            return _ret2;
          }

          if (type.schema.discriminators) {
            var discriminatorPaths = [];

            for (var _i = 0, _Object$keys = Object.keys(type.schema.discriminators); _i < _Object$keys.length; _i++) {
              var discriminatorName = _Object$keys[_i];

              var _schema = type.schema.discriminators[discriminatorName] || type.schema;

              var _ret3 = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));

              if (_ret3 != null) {
                discriminatorPaths.push(_ret3);
              }
            }

            if (discriminatorPaths.length > 0) {
              return discriminatorPaths;
            }
          }
        }
      }

      var fullPath = nestedPath.concat([trypath]).join('.');

      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.populated(fullPath) && p < parts.length) {
        var model = doc.$__.populated[fullPath].options[populateModelSymbol];

        if (model != null) {
          var _ret4 = search(parts.slice(p), model.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));

          if (_ret4) {
            _ret4.$isUnderneathDocArray = _ret4.$isUnderneathDocArray || !model.schema.$isSingleNested;
          }

          return _ret4;
        }
      }

      var _val = get(topLevelDoc, trypath);

      if (_val != null) {
        var _model = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val); // Populated using lean, `leanPopulateMap` value is the foreign model


        var _schema3 = _model != null ? _model.schema : null;

        if (_schema3 != null) {
          var _ret5 = search(parts.slice(p), _schema3, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));

          if (_ret5 != null) {
            _ret5.$isUnderneathDocArray = _ret5.$isUnderneathDocArray || !_schema3.$isSingleNested;
            return _ret5;
          }
        }
      }

      return foundschema;
    }
  } // look for arrays


  var parts = path.split('.');

  for (var i = 0; i < parts.length; ++i) {
    if (parts[i] === '$') {
      // Re: gh-5628, because `schema.path()` doesn't take $ into account.
      parts[i] = '0';
    }
  }

  return search(parts, schema, doc, []);
};