'use strict';

var objectIdSymbol = require('../helpers/symbols').objectIdSymbol;

var utils = require('../utils');
/*!
 * ignore
 */


module.exports = function shardingPlugin(schema) {
  schema.post('init', function () {
    storeShard.call(this);
    return this;
  });
  schema.pre('save', function (next) {
    applyWhere.call(this);
    next();
  });
  schema.pre('remove', function (next) {
    applyWhere.call(this);
    next();
  });
  schema.post('save', function () {
    storeShard.call(this);
  });
};
/*!
 * ignore
 */


function applyWhere() {
  var paths;
  var len;

  if (this.$__.shardval) {
    paths = Object.keys(this.$__.shardval);
    len = paths.length;
    this.$where = this.$where || {};

    for (var i = 0; i < len; ++i) {
      this.$where[paths[i]] = this.$__.shardval[paths[i]];
    }
  }
}
/*!
 * ignore
 */


module.exports.storeShard = storeShard;
/*!
 * ignore
 */

function storeShard() {
  // backwards compat
  var key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;

  if (!utils.isPOJO(key)) {
    return;
  }

  var orig = this.$__.shardval = {};
  var paths = Object.keys(key);
  var len = paths.length;
  var val;

  for (var i = 0; i < len; ++i) {
    val = this.$__getValue(paths[i]);

    if (val == null) {
      orig[paths[i]] = val;
    } else if (utils.isMongooseObject(val)) {
      orig[paths[i]] = val.toObject({
        depopulate: true,
        _isNested: true
      });
    } else if (val instanceof Date || val[objectIdSymbol]) {
      orig[paths[i]] = val;
    } else if (typeof val.valueOf === 'function') {
      orig[paths[i]] = val.valueOf();
    } else {
      orig[paths[i]] = val;
    }
  }
}