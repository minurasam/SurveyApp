'use strict';
/*!
 * Module dependencies.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var CastError = require('../error/cast');

var EventEmitter = require('events').EventEmitter;

var ObjectExpectedError = require('../error/objectExpected');

var SchemaSingleNestedOptions = require('../options/SchemaSingleNestedOptions');

var SchemaType = require('../schematype');

var $exists = require('./operators/exists');

var castToNumber = require('./operators/helpers').castToNumber;

var discriminator = require('../helpers/model/discriminator');

var geospatial = require('./operators/geospatial');

var get = require('../helpers/get');

var getConstructor = require('../helpers/discriminator/getConstructor');

var handleIdOption = require('../helpers/schema/handleIdOption');

var internalToObjectOptions = require('../options').internalToObjectOptions;

var Subdocument;
module.exports = SingleNestedPath;
/**
 * Single nested subdocument SchemaType constructor.
 *
 * @param {Schema} schema
 * @param {String} key
 * @param {Object} options
 * @inherits SchemaType
 * @api public
 */

function SingleNestedPath(schema, path, options) {
  schema = handleIdOption(schema, options);
  this.caster = _createConstructor(schema);
  this.caster.path = path;
  this.caster.prototype.$basePath = path;
  this.schema = schema;
  this.$isSingleNested = true;
  SchemaType.call(this, path, options, 'Embedded');
}
/*!
 * ignore
 */


SingleNestedPath.prototype = Object.create(SchemaType.prototype);
SingleNestedPath.prototype.constructor = SingleNestedPath;
SingleNestedPath.prototype.OptionsConstructor = SchemaSingleNestedOptions;
/*!
 * ignore
 */

function _createConstructor(schema, baseClass) {
  // lazy load
  Subdocument || (Subdocument = require('../types/subdocument'));

  var _embedded = function SingleNested(value, path, parent) {
    var _this = this;

    this.$__parent = parent;
    Subdocument.apply(this, arguments);
    this.$session(this.ownerDocument().$session());

    if (parent) {
      parent.on('save', function () {
        _this.emit('save', _this);

        _this.constructor.emit('save', _this);
      });
      parent.on('isNew', function (val) {
        _this.isNew = val;

        _this.emit('isNew', val);

        _this.constructor.emit('isNew', val);
      });
    }
  };

  var proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
  _embedded.prototype = Object.create(proto);

  _embedded.prototype.$__setSchema(schema);

  _embedded.prototype.constructor = _embedded;
  _embedded.schema = schema;
  _embedded.$isSingleNested = true;
  _embedded.events = new EventEmitter();

  _embedded.prototype.toBSON = function () {
    return this.toObject(internalToObjectOptions);
  }; // apply methods


  for (var i in schema.methods) {
    _embedded.prototype[i] = schema.methods[i];
  } // apply statics


  for (var _i in schema.statics) {
    _embedded[_i] = schema.statics[_i];
  }

  for (var _i2 in EventEmitter.prototype) {
    _embedded[_i2] = EventEmitter.prototype[_i2];
  }

  return _embedded;
}
/*!
 * Special case for when users use a common location schema to represent
 * locations for use with $geoWithin.
 * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/
 *
 * @param {Object} val
 * @api private
 */


SingleNestedPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {
  return {
    $geometry: this.castForQuery(val.$geometry)
  };
};
/*!
 * ignore
 */


SingleNestedPath.prototype.$conditionalHandlers.$near = SingleNestedPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;
SingleNestedPath.prototype.$conditionalHandlers.$within = SingleNestedPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;
SingleNestedPath.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;
SingleNestedPath.prototype.$conditionalHandlers.$minDistance = castToNumber;
SingleNestedPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;
SingleNestedPath.prototype.$conditionalHandlers.$exists = $exists;
/**
 * Casts contents
 *
 * @param {Object} value
 * @api private
 */

SingleNestedPath.prototype.cast = function (val, doc, init, priorVal, options) {
  if (val && val.$isSingleNested && val.parent === doc) {
    return val;
  }

  if (val != null && (_typeof(val) !== 'object' || Array.isArray(val))) {
    throw new ObjectExpectedError(this.path, val);
  }

  var Constructor = getConstructor(this.caster, val);
  var subdoc; // Only pull relevant selected paths and pull out the base path

  var parentSelected = get(doc, '$__.selected', {});
  var path = this.path;
  var selected = Object.keys(parentSelected).reduce(function (obj, key) {
    if (key.startsWith(path + '.')) {
      obj[key.substr(path.length + 1)] = parentSelected[key];
    }

    return obj;
  }, {});
  options = Object.assign({}, options, {
    priorDoc: priorVal
  });

  if (init) {
    subdoc = new Constructor(void 0, selected, doc);
    subdoc.init(val);
  } else {
    if (Object.keys(val).length === 0) {
      return new Constructor({}, selected, doc, undefined, options);
    }

    return new Constructor(val, selected, doc, undefined, options);
  }

  return subdoc;
};
/**
 * Casts contents for query
 *
 * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)
 * @param {any} value
 * @api private
 */


SingleNestedPath.prototype.castForQuery = function ($conditional, val, options) {
  var handler;

  if (arguments.length === 2) {
    handler = this.$conditionalHandlers[$conditional];

    if (!handler) {
      throw new Error('Can\'t use ' + $conditional);
    }

    return handler.call(this, val);
  }

  val = $conditional;

  if (val == null) {
    return val;
  }

  if (this.options.runSetters) {
    val = this._applySetters(val);
  }

  var Constructor = getConstructor(this.caster, val);
  var overrideStrict = options != null && options.strict != null ? options.strict : void 0;

  try {
    val = new Constructor(val, overrideStrict);
  } catch (error) {
    // Make sure we always wrap in a CastError (gh-6803)
    if (!(error instanceof CastError)) {
      throw new CastError('Embedded', val, this.path, error, this);
    }

    throw error;
  }

  return val;
};
/**
 * Async validation on this single nested doc.
 *
 * @api private
 */


SingleNestedPath.prototype.doValidate = function (value, fn, scope, options) {
  var Constructor = getConstructor(this.caster, value);

  if (options && options.skipSchemaValidators) {
    if (!(value instanceof Constructor)) {
      value = new Constructor(value, null, scope);
    }

    return value.validate(fn);
  }

  SchemaType.prototype.doValidate.call(this, value, function (error) {
    if (error) {
      return fn(error);
    }

    if (!value) {
      return fn(null);
    }

    value.validate(fn);
  }, scope, options);
};
/**
 * Synchronously validate this single nested doc
 *
 * @api private
 */


SingleNestedPath.prototype.doValidateSync = function (value, scope, options) {
  if (!options || !options.skipSchemaValidators) {
    var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);

    if (schemaTypeError) {
      return schemaTypeError;
    }
  }

  if (!value) {
    return;
  }

  return value.validateSync();
};
/**
 * Adds a discriminator to this single nested subdocument.
 *
 * ####Example:
 *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });
 *     const schema = Schema({ shape: shapeSchema });
 *
 *     const singleNestedPath = parentSchema.path('shape');
 *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));
 *
 * @param {String} name
 * @param {Schema} schema fields to add to the schema for instances of this sub-class
 * @param {String} [value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.
 * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model
 * @see discriminators /docs/discriminators.html
 * @api public
 */


SingleNestedPath.prototype.discriminator = function (name, schema, value) {
  schema = discriminator(this.caster, name, schema, value);
  this.caster.discriminators[name] = _createConstructor(schema, this.caster);
  return this.caster.discriminators[name];
};
/**
 * Sets a default option for all SingleNestedPath instances.
 *
 * ####Example:
 *
 *     // Make all numbers have option `min` equal to 0.
 *     mongoose.Schema.Embedded.set('required', true);
 *
 * @param {String} option - The option you'd like to set the value for
 * @param {*} value - value for option
 * @return {undefined}
 * @function set
 * @static
 * @api public
 */


SingleNestedPath.defaultOptions = {};
SingleNestedPath.set = SchemaType.set;
/*!
 * ignore
 */

SingleNestedPath.prototype.clone = function () {
  var options = Object.assign({}, this.options);
  var schematype = new this.constructor(this.schema, this.path, options);
  schematype.validators = this.validators.slice();

  if (this.requiredValidator !== undefined) {
    schematype.requiredValidator = this.requiredValidator;
  }

  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);
  return schematype;
};