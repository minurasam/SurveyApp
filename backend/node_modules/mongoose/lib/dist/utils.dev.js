'use strict';
/*!
 * Module dependencies.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var ms = require('ms');

var mpath = require('mpath');

var sliced = require('sliced');

var Buffer = require('safe-buffer').Buffer;

var Decimal = require('./types/decimal128');

var ObjectId = require('./types/objectid');

var PopulateOptions = require('./options/PopulateOptions');

var clone = require('./helpers/clone');

var isObject = require('./helpers/isObject');

var isBsonType = require('./helpers/isBsonType');

var getFunctionName = require('./helpers/getFunctionName');

var isMongooseObject = require('./helpers/isMongooseObject');

var promiseOrCallback = require('./helpers/promiseOrCallback');

var specialProperties = require('./helpers/specialProperties');

var Document;
exports.specialProperties = specialProperties;
/*!
 * Produces a collection name from model `name`. By default, just returns
 * the model name
 *
 * @param {String} name a model name
 * @param {Function} pluralize function that pluralizes the collection name
 * @return {String} a collection name
 * @api private
 */

exports.toCollectionName = function (name, pluralize) {
  if (name === 'system.profile') {
    return name;
  }

  if (name === 'system.indexes') {
    return name;
  }

  if (typeof pluralize === 'function') {
    return pluralize(name);
  }

  return name;
};
/*!
 * Determines if `a` and `b` are deep equal.
 *
 * Modified from node/lib/assert.js
 *
 * @param {any} a a value to compare to `b`
 * @param {any} b a value to compare to `a`
 * @return {Boolean}
 * @api private
 */


exports.deepEqual = function deepEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (_typeof(a) !== 'object' && _typeof(b) !== 'object') {
    return a === b;
  }

  if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  }

  if (isBsonType(a, 'ObjectID') && isBsonType(b, 'ObjectID') || isBsonType(a, 'Decimal128') && isBsonType(b, 'Decimal128')) {
    return a.toString() === b.toString();
  }

  if (a instanceof RegExp && b instanceof RegExp) {
    return a.source === b.source && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.global === b.global;
  }

  if (a == null || b == null) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  if (a instanceof Map && b instanceof Map) {
    return deepEqual(Array.from(a.keys()), Array.from(b.keys())) && deepEqual(Array.from(a.values()), Array.from(b.values()));
  } // Handle MongooseNumbers


  if (a instanceof Number && b instanceof Number) {
    return a.valueOf() === b.valueOf();
  }

  if (Buffer.isBuffer(a)) {
    return exports.buffer.areEqual(a, b);
  }

  if (Array.isArray(a) && Array.isArray(b)) {
    var len = a.length;

    if (len !== b.length) {
      return false;
    }

    for (var i = 0; i < len; ++i) {
      if (!deepEqual(a[i], b[i])) {
        return false;
      }
    }

    return true;
  }

  if (a.$__ != null) {
    a = a._doc;
  } else if (isMongooseObject(a)) {
    a = a.toObject();
  }

  if (b.$__ != null) {
    b = b._doc;
  } else if (isMongooseObject(b)) {
    b = b.toObject();
  }

  var ka = Object.keys(a);
  var kb = Object.keys(b);
  var kaLength = ka.length; // having the same number of owned properties (keys incorporates
  // hasOwnProperty)

  if (kaLength !== kb.length) {
    return false;
  } // the same set of keys (although not necessarily the same order),


  ka.sort();
  kb.sort(); // ~~~cheap key test

  for (var _i = kaLength - 1; _i >= 0; _i--) {
    if (ka[_i] !== kb[_i]) {
      return false;
    }
  } // equivalent values for every corresponding key, and
  // ~~~possibly expensive deep test


  for (var _i2 = 0, _ka = ka; _i2 < _ka.length; _i2++) {
    var key = _ka[_i2];

    if (!deepEqual(a[key], b[key])) {
      return false;
    }
  }

  return true;
};
/*!
 * Get the last element of an array
 */


exports.last = function (arr) {
  if (arr.length > 0) {
    return arr[arr.length - 1];
  }

  return void 0;
};

exports.clone = clone;
/*!
 * ignore
 */

exports.promiseOrCallback = promiseOrCallback;
/*!
 * ignore
 */

exports.omit = function omit(obj, keys) {
  if (keys == null) {
    return Object.assign({}, obj);
  }

  if (!Array.isArray(keys)) {
    keys = [keys];
  }

  var ret = Object.assign({}, obj);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      delete ret[key];
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return ret;
};
/*!
 * Shallow copies defaults into options.
 *
 * @param {Object} defaults
 * @param {Object} options
 * @return {Object} the merged object
 * @api private
 */


exports.options = function (defaults, options) {
  var keys = Object.keys(defaults);
  var i = keys.length;
  var k;
  options = options || {};

  while (i--) {
    k = keys[i];

    if (!(k in options)) {
      options[k] = defaults[k];
    }
  }

  return options;
};
/*!
 * Generates a random string
 *
 * @api private
 */


exports.random = function () {
  return Math.random().toString().substr(3);
};
/*!
 * Merges `from` into `to` without overwriting existing properties.
 *
 * @param {Object} to
 * @param {Object} from
 * @api private
 */


exports.merge = function merge(to, from, options, path) {
  options = options || {};
  var keys = Object.keys(from);
  var i = 0;
  var len = keys.length;
  var key;
  path = path || '';
  var omitNested = options.omitNested || {};

  while (i < len) {
    key = keys[i++];

    if (options.omit && options.omit[key]) {
      continue;
    }

    if (omitNested[path]) {
      continue;
    }

    if (specialProperties.has(key)) {
      continue;
    }

    if (to[key] == null) {
      to[key] = from[key];
    } else if (exports.isObject(from[key])) {
      if (!exports.isObject(to[key])) {
        to[key] = {};
      }

      if (from[key] != null) {
        // Skip merging schemas if we're creating a discriminator schema and
        // base schema has a given path as a single nested but discriminator schema
        // has the path as a document array, or vice versa (gh-9534)
        if (options.isDiscriminatorSchemaMerge && from[key].$isSingleNested && to[key].$isMongooseDocumentArray || from[key].$isMongooseDocumentArray && to[key].$isSingleNested) {
          continue;
        } else if (from[key].instanceOfSchema) {
          if (to[key].instanceOfSchema) {
            to[key].add(from[key].clone());
          } else {
            to[key] = from[key].clone();
          }

          continue;
        } else if (from[key] instanceof ObjectId) {
          to[key] = new ObjectId(from[key]);
          continue;
        }
      }

      merge(to[key], from[key], options, path ? path + '.' + key : key);
    } else if (options.overwrite) {
      to[key] = from[key];
    }
  }
};
/*!
 * Applies toObject recursively.
 *
 * @param {Document|Array|Object} obj
 * @return {Object}
 * @api private
 */


exports.toObject = function toObject(obj) {
  Document || (Document = require('./document'));
  var ret;

  if (obj == null) {
    return obj;
  }

  if (obj instanceof Document) {
    return obj.toObject();
  }

  if (Array.isArray(obj)) {
    ret = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = obj[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var doc = _step2.value;
        ret.push(toObject(doc));
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return ret;
  }

  if (exports.isPOJO(obj)) {
    ret = {};

    for (var _i3 = 0, _Object$keys = Object.keys(obj); _i3 < _Object$keys.length; _i3++) {
      var k = _Object$keys[_i3];

      if (specialProperties.has(k)) {
        continue;
      }

      ret[k] = toObject(obj[k]);
    }

    return ret;
  }

  return obj;
};

exports.isObject = isObject;
/*!
 * Determines if `arg` is a plain old JavaScript object (POJO). Specifically,
 * `arg` must be an object but not an instance of any special class, like String,
 * ObjectId, etc.
 *
 * `Object.getPrototypeOf()` is part of ES5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @api private
 * @return {Boolean}
 */

exports.isPOJO = function isPOJO(arg) {
  if (arg == null || _typeof(arg) !== 'object') {
    return false;
  }

  var proto = Object.getPrototypeOf(arg); // Prototype may be null if you used `Object.create(null)`
  // Checking `proto`'s constructor is safe because `getPrototypeOf()`
  // explicitly crosses the boundary from object data to object metadata

  return !proto || proto.constructor.name === 'Object';
};
/*!
 * Determines if `obj` is a built-in object like an array, date, boolean,
 * etc.
 */


exports.isNativeObject = function (arg) {
  return Array.isArray(arg) || arg instanceof Date || arg instanceof Boolean || arg instanceof Number || arg instanceof String;
};
/*!
 * Determines if `val` is an object that has no own keys
 */


exports.isEmptyObject = function (val) {
  return val != null && _typeof(val) === 'object' && Object.keys(val).length === 0;
};
/*!
 * Search if `obj` or any POJOs nested underneath `obj` has a property named
 * `key`
 */


exports.hasKey = function hasKey(obj, key) {
  var props = Object.keys(obj);

  for (var _i4 = 0, _props = props; _i4 < _props.length; _i4++) {
    var prop = _props[_i4];

    if (prop === key) {
      return true;
    }

    if (exports.isPOJO(obj[prop]) && exports.hasKey(obj[prop], key)) {
      return true;
    }
  }

  return false;
};
/*!
 * A faster Array.prototype.slice.call(arguments) alternative
 * @api private
 */


exports.args = sliced;
/*!
 * process.nextTick helper.
 *
 * Wraps `callback` in a try/catch + nextTick.
 *
 * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.
 *
 * @param {Function} callback
 * @api private
 */

exports.tick = function tick(callback) {
  if (typeof callback !== 'function') {
    return;
  }

  return function () {
    try {
      callback.apply(this, arguments);
    } catch (err) {
      // only nextTick on err to get out of
      // the event loop and avoid state corruption.
      process.nextTick(function () {
        throw err;
      });
    }
  };
};
/*!
 * Returns true if `v` is an object that can be serialized as a primitive in
 * MongoDB
 */


exports.isMongooseType = function (v) {
  return v instanceof ObjectId || v instanceof Decimal || v instanceof Buffer;
};

exports.isMongooseObject = isMongooseObject;
/*!
 * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.
 *
 * @param {Object} object
 * @api private
 */

exports.expires = function expires(object) {
  if (!(object && object.constructor.name === 'Object')) {
    return;
  }

  if (!('expires' in object)) {
    return;
  }

  var when;

  if (typeof object.expires !== 'string') {
    when = object.expires;
  } else {
    when = Math.round(ms(object.expires) / 1000);
  }

  object.expireAfterSeconds = when;
  delete object.expires;
};
/*!
 * populate helper
 */


exports.populate = function populate(path, select, model, match, options, subPopulate, justOne, count) {
  // might have passed an object specifying all arguments
  var obj = null;

  if (arguments.length === 1) {
    if (path instanceof PopulateOptions) {
      return [path];
    }

    if (Array.isArray(path)) {
      var singles = makeSingles(path);
      return singles.map(function (o) {
        return exports.populate(o)[0];
      });
    }

    if (exports.isObject(path)) {
      obj = Object.assign({}, path);
    } else {
      obj = {
        path: path
      };
    }
  } else if (_typeof(model) === 'object') {
    obj = {
      path: path,
      select: select,
      match: model,
      options: match
    };
  } else {
    obj = {
      path: path,
      select: select,
      model: model,
      match: match,
      options: options,
      populate: subPopulate,
      justOne: justOne,
      count: count
    };
  }

  if (typeof obj.path !== 'string') {
    throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + _typeof(path) + '`');
  }

  return _populateObj(obj); // The order of select/conditions args is opposite Model.find but
  // necessary to keep backward compatibility (select could be
  // an array, string, or object literal).

  function makeSingles(arr) {
    var ret = [];
    arr.forEach(function (obj) {
      if (/[\s]/.test(obj.path)) {
        var paths = obj.path.split(' ');
        paths.forEach(function (p) {
          var copy = Object.assign({}, obj);
          copy.path = p;
          ret.push(copy);
        });
      } else {
        ret.push(obj);
      }
    });
    return ret;
  }
};

function _populateObj(obj) {
  if (Array.isArray(obj.populate)) {
    var _ret = [];
    obj.populate.forEach(function (obj) {
      if (/[\s]/.test(obj.path)) {
        var copy = Object.assign({}, obj);

        var _paths = copy.path.split(' ');

        _paths.forEach(function (p) {
          copy.path = p;

          _ret.push(exports.populate(copy)[0]);
        });
      } else {
        _ret.push(exports.populate(obj)[0]);
      }
    });
    obj.populate = exports.populate(_ret);
  } else if (obj.populate != null && _typeof(obj.populate) === 'object') {
    obj.populate = exports.populate(obj.populate);
  }

  var ret = [];
  var paths = obj.path.split(' ');

  if (obj.options != null) {
    obj.options = exports.clone(obj.options);
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = paths[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var path = _step3.value;
      ret.push(new PopulateOptions(Object.assign({}, obj, {
        path: path
      })));
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return ret;
}
/*!
 * Return the value of `obj` at the given `path`.
 *
 * @param {String} path
 * @param {Object} obj
 */


exports.getValue = function (path, obj, map) {
  return mpath.get(path, obj, '_doc', map);
};
/*!
 * Sets the value of `obj` at the given `path`.
 *
 * @param {String} path
 * @param {Anything} val
 * @param {Object} obj
 */


exports.setValue = function (path, val, obj, map, _copying) {
  mpath.set(path, val, obj, '_doc', map, _copying);
};
/*!
 * Returns an array of values from object `o`.
 *
 * @param {Object} o
 * @return {Array}
 * @private
 */


exports.object = {};

exports.object.vals = function vals(o) {
  var keys = Object.keys(o);
  var i = keys.length;
  var ret = [];

  while (i--) {
    ret.push(o[keys[i]]);
  }

  return ret;
};
/*!
 * @see exports.options
 */


exports.object.shallowCopy = exports.options;
/*!
 * Safer helper for hasOwnProperty checks
 *
 * @param {Object} obj
 * @param {String} prop
 */

var hop = Object.prototype.hasOwnProperty;

exports.object.hasOwnProperty = function (obj, prop) {
  return hop.call(obj, prop);
};
/*!
 * Determine if `val` is null or undefined
 *
 * @return {Boolean}
 */


exports.isNullOrUndefined = function (val) {
  return val === null || val === undefined;
};
/*!
 * ignore
 */


exports.array = {};
/*!
 * Flattens an array.
 *
 * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]
 *
 * @param {Array} arr
 * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsy value, the item will not be included in the results.
 * @return {Array}
 * @private
 */

exports.array.flatten = function flatten(arr, filter, ret) {
  ret || (ret = []);
  arr.forEach(function (item) {
    if (Array.isArray(item)) {
      flatten(item, filter, ret);
    } else {
      if (!filter || filter(item)) {
        ret.push(item);
      }
    }
  });
  return ret;
};
/*!
 * ignore
 */


var _hasOwnProperty = Object.prototype.hasOwnProperty;

exports.hasUserDefinedProperty = function (obj, key) {
  if (obj == null) {
    return false;
  }

  if (Array.isArray(key)) {
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = key[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var k = _step4.value;

        if (exports.hasUserDefinedProperty(obj, k)) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
          _iterator4["return"]();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    return false;
  }

  if (_hasOwnProperty.call(obj, key)) {
    return true;
  }

  if (_typeof(obj) === 'object' && key in obj) {
    var v = obj[key];
    return v !== Object.prototype[key] && v !== Array.prototype[key];
  }

  return false;
};
/*!
 * ignore
 */


var MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;

exports.isArrayIndex = function (val) {
  if (typeof val === 'number') {
    return val >= 0 && val <= MAX_ARRAY_INDEX;
  }

  if (typeof val === 'string') {
    if (!/^\d+$/.test(val)) {
      return false;
    }

    val = +val;
    return val >= 0 && val <= MAX_ARRAY_INDEX;
  }

  return false;
};
/*!
 * Removes duplicate values from an array
 *
 * [1, 2, 3, 3, 5] => [1, 2, 3, 5]
 * [ ObjectId("550988ba0c19d57f697dc45e"), ObjectId("550988ba0c19d57f697dc45e") ]
 *    => [ObjectId("550988ba0c19d57f697dc45e")]
 *
 * @param {Array} arr
 * @return {Array}
 * @private
 */


exports.array.unique = function (arr) {
  var primitives = new Set();
  var ids = new Set();
  var ret = [];
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = arr[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var item = _step5.value;

      if (typeof item === 'number' || typeof item === 'string' || item == null) {
        if (primitives.has(item)) {
          continue;
        }

        ret.push(item);
        primitives.add(item);
      } else if (item instanceof ObjectId) {
        if (ids.has(item.toString())) {
          continue;
        }

        ret.push(item);
        ids.add(item.toString());
      } else {
        ret.push(item);
      }
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
        _iterator5["return"]();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  return ret;
};
/*!
 * Determines if two buffers are equal.
 *
 * @param {Buffer} a
 * @param {Object} b
 */


exports.buffer = {};

exports.buffer.areEqual = function (a, b) {
  if (!Buffer.isBuffer(a)) {
    return false;
  }

  if (!Buffer.isBuffer(b)) {
    return false;
  }

  if (a.length !== b.length) {
    return false;
  }

  for (var i = 0, len = a.length; i < len; ++i) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
};

exports.getFunctionName = getFunctionName;
/*!
 * Decorate buffers
 */

exports.decorate = function (destination, source) {
  for (var key in source) {
    if (specialProperties.has(key)) {
      continue;
    }

    destination[key] = source[key];
  }
};
/**
 * merges to with a copy of from
 *
 * @param {Object} to
 * @param {Object} fromObj
 * @api private
 */


exports.mergeClone = function (to, fromObj) {
  if (isMongooseObject(fromObj)) {
    fromObj = fromObj.toObject({
      transform: false,
      virtuals: false,
      depopulate: true,
      getters: false,
      flattenDecimals: false
    });
  }

  var keys = Object.keys(fromObj);
  var len = keys.length;
  var i = 0;
  var key;

  while (i < len) {
    key = keys[i++];

    if (specialProperties.has(key)) {
      continue;
    }

    if (typeof to[key] === 'undefined') {
      to[key] = exports.clone(fromObj[key], {
        transform: false,
        virtuals: false,
        depopulate: true,
        getters: false,
        flattenDecimals: false
      });
    } else {
      var val = fromObj[key];

      if (val != null && val.valueOf && !(val instanceof Date)) {
        val = val.valueOf();
      }

      if (exports.isObject(val)) {
        var obj = val;

        if (isMongooseObject(val) && !val.isMongooseBuffer) {
          obj = obj.toObject({
            transform: false,
            virtuals: false,
            depopulate: true,
            getters: false,
            flattenDecimals: false
          });
        }

        if (val.isMongooseBuffer) {
          obj = Buffer.from(obj);
        }

        exports.mergeClone(to[key], obj);
      } else {
        to[key] = exports.clone(val, {
          flattenDecimals: false
        });
      }
    }
  }
};
/**
 * Executes a function on each element of an array (like _.each)
 *
 * @param {Array} arr
 * @param {Function} fn
 * @api private
 */


exports.each = function (arr, fn) {
  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = arr[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var item = _step6.value;
      fn(item);
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
        _iterator6["return"]();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }
};
/*!
 * ignore
 */


exports.getOption = function (name) {
  var sources = Array.prototype.slice.call(arguments, 1);
  var _iteratorNormalCompletion7 = true;
  var _didIteratorError7 = false;
  var _iteratorError7 = undefined;

  try {
    for (var _iterator7 = sources[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
      var source = _step7.value;

      if (source[name] != null) {
        return source[name];
      }
    }
  } catch (err) {
    _didIteratorError7 = true;
    _iteratorError7 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
        _iterator7["return"]();
      }
    } finally {
      if (_didIteratorError7) {
        throw _iteratorError7;
      }
    }
  }

  return null;
};
/*!
 * ignore
 */


exports.noop = function () {};

exports.errorToPOJO = function errorToPOJO(error) {
  var isError = error instanceof Error;

  if (!isError) {
    throw new Error('`error` must be `instanceof Error`.');
  }

  var ret = {};
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = Object.getOwnPropertyNames(error)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var properyName = _step8.value;
      ret[properyName] = error[properyName];
    }
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
        _iterator8["return"]();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  return ret;
};