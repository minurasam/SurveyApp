'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var Result = require('./result');

var utils = require('./utils');

var Query =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Query, _EventEmitter);

  function Query(config, values, callback) {
    var _this;

    _classCallCheck(this, Query);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Query).call(this));
    config = utils.normalizeQueryConfig(config, values, callback);
    _this.text = config.text;
    _this.values = config.values;
    _this.rows = config.rows;
    _this.types = config.types;
    _this.name = config.name;
    _this.binary = config.binary; // use unique portal name each time

    _this.portal = config.portal || '';
    _this.callback = config.callback;
    _this._rowMode = config.rowMode;

    if (process.domain && config.callback) {
      _this.callback = process.domain.bind(config.callback);
    }

    _this._result = new Result(_this._rowMode, _this.types); // potential for multiple results

    _this._results = _this._result;
    _this.isPreparedStatement = false;
    _this._canceledDueToError = false;
    _this._promise = null;
    return _this;
  }

  _createClass(Query, [{
    key: "requiresPreparation",
    value: function requiresPreparation() {
      // named queries must always be prepared
      if (this.name) {
        return true;
      } // always prepare if there are max number of rows expected per
      // portal execution


      if (this.rows) {
        return true;
      } // don't prepare empty text queries


      if (!this.text) {
        return false;
      } // prepare if there are values


      if (!this.values) {
        return false;
      }

      return this.values.length > 0;
    }
  }, {
    key: "_checkForMultirow",
    value: function _checkForMultirow() {
      // if we already have a result with a command property
      // then we've already executed one query in a multi-statement simple query
      // turn our results into an array of results
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }

        this._result = new Result(this._rowMode, this.types);

        this._results.push(this._result);
      }
    } // associates row metadata from the supplied
    // message with this query object
    // metadata used when parsing row results

  }, {
    key: "handleRowDescription",
    value: function handleRowDescription(msg) {
      this._checkForMultirow();

      this._result.addFields(msg.fields);

      this._accumulateRows = this.callback || !this.listeners('row').length;
    }
  }, {
    key: "handleDataRow",
    value: function handleDataRow(msg) {
      var row;

      if (this._canceledDueToError) {
        return;
      }

      try {
        row = this._result.parseRow(msg.fields);
      } catch (err) {
        this._canceledDueToError = err;
        return;
      }

      this.emit('row', row, this._result);

      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
  }, {
    key: "handleCommandComplete",
    value: function handleCommandComplete(msg, connection) {
      this._checkForMultirow();

      this._result.addCommandComplete(msg); // need to sync after each command complete of a prepared statement
      // if we were using a row count which results in multiple calls to _getRows


      if (this.rows) {
        connection.sync();
      }
    } // if a named prepared statement is created with empty query text
    // the backend will send an emptyQuery message but *not* a command complete message
    // since we pipeline sync immediately after execute we don't need to do anything here
    // unless we have rows specified, in which case we did not pipeline the intial sync call

  }, {
    key: "handleEmptyQuery",
    value: function handleEmptyQuery(connection) {
      if (this.rows) {
        connection.sync();
      }
    }
  }, {
    key: "handleError",
    value: function handleError(err, connection) {
      // need to sync after error during a prepared statement
      if (this._canceledDueToError) {
        err = this._canceledDueToError;
        this._canceledDueToError = false;
      } // if callback supplied do not emit error event as uncaught error
      // events will bubble up to node process


      if (this.callback) {
        return this.callback(err);
      }

      this.emit('error', err);
    }
  }, {
    key: "handleReadyForQuery",
    value: function handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }

      if (this.callback) {
        this.callback(null, this._results);
      }

      this.emit('end', this._results);
    }
  }, {
    key: "submit",
    value: function submit(connection) {
      if (typeof this.text !== 'string' && typeof this.name !== 'string') {
        return new Error('A query must have either text or a name. Supplying neither is unsupported.');
      }

      var previous = connection.parsedStatements[this.name];

      if (this.text && previous && this.text !== previous) {
        return new Error("Prepared statements must be unique - '".concat(this.name, "' was used for a different statement"));
      }

      if (this.values && !Array.isArray(this.values)) {
        return new Error('Query values must be an array');
      }

      if (this.requiresPreparation()) {
        this.prepare(connection);
      } else {
        connection.query(this.text);
      }

      return null;
    }
  }, {
    key: "hasBeenParsed",
    value: function hasBeenParsed(connection) {
      return this.name && connection.parsedStatements[this.name];
    }
  }, {
    key: "handlePortalSuspended",
    value: function handlePortalSuspended(connection) {
      this._getRows(connection, this.rows);
    }
  }, {
    key: "_getRows",
    value: function _getRows(connection, rows) {
      connection.execute({
        portal: this.portal,
        rows: rows
      }); // if we're not reading pages of rows send the sync command
      // to indicate the pipeline is finished

      if (!rows) {
        connection.sync();
      } else {
        // otherwise flush the call out to read more rows
        connection.flush();
      }
    } // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY

  }, {
    key: "prepare",
    value: function prepare(connection) {
      // prepared statements need sync to be called after each command
      // complete or when an error is encountered
      this.isPreparedStatement = true; // TODO refactor this poor encapsulation

      if (!this.hasBeenParsed(connection)) {
        connection.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      } // because we're mapping user supplied values to
      // postgres wire protocol compatible values it could
      // throw an exception, so try/catch this section


      try {
        connection.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils.prepareValue
        });
      } catch (err) {
        this.handleError(err, connection);
        return;
      }

      connection.describe({
        type: 'P',
        name: this.portal || ''
      });

      this._getRows(connection, this.rows);
    }
  }, {
    key: "handleCopyInResponse",
    value: function handleCopyInResponse(connection) {
      connection.sendCopyFail('No source stream defined');
    } // eslint-disable-next-line no-unused-vars

  }, {
    key: "handleCopyData",
    value: function handleCopyData(msg, connection) {// noop
    }
  }]);

  return Query;
}(EventEmitter);

module.exports = Query;