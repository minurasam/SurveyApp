'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EventEmitter = require('events').EventEmitter;

var util = require('util');

var utils = require('./utils');

var sasl = require('./sasl');

var pgPass = require('pgpass');

var TypeOverrides = require('./type-overrides');

var ConnectionParameters = require('./connection-parameters');

var Query = require('./query');

var defaults = require('./defaults');

var Connection = require('./connection');

var Client =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Client, _EventEmitter);

  function Client(config) {
    var _this;

    _classCallCheck(this, Client);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Client).call(this));
    _this.connectionParameters = new ConnectionParameters(config);
    _this.user = _this.connectionParameters.user;
    _this.database = _this.connectionParameters.database;
    _this.port = _this.connectionParameters.port;
    _this.host = _this.connectionParameters.host; // "hiding" the password so it doesn't show up in stack traces
    // or if the client is console.logged

    Object.defineProperty(_assertThisInitialized(_this), 'password', {
      configurable: true,
      enumerable: false,
      writable: true,
      value: _this.connectionParameters.password
    });
    _this.replication = _this.connectionParameters.replication;
    var c = config || {};
    _this._Promise = c.Promise || global.Promise;
    _this._types = new TypeOverrides(c.types);
    _this._ending = false;
    _this._connecting = false;
    _this._connected = false;
    _this._connectionError = false;
    _this._queryable = true;
    _this.connection = c.connection || new Connection({
      stream: c.stream,
      ssl: _this.connectionParameters.ssl,
      keepAlive: c.keepAlive || false,
      keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
      encoding: _this.connectionParameters.client_encoding || 'utf8'
    });
    _this.queryQueue = [];
    _this.binary = c.binary || defaults.binary;
    _this.processID = null;
    _this.secretKey = null;
    _this.ssl = _this.connectionParameters.ssl || false; // As with Password, make SSL->Key (the private key) non-enumerable.
    // It won't show up in stack traces
    // or if the client is console.logged

    if (_this.ssl && _this.ssl.key) {
      Object.defineProperty(_this.ssl, 'key', {
        enumerable: false
      });
    }

    _this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    return _this;
  }

  _createClass(Client, [{
    key: "_errorAllQueries",
    value: function _errorAllQueries(err) {
      var _this2 = this;

      var enqueueError = function enqueueError(query) {
        process.nextTick(function () {
          query.handleError(err, _this2.connection);
        });
      };

      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }

      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
  }, {
    key: "_connect",
    value: function _connect(callback) {
      var _this3 = this;

      var self = this;
      var con = this.connection;
      this._connectionCallback = callback;

      if (this._connecting || this._connected) {
        var err = new Error('Client has already been connected. You cannot reuse a client.');
        process.nextTick(function () {
          callback(err);
        });
        return;
      }

      this._connecting = true;
      this.connectionTimeoutHandle;

      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(function () {
          con._ending = true;
          con.stream.destroy(new Error('timeout expired'));
        }, this._connectionTimeoutMillis);
      }

      if (this.host && this.host.indexOf('/') === 0) {
        con.connect(this.host + '/.s.PGSQL.' + this.port);
      } else {
        con.connect(this.port, this.host);
      } // once connection is established send startup message


      con.on('connect', function () {
        if (self.ssl) {
          con.requestSsl();
        } else {
          con.startup(self.getStartupConf());
        }
      });
      con.on('sslconnect', function () {
        con.startup(self.getStartupConf());
      });

      this._attachListeners(con);

      con.once('end', function () {
        var error = _this3._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly');
        clearTimeout(_this3.connectionTimeoutHandle);

        _this3._errorAllQueries(error);

        if (!_this3._ending) {
          // if the connection is ended without us calling .end()
          // on this client then we have an unexpected disconnection
          // treat this as an error unless we've already emitted an error
          // during connection.
          if (_this3._connecting && !_this3._connectionError) {
            if (_this3._connectionCallback) {
              _this3._connectionCallback(error);
            } else {
              _this3._handleErrorEvent(error);
            }
          } else if (!_this3._connectionError) {
            _this3._handleErrorEvent(error);
          }
        }

        process.nextTick(function () {
          _this3.emit('end');
        });
      });
    }
  }, {
    key: "connect",
    value: function connect(callback) {
      var _this4 = this;

      if (callback) {
        this._connect(callback);

        return;
      }

      return new this._Promise(function (resolve, reject) {
        _this4._connect(function (error) {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    }
  }, {
    key: "_attachListeners",
    value: function _attachListeners(con) {
      // password request handling
      con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this)); // password request handling

      con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this)); // password request handling (SASL)

      con.on('authenticationSASL', this._handleAuthSASL.bind(this));
      con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this));
      con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this));
      con.on('backendKeyData', this._handleBackendKeyData.bind(this));
      con.on('error', this._handleErrorEvent.bind(this));
      con.on('errorMessage', this._handleErrorMessage.bind(this));
      con.on('readyForQuery', this._handleReadyForQuery.bind(this));
      con.on('notice', this._handleNotice.bind(this));
      con.on('rowDescription', this._handleRowDescription.bind(this));
      con.on('dataRow', this._handleDataRow.bind(this));
      con.on('portalSuspended', this._handlePortalSuspended.bind(this));
      con.on('emptyQuery', this._handleEmptyQuery.bind(this));
      con.on('commandComplete', this._handleCommandComplete.bind(this));
      con.on('parseComplete', this._handleParseComplete.bind(this));
      con.on('copyInResponse', this._handleCopyInResponse.bind(this));
      con.on('copyData', this._handleCopyData.bind(this));
      con.on('notification', this._handleNotification.bind(this));
    } // TODO(bmc): deprecate pgpass "built in" integration since this.password can be a function
    // it can be supplied by the user if required - this is a breaking change!

  }, {
    key: "_checkPgPass",
    value: function _checkPgPass(cb) {
      var _this5 = this;

      var con = this.connection;

      if (typeof this.password === 'function') {
        this._Promise.resolve().then(function () {
          return _this5.password();
        }).then(function (pass) {
          if (pass !== undefined) {
            if (typeof pass !== 'string') {
              con.emit('error', new TypeError('Password must be a string'));
              return;
            }

            _this5.connectionParameters.password = _this5.password = pass;
          } else {
            _this5.connectionParameters.password = _this5.password = null;
          }

          cb();
        })["catch"](function (err) {
          con.emit('error', err);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        pgPass(this.connectionParameters, function (pass) {
          if (undefined !== pass) {
            _this5.connectionParameters.password = _this5.password = pass;
          }

          cb();
        });
      }
    }
  }, {
    key: "_handleAuthCleartextPassword",
    value: function _handleAuthCleartextPassword(msg) {
      var _this6 = this;

      this._checkPgPass(function () {
        _this6.connection.password(_this6.password);
      });
    }
  }, {
    key: "_handleAuthMD5Password",
    value: function _handleAuthMD5Password(msg) {
      var _this7 = this;

      this._checkPgPass(function () {
        var hashedPassword = utils.postgresMd5PasswordHash(_this7.user, _this7.password, msg.salt);

        _this7.connection.password(hashedPassword);
      });
    }
  }, {
    key: "_handleAuthSASL",
    value: function _handleAuthSASL(msg) {
      var _this8 = this;

      this._checkPgPass(function () {
        _this8.saslSession = sasl.startSession(msg.mechanisms);

        _this8.connection.sendSASLInitialResponseMessage(_this8.saslSession.mechanism, _this8.saslSession.response);
      });
    }
  }, {
    key: "_handleAuthSASLContinue",
    value: function _handleAuthSASLContinue(msg) {
      sasl.continueSession(this.saslSession, this.password, msg.data);
      this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
    }
  }, {
    key: "_handleAuthSASLFinal",
    value: function _handleAuthSASLFinal(msg) {
      sasl.finalizeSession(this.saslSession, msg.data);
      this.saslSession = null;
    }
  }, {
    key: "_handleBackendKeyData",
    value: function _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
  }, {
    key: "_handleReadyForQuery",
    value: function _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle); // process possible callback argument to Client#connect

        if (this._connectionCallback) {
          this._connectionCallback(null, this); // remove callback for proper error handling
          // after the connect event


          this._connectionCallback = null;
        }

        this.emit('connect');
      }

      var activeQuery = this.activeQuery;
      this.activeQuery = null;
      this.readyForQuery = true;

      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }

      this._pulseQueryQueue();
    } // if we receieve an error event or error message
    // during the connection process we handle it here

  }, {
    key: "_handleErrorWhileConnecting",
    value: function _handleErrorWhileConnecting(err) {
      if (this._connectionError) {
        // TODO(bmc): this is swallowing errors - we shouldn't do this
        return;
      }

      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);

      if (this._connectionCallback) {
        return this._connectionCallback(err);
      }

      this.emit('error', err);
    } // if we're connected and we receive an error event from the connection
    // this means the socket is dead - do a hard abort of all queries and emit
    // the socket error on the client as well

  }, {
    key: "_handleErrorEvent",
    value: function _handleErrorEvent(err) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err);
      }

      this._queryable = false;

      this._errorAllQueries(err);

      this.emit('error', err);
    } // handle error messages from the postgres backend

  }, {
    key: "_handleErrorMessage",
    value: function _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }

      var activeQuery = this.activeQuery;

      if (!activeQuery) {
        this._handleErrorEvent(msg);

        return;
      }

      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
  }, {
    key: "_handleRowDescription",
    value: function _handleRowDescription(msg) {
      // delegate rowDescription to active query
      this.activeQuery.handleRowDescription(msg);
    }
  }, {
    key: "_handleDataRow",
    value: function _handleDataRow(msg) {
      // delegate dataRow to active query
      this.activeQuery.handleDataRow(msg);
    }
  }, {
    key: "_handlePortalSuspended",
    value: function _handlePortalSuspended(msg) {
      // delegate portalSuspended to active query
      this.activeQuery.handlePortalSuspended(this.connection);
    }
  }, {
    key: "_handleEmptyQuery",
    value: function _handleEmptyQuery(msg) {
      // delegate emptyQuery to active query
      this.activeQuery.handleEmptyQuery(this.connection);
    }
  }, {
    key: "_handleCommandComplete",
    value: function _handleCommandComplete(msg) {
      // delegate commandComplete to active query
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
  }, {
    key: "_handleParseComplete",
    value: function _handleParseComplete(msg) {
      // if a prepared statement has a name and properly parses
      // we track that its already been executed so we don't parse
      // it again on the same client
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
  }, {
    key: "_handleCopyInResponse",
    value: function _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
  }, {
    key: "_handleCopyData",
    value: function _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
  }, {
    key: "_handleNotification",
    value: function _handleNotification(msg) {
      this.emit('notification', msg);
    }
  }, {
    key: "_handleNotice",
    value: function _handleNotice(msg) {
      this.emit('notice', msg);
    }
  }, {
    key: "getStartupConf",
    value: function getStartupConf() {
      var params = this.connectionParameters;
      var data = {
        user: params.user,
        database: params.database
      };
      var appName = params.application_name || params.fallback_application_name;

      if (appName) {
        data.application_name = appName;
      }

      if (params.replication) {
        data.replication = '' + params.replication;
      }

      if (params.statement_timeout) {
        data.statement_timeout = String(parseInt(params.statement_timeout, 10));
      }

      if (params.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
      }

      if (params.options) {
        data.options = params.options;
      }

      return data;
    }
  }, {
    key: "cancel",
    value: function cancel(client, query) {
      if (client.activeQuery === query) {
        var con = this.connection;

        if (this.host && this.host.indexOf('/') === 0) {
          con.connect(this.host + '/.s.PGSQL.' + this.port);
        } else {
          con.connect(this.port, this.host);
        } // once connection is established send cancel message


        con.on('connect', function () {
          con.cancel(client.processID, client.secretKey);
        });
      } else if (client.queryQueue.indexOf(query) !== -1) {
        client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
      }
    }
  }, {
    key: "setTypeParser",
    value: function setTypeParser(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    }
  }, {
    key: "getTypeParser",
    value: function getTypeParser(oid, format) {
      return this._types.getTypeParser(oid, format);
    } // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c

  }, {
    key: "escapeIdentifier",
    value: function escapeIdentifier(str) {
      return '"' + str.replace(/"/g, '""') + '"';
    } // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c

  }, {
    key: "escapeLiteral",
    value: function escapeLiteral(str) {
      var hasBackslash = false;
      var escaped = "'";

      for (var i = 0; i < str.length; i++) {
        var c = str[i];

        if (c === "'") {
          escaped += c + c;
        } else if (c === '\\') {
          escaped += c + c;
          hasBackslash = true;
        } else {
          escaped += c;
        }
      }

      escaped += "'";

      if (hasBackslash === true) {
        escaped = ' E' + escaped;
      }

      return escaped;
    }
  }, {
    key: "_pulseQueryQueue",
    value: function _pulseQueryQueue() {
      var _this9 = this;

      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();

        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          var queryError = this.activeQuery.submit(this.connection);

          if (queryError) {
            process.nextTick(function () {
              _this9.activeQuery.handleError(queryError, _this9.connection);

              _this9.readyForQuery = true;

              _this9._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit('drain');
        }
      }
    }
  }, {
    key: "query",
    value: function query(config, values, callback) {
      var _this10 = this;

      // can take in strings, config object or query object
      var query;
      var result;
      var readTimeout;
      var readTimeoutTimer;
      var queryCallback;

      if (config === null || config === undefined) {
        throw new TypeError('Client was passed a null or undefined query');
      } else if (typeof config.submit === 'function') {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query = config;

        if (typeof values === 'function') {
          query.callback = query.callback || values;
        }
      } else {
        readTimeout = this.connectionParameters.query_timeout;
        query = new Query(config, values, callback);

        if (!query.callback) {
          result = new this._Promise(function (resolve, reject) {
            query.callback = function (err, res) {
              return err ? reject(err) : resolve(res);
            };
          });
        }
      }

      if (readTimeout) {
        queryCallback = query.callback;
        readTimeoutTimer = setTimeout(function () {
          var error = new Error('Query read timeout');
          process.nextTick(function () {
            query.handleError(error, _this10.connection);
          });
          queryCallback(error); // we already returned an error,
          // just do nothing if query completes

          query.callback = function () {}; // Remove from queue


          var index = _this10.queryQueue.indexOf(query);

          if (index > -1) {
            _this10.queryQueue.splice(index, 1);
          }

          _this10._pulseQueryQueue();
        }, readTimeout);

        query.callback = function (err, res) {
          clearTimeout(readTimeoutTimer);
          queryCallback(err, res);
        };
      }

      if (this.binary && !query.binary) {
        query.binary = true;
      }

      if (query._result && !query._result._types) {
        query._result._types = this._types;
      }

      if (!this._queryable) {
        process.nextTick(function () {
          query.handleError(new Error('Client has encountered a connection error and is not queryable'), _this10.connection);
        });
        return result;
      }

      if (this._ending) {
        process.nextTick(function () {
          query.handleError(new Error('Client was closed and is not queryable'), _this10.connection);
        });
        return result;
      }

      this.queryQueue.push(query);

      this._pulseQueryQueue();

      return result;
    }
  }, {
    key: "end",
    value: function end(cb) {
      var _this11 = this;

      this._ending = true; // if we have never connected, then end is a noop, callback immediately

      if (!this.connection._connecting) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }

      if (this.activeQuery || !this._queryable) {
        // if we have an active query we need to force a disconnect
        // on the socket - otherwise a hung query could block end forever
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }

      if (cb) {
        this.connection.once('end', cb);
      } else {
        return new this._Promise(function (resolve) {
          _this11.connection.once('end', resolve);
        });
      }
    }
  }]);

  return Client;
}(EventEmitter); // expose a Query constructor


Client.Query = Query;
module.exports = Client;