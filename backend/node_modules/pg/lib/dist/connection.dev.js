'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var net = require('net');

var EventEmitter = require('events').EventEmitter;

var _require = require('pg-protocol'),
    parse = _require.parse,
    serialize = _require.serialize;

var flushBuffer = serialize.flush();
var syncBuffer = serialize.sync();
var endBuffer = serialize.end(); // TODO(bmc) support binary mode at some point

var Connection =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Connection, _EventEmitter);

  function Connection(config) {
    var _this;

    _classCallCheck(this, Connection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connection).call(this));
    config = config || {};
    _this.stream = config.stream || new net.Socket();
    _this._keepAlive = config.keepAlive;
    _this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
    _this.lastBuffer = false;
    _this.parsedStatements = {};
    _this.ssl = config.ssl || false;
    _this._ending = false;
    _this._emitMessage = false;

    var self = _assertThisInitialized(_this);

    _this.on('newListener', function (eventName) {
      if (eventName === 'message') {
        self._emitMessage = true;
      }
    });

    return _this;
  }

  _createClass(Connection, [{
    key: "connect",
    value: function connect(port, host) {
      var self = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once('connect', function () {
        if (self._keepAlive) {
          self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);
        }

        self.emit('connect');
      });

      var reportStreamError = function reportStreamError(error) {
        // errors about disconnections should be ignored during disconnect
        if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {
          return;
        }

        self.emit('error', error);
      };

      this.stream.on('error', reportStreamError);
      this.stream.on('close', function () {
        self.emit('end');
      });

      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }

      this.stream.once('data', function (buffer) {
        var responseCode = buffer.toString('utf8');

        switch (responseCode) {
          case 'S':
            // Server supports SSL connections, continue with a secure connection
            break;

          case 'N':
            // Server does not support SSL connections
            self.stream.end();
            return self.emit('error', new Error('The server does not support SSL connections'));

          default:
            // Any other response byte, including 'E' (ErrorResponse) indicating a server error
            self.stream.end();
            return self.emit('error', new Error('There was an error establishing an SSL connection'));
        }

        var tls = require('tls');

        var options = {
          socket: self.stream
        };

        if (self.ssl !== true) {
          Object.assign(options, self.ssl);

          if ('key' in self.ssl) {
            options.key = self.ssl.key;
          }
        }

        if (net.isIP(host) === 0) {
          options.servername = host;
        }

        try {
          self.stream = tls.connect(options);
        } catch (err) {
          return self.emit('error', err);
        }

        self.attachListeners(self.stream);
        self.stream.on('error', reportStreamError);
        self.emit('sslconnect');
      });
    }
  }, {
    key: "attachListeners",
    value: function attachListeners(stream) {
      var _this2 = this;

      stream.on('end', function () {
        _this2.emit('end');
      });
      parse(stream, function (msg) {
        var eventName = msg.name === 'error' ? 'errorMessage' : msg.name;

        if (_this2._emitMessage) {
          _this2.emit('message', msg);
        }

        _this2.emit(eventName, msg);
      });
    }
  }, {
    key: "requestSsl",
    value: function requestSsl() {
      this.stream.write(serialize.requestSsl());
    }
  }, {
    key: "startup",
    value: function startup(config) {
      this.stream.write(serialize.startup(config));
    }
  }, {
    key: "cancel",
    value: function cancel(processID, secretKey) {
      this._send(serialize.cancel(processID, secretKey));
    }
  }, {
    key: "password",
    value: function password(_password) {
      this._send(serialize.password(_password));
    }
  }, {
    key: "sendSASLInitialResponseMessage",
    value: function sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
  }, {
    key: "sendSCRAMClientFinalMessage",
    value: function sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize.sendSCRAMClientFinalMessage(additionalData));
    }
  }, {
    key: "_send",
    value: function _send(buffer) {
      if (!this.stream.writable) {
        return false;
      }

      return this.stream.write(buffer);
    }
  }, {
    key: "query",
    value: function query(text) {
      this._send(serialize.query(text));
    } // send parse message

  }, {
    key: "parse",
    value: function parse(query) {
      this._send(serialize.parse(query));
    } // send bind message

  }, {
    key: "bind",
    value: function bind(config) {
      this._send(serialize.bind(config));
    } // send execute message

  }, {
    key: "execute",
    value: function execute(config) {
      this._send(serialize.execute(config));
    }
  }, {
    key: "flush",
    value: function flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
  }, {
    key: "sync",
    value: function sync() {
      this._ending = true;

      this._send(flushBuffer);

      this._send(syncBuffer);
    }
  }, {
    key: "end",
    value: function end() {
      var _this3 = this;

      // 0x58 = 'X'
      this._ending = true;

      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }

      return this.stream.write(endBuffer, function () {
        _this3.stream.end();
      });
    }
  }, {
    key: "close",
    value: function close(msg) {
      this._send(serialize.close(msg));
    }
  }, {
    key: "describe",
    value: function describe(msg) {
      this._send(serialize.describe(msg));
    }
  }, {
    key: "sendCopyFromChunk",
    value: function sendCopyFromChunk(chunk) {
      this._send(serialize.copyData(chunk));
    }
  }, {
    key: "endCopyFrom",
    value: function endCopyFrom() {
      this._send(serialize.copyDone());
    }
  }, {
    key: "sendCopyFail",
    value: function sendCopyFail(msg) {
      this._send(serialize.copyFail(msg));
    }
  }]);

  return Connection;
}(EventEmitter);

module.exports = Connection;