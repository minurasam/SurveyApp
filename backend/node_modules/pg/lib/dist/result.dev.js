'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var types = require('pg-types');

var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/; // result object returned from query
// in the 'end' event and also
// passed as second argument to provided callback

var Result =
/*#__PURE__*/
function () {
  function Result(rowMode, types) {
    _classCallCheck(this, Result);

    this.command = null;
    this.rowCount = null;
    this.oid = null;
    this.rows = [];
    this.fields = [];
    this._parsers = undefined;
    this._types = types;
    this.RowCtor = null;
    this.rowAsArray = rowMode === 'array';

    if (this.rowAsArray) {
      this.parseRow = this._parseRowAsArray;
    }
  } // adds a command complete message


  _createClass(Result, [{
    key: "addCommandComplete",
    value: function addCommandComplete(msg) {
      var match;

      if (msg.text) {
        // pure javascript
        match = matchRegexp.exec(msg.text);
      } else {
        // native bindings
        match = matchRegexp.exec(msg.command);
      }

      if (match) {
        this.command = match[1];

        if (match[3]) {
          // COMMMAND OID ROWS
          this.oid = parseInt(match[2], 10);
          this.rowCount = parseInt(match[3], 10);
        } else if (match[2]) {
          // COMMAND ROWS
          this.rowCount = parseInt(match[2], 10);
        }
      }
    }
  }, {
    key: "_parseRowAsArray",
    value: function _parseRowAsArray(rowData) {
      var row = new Array(rowData.length);

      for (var i = 0, len = rowData.length; i < len; i++) {
        var rawValue = rowData[i];

        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }

      return row;
    }
  }, {
    key: "parseRow",
    value: function parseRow(rowData) {
      var row = {};

      for (var i = 0, len = rowData.length; i < len; i++) {
        var rawValue = rowData[i];
        var field = this.fields[i].name;

        if (rawValue !== null) {
          row[field] = this._parsers[i](rawValue);
        } else {
          row[field] = null;
        }
      }

      return row;
    }
  }, {
    key: "addRow",
    value: function addRow(row) {
      this.rows.push(row);
    }
  }, {
    key: "addFields",
    value: function addFields(fieldDescriptions) {
      // clears field definitions
      // multiple query statements in 1 action can result in multiple sets
      // of rowDescriptions...eg: 'select NOW(); select 1::int;'
      // you need to reset the fields
      this.fields = fieldDescriptions;

      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }

      for (var i = 0; i < fieldDescriptions.length; i++) {
        var desc = fieldDescriptions[i];

        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || 'text');
        } else {
          this._parsers[i] = types.getTypeParser(desc.dataTypeID, desc.format || 'text');
        }
      }
    }
  }]);

  return Result;
}();

module.exports = Result;