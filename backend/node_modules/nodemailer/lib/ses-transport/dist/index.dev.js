'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EventEmitter = require('events');

var packageData = require('../../package.json');

var shared = require('../shared');

var LeWindows = require('../mime-node/le-windows');
/**
 * Generates a Transport object for AWS SES
 *
 * Possible options can be the following:
 *
 *  * **sendingRate** optional Number specifying how many messages per second should be delivered to SES
 *  * **maxConnections** optional Number specifying max number of parallel connections to SES
 *
 * @constructor
 * @param {Object} optional config parameter
 */


var SESTransport =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(SESTransport, _EventEmitter);

  function SESTransport(options) {
    var _this;

    _classCallCheck(this, SESTransport);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SESTransport).call(this));
    options = options || {};
    _this.options = options || {};
    _this.ses = _this.options.SES;
    _this.name = 'SESTransport';
    _this.version = packageData.version;
    _this.logger = shared.getLogger(_this.options, {
      component: _this.options.component || 'ses-transport'
    }); // parallel sending connections

    _this.maxConnections = Number(_this.options.maxConnections) || Infinity;
    _this.connections = 0; // max messages per second

    _this.sendingRate = Number(_this.options.sendingRate) || Infinity;
    _this.sendingRateTTL = null;
    _this.rateInterval = 1000; // milliseconds

    _this.rateMessages = [];
    _this.pending = [];
    _this.idling = true;
    setImmediate(function () {
      if (_this.idling) {
        _this.emit('idle');
      }
    });
    return _this;
  }
  /**
   * Schedules a sending of a message
   *
   * @param {Object} emailMessage MailComposer object
   * @param {Function} callback Callback function to run when the sending is completed
   */


  _createClass(SESTransport, [{
    key: "send",
    value: function send(mail, callback) {
      var _this2 = this;

      if (this.connections >= this.maxConnections) {
        this.idling = false;
        return this.pending.push({
          mail: mail,
          callback: callback
        });
      }

      if (!this._checkSendingRate()) {
        this.idling = false;
        return this.pending.push({
          mail: mail,
          callback: callback
        });
      }

      this._send(mail, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        setImmediate(function () {
          return callback.apply(void 0, args);
        });

        _this2._sent();
      });
    }
  }, {
    key: "_checkRatedQueue",
    value: function _checkRatedQueue() {
      var _this3 = this;

      if (this.connections >= this.maxConnections || !this._checkSendingRate()) {
        return;
      }

      if (!this.pending.length) {
        if (!this.idling) {
          this.idling = true;
          this.emit('idle');
        }

        return;
      }

      var next = this.pending.shift();

      this._send(next.mail, function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        setImmediate(function () {
          return next.callback.apply(next, args);
        });

        _this3._sent();
      });
    }
  }, {
    key: "_checkSendingRate",
    value: function _checkSendingRate() {
      var _this4 = this;

      clearTimeout(this.sendingRateTTL);
      var now = Date.now();
      var oldest = false; // delete older messages

      for (var i = this.rateMessages.length - 1; i >= 0; i--) {
        if (this.rateMessages[i].ts >= now - this.rateInterval && (!oldest || this.rateMessages[i].ts < oldest)) {
          oldest = this.rateMessages[i].ts;
        }

        if (this.rateMessages[i].ts < now - this.rateInterval && !this.rateMessages[i].pending) {
          this.rateMessages.splice(i, 1);
        }
      }

      if (this.rateMessages.length < this.sendingRate) {
        return true;
      }

      var delay = Math.max(oldest + 1001, now + 20);
      this.sendingRateTTL = setTimeout(function () {
        return _this4._checkRatedQueue();
      }, now - delay);

      try {
        this.sendingRateTTL.unref();
      } catch (E) {// Ignore. Happens on envs with non-node timer implementation
      }

      return false;
    }
  }, {
    key: "_sent",
    value: function _sent() {
      this.connections--;

      this._checkRatedQueue();
    }
    /**
     * Returns true if there are free slots in the queue
     */

  }, {
    key: "isIdle",
    value: function isIdle() {
      return this.idling;
    }
    /**
     * Compiles a mailcomposer message and forwards it to SES
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */

  }, {
    key: "_send",
    value: function _send(mail, callback) {
      var _this5 = this;

      var statObject = {
        ts: Date.now(),
        pending: true
      };
      this.connections++;
      this.rateMessages.push(statObject);
      var envelope = mail.data.envelope || mail.message.getEnvelope();
      var messageId = mail.message.messageId();
      var recipients = [].concat(envelope.to || []);

      if (recipients.length > 3) {
        recipients.push('...and ' + recipients.splice(2).length + ' more');
      }

      this.logger.info({
        tnx: 'send',
        messageId: messageId
      }, 'Sending message %s to <%s>', messageId, recipients.join(', '));

      var getRawMessage = function getRawMessage(next) {
        // do not use Message-ID and Date in DKIM signature
        if (!mail.data._dkim) {
          mail.data._dkim = {};
        }

        if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === 'string') {
          mail.data._dkim.skipFields += ':date:message-id';
        } else {
          mail.data._dkim.skipFields = 'date:message-id';
        }

        var sourceStream = mail.message.createReadStream();
        var stream = sourceStream.pipe(new LeWindows());
        var chunks = [];
        var chunklen = 0;
        stream.on('readable', function () {
          var chunk;

          while ((chunk = stream.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
          }
        });
        sourceStream.once('error', function (err) {
          return stream.emit('error', err);
        });
        stream.once('error', function (err) {
          next(err);
        });
        stream.once('end', function () {
          return next(null, Buffer.concat(chunks, chunklen));
        });
      };

      setImmediate(function () {
        return getRawMessage(function (err, raw) {
          if (err) {
            _this5.logger.error({
              err: err,
              tnx: 'send',
              messageId: messageId
            }, 'Failed creating message for %s. %s', messageId, err.message);

            statObject.pending = false;
            return callback(err);
          }

          var sesMessage = {
            RawMessage: {
              // required
              Data: raw // required

            },
            Source: envelope.from,
            Destinations: envelope.to
          };
          Object.keys(mail.data.ses || {}).forEach(function (key) {
            sesMessage[key] = mail.data.ses[key];
          });
          var ses = (_this5.ses.aws ? _this5.ses.ses : _this5.ses) || {};
          var aws = _this5.ses.aws || {};

          var getRegion = function getRegion(cb) {
            if (ses.config && typeof ses.config.region === 'function') {
              // promise
              return ses.config.region().then(function (region) {
                return cb(null, region);
              })["catch"](function (err) {
                return cb(err);
              });
            }

            return cb(null, ses.config && ses.config.region || 'us-east-1');
          };

          getRegion(function (err, region) {
            if (err || !region) {
              region = 'us-east-1';
            }

            var sendPromise;

            if (typeof ses.send === 'function' && aws.SendRawEmailCommand) {
              // v3 API
              sendPromise = ses.send(new aws.SendRawEmailCommand(sesMessage));
            } else {
              // v2 API
              sendPromise = ses.sendRawEmail(sesMessage).promise();
            }

            sendPromise.then(function (data) {
              if (region === 'us-east-1') {
                region = 'email';
              }

              statObject.pending = false;
              callback(null, {
                envelope: {
                  from: envelope.from,
                  to: envelope.to
                },
                messageId: '<' + data.MessageId + (!/@/.test(data.MessageId) ? '@' + region + '.amazonses.com' : '') + '>',
                response: data.MessageId,
                raw: raw
              });
            })["catch"](function (err) {
              _this5.logger.error({
                err: err,
                tnx: 'send'
              }, 'Send error for %s: %s', messageId, err.message);

              statObject.pending = false;
              callback(err);
            });
          });
        });
      });
    }
    /**
     * Verifies SES configuration
     *
     * @param {Function} callback Callback function
     */

  }, {
    key: "verify",
    value: function verify(callback) {
      var promise;
      var ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
      var aws = this.ses.aws || {};
      var sesMessage = {
        RawMessage: {
          // required
          Data: 'From: invalid@invalid\r\nTo: invalid@invalid\r\n Subject: Invalid\r\n\r\nInvalid'
        },
        Source: 'invalid@invalid',
        Destinations: ['invalid@invalid']
      };

      var cb = function cb(err) {
        if (err && err.code !== 'InvalidParameterValue') {
          return callback(err);
        }

        return callback(null, true);
      };

      if (!callback) {
        promise = new Promise(function (resolve, reject) {
          callback = shared.callbackPromise(resolve, reject);
        });
      }

      if (typeof ses.send === 'function' && aws.SendRawEmailCommand) {
        // v3 API
        ses.send(new aws.SendRawEmailCommand(sesMessage), cb);
      } else {
        // v2 API
        ses.sendRawEmail(sesMessage, cb).promise();
      }

      return promise;
    }
  }]);

  return SESTransport;
}(EventEmitter);

module.exports = SESTransport;