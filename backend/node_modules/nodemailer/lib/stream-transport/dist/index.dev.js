'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var packageData = require('../../package.json');

var shared = require('../shared');
/**
 * Generates a Transport object for streaming
 *
 * Possible options can be the following:
 *
 *  * **buffer** if true, then returns the message as a Buffer object instead of a stream
 *  * **newline** either 'windows' or 'unix'
 *
 * @constructor
 * @param {Object} optional config parameter
 */


var StreamTransport =
/*#__PURE__*/
function () {
  function StreamTransport(options) {
    _classCallCheck(this, StreamTransport);

    options = options || {};
    this.options = options || {};
    this.name = 'StreamTransport';
    this.version = packageData.version;
    this.logger = shared.getLogger(this.options, {
      component: this.options.component || 'stream-transport'
    });
    this.winbreak = ['win', 'windows', 'dos', '\r\n'].includes((options.newline || '').toString().toLowerCase());
  }
  /**
   * Compiles a mailcomposer message and forwards it to handler that sends it
   *
   * @param {Object} emailMessage MailComposer object
   * @param {Function} callback Callback function to run when the sending is completed
   */


  _createClass(StreamTransport, [{
    key: "send",
    value: function send(mail, done) {
      var _this = this;

      // We probably need this in the output
      mail.message.keepBcc = true;
      var envelope = mail.data.envelope || mail.message.getEnvelope();
      var messageId = mail.message.messageId();
      var recipients = [].concat(envelope.to || []);

      if (recipients.length > 3) {
        recipients.push('...and ' + recipients.splice(2).length + ' more');
      }

      this.logger.info({
        tnx: 'send',
        messageId: messageId
      }, 'Sending message %s to <%s> using %s line breaks', messageId, recipients.join(', '), this.winbreak ? '<CR><LF>' : '<LF>');
      setImmediate(function () {
        var stream;

        try {
          stream = mail.message.createReadStream();
        } catch (E) {
          _this.logger.error({
            err: E,
            tnx: 'send',
            messageId: messageId
          }, 'Creating send stream failed for %s. %s', messageId, E.message);

          return done(E);
        }

        if (!_this.options.buffer) {
          stream.once('error', function (err) {
            _this.logger.error({
              err: err,
              tnx: 'send',
              messageId: messageId
            }, 'Failed creating message for %s. %s', messageId, err.message);
          });
          return done(null, {
            envelope: mail.data.envelope || mail.message.getEnvelope(),
            messageId: messageId,
            message: stream
          });
        }

        var chunks = [];
        var chunklen = 0;
        stream.on('readable', function () {
          var chunk;

          while ((chunk = stream.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
          }
        });
        stream.once('error', function (err) {
          _this.logger.error({
            err: err,
            tnx: 'send',
            messageId: messageId
          }, 'Failed creating message for %s. %s', messageId, err.message);

          return done(err);
        });
        stream.on('end', function () {
          return done(null, {
            envelope: mail.data.envelope || mail.message.getEnvelope(),
            messageId: messageId,
            message: Buffer.concat(chunks, chunklen)
          });
        });
      });
    }
  }]);

  return StreamTransport;
}();

module.exports = StreamTransport;