'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EventEmitter = require('events');

var shared = require('../shared');

var mimeTypes = require('../mime-funcs/mime-types');

var MailComposer = require('../mail-composer');

var DKIM = require('../dkim');

var httpProxyClient = require('../smtp-connection/http-proxy-client');

var util = require('util');

var urllib = require('url');

var packageData = require('../../package.json');

var MailMessage = require('./mail-message');

var net = require('net');

var dns = require('dns');

var crypto = require('crypto');
/**
 * Creates an object for exposing the Mail API
 *
 * @constructor
 * @param {Object} transporter Transport object instance to pass the mails to
 */


var Mail =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Mail, _EventEmitter);

  function Mail(transporter, options, defaults) {
    var _this;

    _classCallCheck(this, Mail);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Mail).call(this));
    _this.options = options || {};
    _this._defaults = defaults || {};
    _this._defaultPlugins = {
      compile: [function () {
        var _this2;

        return (_this2 = _this)._convertDataImages.apply(_this2, arguments);
      }],
      stream: []
    };
    _this._userPlugins = {
      compile: [],
      stream: []
    };
    _this.meta = new Map();
    _this.dkim = _this.options.dkim ? new DKIM(_this.options.dkim) : false;
    _this.transporter = transporter;
    _this.transporter.mailer = _assertThisInitialized(_this);
    _this.logger = shared.getLogger(_this.options, {
      component: _this.options.component || 'mail'
    });

    _this.logger.debug({
      tnx: 'create'
    }, 'Creating transport: %s', _this.getVersionString()); // setup emit handlers for the transporter


    if (typeof _this.transporter.on === 'function') {
      // deprecated log interface
      _this.transporter.on('log', function (log) {
        _this.logger.debug({
          tnx: 'transport'
        }, '%s: %s', log.type, log.message);
      }); // transporter errors


      _this.transporter.on('error', function (err) {
        _this.logger.error({
          err: err,
          tnx: 'transport'
        }, 'Transport Error: %s', err.message);

        _this.emit('error', err);
      }); // indicates if the sender has became idle


      _this.transporter.on('idle', function () {
        var _this3;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        (_this3 = _this).emit.apply(_this3, ['idle'].concat(args));
      });
    }
    /**
     * Optional methods passed to the underlying transport object
     */


    ['close', 'isIdle', 'verify'].forEach(function (method) {
      _this[method] = function () {
        if (typeof _this.transporter[method] === 'function') {
          var _this$transporter;

          return (_this$transporter = _this.transporter)[method].apply(_this$transporter, arguments);
        } else {
          _this.logger.warn({
            tnx: 'transport',
            methodName: method
          }, 'Non existing method %s called for transport', method);

          return false;
        }
      };
    }); // setup proxy handling

    if (_this.options.proxy && typeof _this.options.proxy === 'string') {
      _this.setupProxy(_this.options.proxy);
    }

    return _this;
  }

  _createClass(Mail, [{
    key: "use",
    value: function use(step, plugin) {
      step = (step || '').toString();

      if (!this._userPlugins.hasOwnProperty(step)) {
        this._userPlugins[step] = [plugin];
      } else {
        this._userPlugins[step].push(plugin);
      }

      return this;
    }
    /**
     * Sends an email using the preselected transport object
     *
     * @param {Object} data E-data description
     * @param {Function?} callback Callback to run once the sending succeeded or failed
     */

  }, {
    key: "sendMail",
    value: function sendMail(data, callback) {
      var _this4 = this;

      var promise;

      if (!callback) {
        promise = new Promise(function (resolve, reject) {
          callback = shared.callbackPromise(resolve, reject);
        });
      }

      if (typeof this.getSocket === 'function') {
        this.transporter.getSocket = this.getSocket;
        this.getSocket = false;
      }

      var mail = new MailMessage(this, data);
      this.logger.debug({
        tnx: 'transport',
        name: this.transporter.name,
        version: this.transporter.version,
        action: 'send'
      }, 'Sending mail using %s/%s', this.transporter.name, this.transporter.version);

      this._processPlugins('compile', mail, function (err) {
        if (err) {
          _this4.logger.error({
            err: err,
            tnx: 'plugin',
            action: 'compile'
          }, 'PluginCompile Error: %s', err.message);

          return callback(err);
        }

        mail.message = new MailComposer(mail.data).compile();
        mail.setMailerHeader();
        mail.setPriorityHeaders();
        mail.setListHeaders();

        _this4._processPlugins('stream', mail, function (err) {
          if (err) {
            _this4.logger.error({
              err: err,
              tnx: 'plugin',
              action: 'stream'
            }, 'PluginStream Error: %s', err.message);

            return callback(err);
          }

          if (mail.data.dkim || _this4.dkim) {
            mail.message.processFunc(function (input) {
              var dkim = mail.data.dkim ? new DKIM(mail.data.dkim) : _this4.dkim;

              _this4.logger.debug({
                tnx: 'DKIM',
                messageId: mail.message.messageId(),
                dkimDomains: dkim.keys.map(function (key) {
                  return key.keySelector + '.' + key.domainName;
                }).join(', ')
              }, 'Signing outgoing message with %s keys', dkim.keys.length);

              return dkim.sign(input, mail.data._dkim);
            });
          }

          _this4.transporter.send(mail, function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            if (args[0]) {
              _this4.logger.error({
                err: args[0],
                tnx: 'transport',
                action: 'send'
              }, 'Send Error: %s', args[0].message);
            }

            callback.apply(void 0, args);
          });
        });
      });

      return promise;
    }
  }, {
    key: "getVersionString",
    value: function getVersionString() {
      return util.format('%s (%s; +%s; %s/%s)', packageData.name, packageData.version, packageData.homepage, this.transporter.name, this.transporter.version);
    }
  }, {
    key: "_processPlugins",
    value: function _processPlugins(step, mail, callback) {
      step = (step || '').toString();

      if (!this._userPlugins.hasOwnProperty(step)) {
        return callback();
      }

      var userPlugins = this._userPlugins[step] || [];
      var defaultPlugins = this._defaultPlugins[step] || [];

      if (userPlugins.length) {
        this.logger.debug({
          tnx: 'transaction',
          pluginCount: userPlugins.length,
          step: step
        }, 'Using %s plugins for %s', userPlugins.length, step);
      }

      if (userPlugins.length + defaultPlugins.length === 0) {
        return callback();
      }

      var pos = 0;
      var block = 'default';

      var processPlugins = function processPlugins() {
        var curplugins = block === 'default' ? defaultPlugins : userPlugins;

        if (pos >= curplugins.length) {
          if (block === 'default' && userPlugins.length) {
            block = 'user';
            pos = 0;
            curplugins = userPlugins;
          } else {
            return callback();
          }
        }

        var plugin = curplugins[pos++];
        plugin(mail, function (err) {
          if (err) {
            return callback(err);
          }

          processPlugins();
        });
      };

      processPlugins();
    }
    /**
     * Sets up proxy handler for a Nodemailer object
     *
     * @param {String} proxyUrl Proxy configuration url
     */

  }, {
    key: "setupProxy",
    value: function setupProxy(proxyUrl) {
      var _this5 = this;

      var proxy = urllib.parse(proxyUrl); // setup socket handler for the mailer object

      this.getSocket = function (options, callback) {
        var protocol = proxy.protocol.replace(/:$/, '').toLowerCase();

        if (_this5.meta.has('proxy_handler_' + protocol)) {
          return _this5.meta.get('proxy_handler_' + protocol)(proxy, options, callback);
        }

        switch (protocol) {
          // Connect using a HTTP CONNECT method
          case 'http':
          case 'https':
            httpProxyClient(proxy.href, options.port, options.host, function (err, socket) {
              if (err) {
                return callback(err);
              }

              return callback(null, {
                connection: socket
              });
            });
            return;

          case 'socks':
          case 'socks5':
          case 'socks4':
          case 'socks4a':
            {
              if (!_this5.meta.has('proxy_socks_module')) {
                return callback(new Error('Socks module not loaded'));
              }

              var connect = function connect(ipaddress) {
                var _connectionOpts;

                var proxyV2 = !!_this5.meta.get('proxy_socks_module').SocksClient;
                var socksClient = proxyV2 ? _this5.meta.get('proxy_socks_module').SocksClient : _this5.meta.get('proxy_socks_module');
                var proxyType = Number(proxy.protocol.replace(/\D/g, '')) || 5;
                var connectionOpts = (_connectionOpts = {
                  proxy: {
                    ipaddress: ipaddress,
                    port: Number(proxy.port),
                    type: proxyType
                  }
                }, _defineProperty(_connectionOpts, proxyV2 ? 'destination' : 'target', {
                  host: options.host,
                  port: options.port
                }), _defineProperty(_connectionOpts, "command", 'connect'), _connectionOpts);

                if (proxy.auth) {
                  var username = decodeURIComponent(proxy.auth.split(':').shift());
                  var password = decodeURIComponent(proxy.auth.split(':').pop());

                  if (proxyV2) {
                    connectionOpts.proxy.userId = username;
                    connectionOpts.proxy.password = password;
                  } else if (proxyType === 4) {
                    connectionOpts.userid = username;
                  } else {
                    connectionOpts.authentication = {
                      username: username,
                      password: password
                    };
                  }
                }

                socksClient.createConnection(connectionOpts, function (err, info) {
                  if (err) {
                    return callback(err);
                  }

                  return callback(null, {
                    connection: info.socket || info
                  });
                });
              };

              if (net.isIP(proxy.hostname)) {
                return connect(proxy.hostname);
              }

              return dns.resolve(proxy.hostname, function (err, address) {
                if (err) {
                  return callback(err);
                }

                connect(Array.isArray(address) ? address[0] : address);
              });
            }
        }

        callback(new Error('Unknown proxy configuration'));
      };
    }
  }, {
    key: "_convertDataImages",
    value: function _convertDataImages(mail, callback) {
      if (!this.options.attachDataUrls && !mail.data.attachDataUrls || !mail.data.html) {
        return callback();
      }

      mail.resolveContent(mail.data, 'html', function (err, html) {
        if (err) {
          return callback(err);
        }

        var cidCounter = 0;
        html = (html || '').toString().replace(/(<img\b[^>]* src\s*=[\s"']*)(data:([^;]+);[^"'>\s]+)/gi, function (match, prefix, dataUri, mimeType) {
          var cid = crypto.randomBytes(10).toString('hex') + '@localhost';

          if (!mail.data.attachments) {
            mail.data.attachments = [];
          }

          if (!Array.isArray(mail.data.attachments)) {
            mail.data.attachments = [].concat(mail.data.attachments || []);
          }

          mail.data.attachments.push({
            path: dataUri,
            cid: cid,
            filename: 'image-' + ++cidCounter + '.' + mimeTypes.detectExtension(mimeType)
          });
          return prefix + 'cid:' + cid;
        });
        mail.data.html = html;
        callback();
      });
    }
  }, {
    key: "set",
    value: function set(key, value) {
      return this.meta.set(key, value);
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.meta.get(key);
    }
  }]);

  return Mail;
}(EventEmitter);

module.exports = Mail;