"use strict"; // Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flattenObject = exports.getDiffs = exports.sortKeys = exports.shouldUpdate = exports.downloadDiscoveryDocs = exports.gfs = exports.DISCOVERY_URL = void 0;

var minimist = require("yargs-parser");

var path = require("path");

var fs = require("fs");

var p_queue_1 = require("p-queue");

var gaxios_1 = require("gaxios");

var mkdirp = require("mkdirp");

exports.DISCOVERY_URL = 'https://www.googleapis.com/discovery/v1/apis/'; // exported for mocking purposes

exports.gfs = {
  mkdir: function mkdir(dir) {
    return regeneratorRuntime.async(function mkdir$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", mkdirp(dir));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    });
  },
  writeFile: function writeFile(path, obj) {
    fs.writeFileSync(path, JSON.stringify(obj, null, 2));
  },
  readFile: function readFile(path) {
    return fs.readFileSync(path, 'utf8');
  }
};
/**
 * Download all discovery documents into the /discovery directory.
 * @param options
 */

function downloadDiscoveryDocs(options) {
  var headers, res, apis, indexPath, queue, changes;
  return regeneratorRuntime.async(function downloadDiscoveryDocs$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap(exports.gfs.mkdir(options.downloadPath));

        case 2:
          headers = options.includePrivate ? {} : {
            'X-User-Ip': '0.0.0.0'
          };
          console.log("sending request to ".concat(options.discoveryUrl));
          _context3.next = 6;
          return regeneratorRuntime.awrap(gaxios_1.request({
            url: options.discoveryUrl,
            headers: headers
          }));

        case 6:
          res = _context3.sent;
          apis = res.data.items;
          indexPath = path.join(options.downloadPath, 'index.json');
          exports.gfs.writeFile(indexPath, res.data);
          queue = new p_queue_1["default"]({
            concurrency: 25
          });
          console.log("Downloading ".concat(apis.length, " APIs..."));
          _context3.next = 14;
          return regeneratorRuntime.awrap(queue.addAll(apis.map(function (api) {
            return function _callee() {
              var apiPath, url, changeSet, _res, newDoc, updateFile, oldDoc;

              return regeneratorRuntime.async(function _callee$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      console.log("Downloading ".concat(api.id, "..."));
                      apiPath = path.join(options.downloadPath, api.id.replace(':', '-') + '.json');
                      url = api.discoveryRestUrl;
                      changeSet = {
                        api: api,
                        changes: []
                      };
                      _context2.prev = 4;
                      _context2.next = 7;
                      return regeneratorRuntime.awrap(gaxios_1.request({
                        url: url
                      }));

                    case 7:
                      _res = _context2.sent;
                      // The keys in the downloaded JSON come back in an arbitrary order from
                      // request to request. Sort them before storing.
                      newDoc = sortKeys(_res.data);
                      updateFile = true;
                      _context2.prev = 10;
                      _context2.t0 = JSON;
                      _context2.next = 14;
                      return regeneratorRuntime.awrap(exports.gfs.readFile(apiPath));

                    case 14:
                      _context2.t1 = _context2.sent;
                      oldDoc = _context2.t0.parse.call(_context2.t0, _context2.t1);
                      updateFile = shouldUpdate(newDoc, oldDoc);
                      changeSet.changes = getDiffs(oldDoc, newDoc);
                      _context2.next = 22;
                      break;

                    case 20:
                      _context2.prev = 20;
                      _context2.t2 = _context2["catch"](10);

                    case 22:
                      if (updateFile) {
                        exports.gfs.writeFile(apiPath, newDoc);
                      }

                      _context2.next = 28;
                      break;

                    case 25:
                      _context2.prev = 25;
                      _context2.t3 = _context2["catch"](4);
                      console.error("Error downloading: ".concat(url));

                    case 28:
                      return _context2.abrupt("return", changeSet);

                    case 29:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, null, null, [[4, 25], [10, 20]]);
            };
          })));

        case 14:
          changes = _context3.sent;
          return _context3.abrupt("return", changes);

        case 16:
        case "end":
          return _context3.stop();
      }
    }
  });
}

exports.downloadDiscoveryDocs = downloadDiscoveryDocs;
var ignoreLines = /^\s+"(?:etag|revision)": ".+"/;
/**
 * Determine if any of the changes in the discovery docs were interesting
 * @param newDoc New downloaded schema
 * @param oldDoc The existing schema from disk
 */

function shouldUpdate(newDoc, oldDoc) {
  var _map = [newDoc, oldDoc].map(function (doc) {
    return JSON.stringify(doc, null, 2).split('\n').filter(function (l) {
      return !ignoreLines.test(l);
    }).join('\n');
  }),
      _map2 = _slicedToArray(_map, 2),
      newLines = _map2[0],
      oldLines = _map2[1];

  return newLines !== oldLines;
}

exports.shouldUpdate = shouldUpdate;
/**
 * Given an arbitrary object, recursively sort the properties on the object
 * by the name of the key.  For example:
 * {
 *   b: 1,
 *   a: 2
 * }
 * becomes....
 * {
 *   a: 2,
 *   b: 1
 * }
 * @param obj Object to be sorted
 * @returns object with sorted keys
 */

function sortKeys(obj) {
  var sorted = {};
  var keys = Object.keys(obj);
  keys = keys.sort();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      // typeof [] === 'object', which is maddening
      if (!Array.isArray(obj[key]) && _typeof(obj[key]) === 'object') {
        sorted[key] = sortKeys(obj[key]);
      } else {
        sorted[key] = obj[key];
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return sorted;
}

exports.sortKeys = sortKeys;
/**
 * Get a diff between the two
 */

function getDiffs(oldDoc, newDoc) {
  var changes = new Array();
  var flatOld = flattenObject(oldDoc);
  var flatNew = flattenObject(newDoc); // find deleted nodes

  Object.keys(flatOld).forEach(function (key) {
    if (!Object.prototype.hasOwnProperty.call(flatNew, key)) {
      changes.push({
        action: 'DELETED',
        keyName: key
      });
    }
  }); // find added nodes

  Object.keys(flatNew).forEach(function (key) {
    if (!Object.prototype.hasOwnProperty.call(flatOld, key)) {
      changes.push({
        action: 'ADDED',
        keyName: key
      });
    }
  }); // find updated nodes

  Object.keys(flatOld).forEach(function (key) {
    var oldValue = flatOld[key];

    if (Array.isArray(oldValue)) {
      oldValue = oldValue.join(', ');
    }

    var newValue = flatNew[key];

    if (newValue) {
      if (Array.isArray(newValue)) {
        newValue = newValue.join(', ');
      }

      if (newValue !== oldValue && key !== 'revision' && key !== 'etag') {
        changes.push({
          action: 'CHANGED',
          keyName: key
        });
      }
    }
  });
  return changes;
}

exports.getDiffs = getDiffs;
/**
 * Given a complex nested object, flatten the key paths so this:
 * {
 *   a: {
 *     b: 2
 *   },
 *   c: 3
 * }
 * becomes ...
 * {
 *   'a.b': 2
 *   c: 3
 * }
 */

function flattenObject(doc) {
  var flat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var keys = Object.keys(doc);
  var newPrefix = prefix ? "".concat(prefix, ".") : '';

  for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {
    var key = _keys[_i2];
    var fullKey = newPrefix + key;
    var value = doc[key];

    if (!Array.isArray(value) && _typeof(value) === 'object') {
      flattenObject(value, flat, fullKey);
    } else {
      flat[fullKey] = value;
    }
  }

  return flat;
}

exports.flattenObject = flattenObject;
/**
 * Allow this file to be directly run via `npm run download`, or imported
 * and used by `generator.ts`
 */

if (require.main === module) {
  var argv = minimist(process.argv.slice(2));
  var discoveryUrl = argv['discovery-url'] || exports.DISCOVERY_URL;
  var downloadPath = argv['download-path'] || path.join(__dirname, '../../../discovery');
  downloadDiscoveryDocs({
    discoveryUrl: discoveryUrl,
    downloadPath: downloadPath
  });
}