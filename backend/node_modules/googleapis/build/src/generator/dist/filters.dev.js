"use strict"; // Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unRegex = exports.buildurl = exports.hasResourceParam = exports.getSafeParamName = exports.getPathParams = exports.cleanComments = exports.getType = exports.camelify = exports.cleanPropertyName = exports.isSimpleType = exports.getObjectType = void 0;

function getObjectType(item) {
  if (item.additionalProperties) {
    var valueType = getType(item.additionalProperties);
    return "{ [key: string]: ".concat(valueType, "; }");
  } else if (item.properties) {
    var fields = item.properties;
    var objectType = Object.keys(fields).map(function (field) {
      return "".concat(cleanPropertyName(field), "?: ").concat(getType(fields[field]), ";");
    }).join(' ');
    return "{ ".concat(objectType, " }");
  } else {
    return 'any';
  }
}

exports.getObjectType = getObjectType;

function isSimpleType(type) {
  if (type.indexOf('{') > -1) {
    return false;
  }

  return true;
}

exports.isSimpleType = isSimpleType;

function cleanPropertyName(prop) {
  var match = prop.match(/[-@.]/);
  return match ? "'".concat(prop, "'") : prop;
}

exports.cleanPropertyName = cleanPropertyName;

function camelify(name) {
  // If the name has a `-`, remove it and camelize.
  // Ex: `well-known` => `wellKnown`
  if (name.includes('-')) {
    var parts = name.split('-').filter(function (x) {
      return !!x;
    });
    name = parts.map(function (part, i) {
      if (i === 0) {
        return part;
      }

      return part.charAt(0).toUpperCase() + part.slice(1);
    }).join('');
  }

  return name;
}

exports.camelify = camelify;

function getType(item) {
  if (item.$ref) {
    return "Schema$".concat(item.$ref);
  }

  switch (item.type) {
    case 'integer':
      return 'number';

    case 'object':
      return getObjectType(item);

    case 'array':
      {
        var innerType = getType(item.items);

        if (isSimpleType(innerType)) {
          return "".concat(innerType, "[]");
        } else {
          return "Array<".concat(innerType, ">");
        }
      }

    default:
      return item.type;
  }
}

exports.getType = getType;
/**
 * Clean a string of comment tags.
 * @param str - String to process
 * @return Single line string processed
 */

function cleanComments(str) {
  if (!str) {
    return '';
  } // Convert /* into /x and */ into x/


  return str.replace(/\*\//g, 'x/').replace(/\/\*/g, '/x').replace(/}/g, '\\}').replace(/>/g, '\\>');
}

exports.cleanComments = cleanComments;

function getPathParams(params) {
  var pathParams = new Array();

  if (_typeof(params) !== 'object') {
    params = {};
  }

  Object.keys(params).forEach(function (key) {
    if (params[key].location === 'path') {
      pathParams.push(key);
    }
  });
  return pathParams;
}

exports.getPathParams = getPathParams;

function getSafeParamName(param) {
  if (RESERVED_PARAMS.indexOf(param) !== -1) {
    return param + '_';
  }

  return param;
}

exports.getSafeParamName = getSafeParamName;

function hasResourceParam(method) {
  return !!method.parameters && !!method.parameters['resource'];
}

exports.hasResourceParam = hasResourceParam;
var RESERVED_PARAMS = ['resource', 'media', 'auth'];
/**
 * Build a string used to create a URL from the discovery doc provided URL.
 * replace double slashes with single slash (except in https://)
 * @private
 * @param  input URL to build from
 * @return Resulting built URL
 */

function buildurl(input) {
  return input ? "'".concat(input, "'").replace(/([^:]\/)\/+/g, '$1') : '';
}

exports.buildurl = buildurl;
/**
 * Attempt to turn a regex into a more human readable form.
 * @param regex pattern for the given parameter
 */

function unRegex(regex) {
  // example: ^projects/[^/]+$' ==> projects/my-project
  var pattern = regex;

  if (typeof regex !== 'string') {
    return '';
  } // remove leading ^


  if (pattern.startsWith('^')) {
    pattern = pattern.slice(1);
  } // remove trailing $


  if (pattern.endsWith('$')) {
    pattern = pattern.slice(0, pattern.length - 1);
  } // replace projects placeholders


  pattern = pattern.replace(/\^?(\w+)s\/\[\^\/\]\+\$?/g, '$1s/my-$1');
  return pattern;
}

exports.unRegex = unRegex;