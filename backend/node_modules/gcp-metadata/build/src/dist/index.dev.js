"use strict";
/**
 * Copyright 2018 Google LLC
 *
 * Distributed under MIT license.
 * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
 */

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.requestTimeout = exports.resetIsAvailableCache = exports.isAvailable = exports.project = exports.instance = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;

var gaxios_1 = require("gaxios");

var jsonBigint = require('json-bigint'); // eslint-disable-line


exports.BASE_PATH = '/computeMetadata/v1';
exports.HOST_ADDRESS = 'http://169.254.169.254';
exports.SECONDARY_HOST_ADDRESS = 'http://metadata.google.internal.';
exports.HEADER_NAME = 'Metadata-Flavor';
exports.HEADER_VALUE = 'Google';
exports.HEADERS = Object.freeze(_defineProperty({}, exports.HEADER_NAME, exports.HEADER_VALUE));
/**
 * Returns the base URL while taking into account the GCE_METADATA_HOST
 * environment variable if it exists.
 *
 * @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.
 */

function getBaseUrl(baseUrl) {
  if (!baseUrl) {
    baseUrl = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports.HOST_ADDRESS;
  } // If no scheme is provided default to HTTP:


  if (!/^https?:\/\//.test(baseUrl)) {
    baseUrl = "http://".concat(baseUrl);
  }

  return new URL(exports.BASE_PATH, baseUrl).href;
} // Accepts an options object passed from the user to the API. In previous
// versions of the API, it referred to a `Request` or an `Axios` request
// options object.  Now it refers to an object with very limited property
// names. This is here to help ensure users don't pass invalid options when
// they  upgrade from 0.4 to 0.5 to 0.8.


function validate(options) {
  Object.keys(options).forEach(function (key) {
    switch (key) {
      case 'params':
      case 'property':
      case 'headers':
        break;

      case 'qs':
        throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");

      default:
        throw new Error("'".concat(key, "' is not a valid configuration option."));
    }
  });
}

function metadataAccessor(type, options) {
  var noResponseRetries,
      fastFail,
      property,
      requestMethod,
      res,
      _args = arguments;
  return regeneratorRuntime.async(function metadataAccessor$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          noResponseRetries = _args.length > 2 && _args[2] !== undefined ? _args[2] : 3;
          fastFail = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;
          options = options || {};

          if (typeof options === 'string') {
            options = {
              property: options
            };
          }

          property = '';

          if (_typeof(options) === 'object' && options.property) {
            property = '/' + options.property;
          }

          validate(options);
          _context.prev = 7;
          requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;
          _context.next = 11;
          return regeneratorRuntime.awrap(requestMethod({
            url: "".concat(getBaseUrl(), "/").concat(type).concat(property),
            headers: Object.assign({}, exports.HEADERS, options.headers),
            retryConfig: {
              noResponseRetries: noResponseRetries
            },
            params: options.params,
            responseType: 'text',
            timeout: requestTimeout()
          }));

        case 11:
          res = _context.sent;

          if (!(res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE)) {
            _context.next = 16;
            break;
          }

          throw new Error("Invalid response from metadata service: incorrect ".concat(exports.HEADER_NAME, " header."));

        case 16:
          if (res.data) {
            _context.next = 18;
            break;
          }

          throw new Error('Invalid response from the metadata service');

        case 18:
          if (!(typeof res.data === 'string')) {
            _context.next = 25;
            break;
          }

          _context.prev = 19;
          return _context.abrupt("return", jsonBigint.parse(res.data));

        case 23:
          _context.prev = 23;
          _context.t0 = _context["catch"](19);

        case 25:
          return _context.abrupt("return", res.data);

        case 28:
          _context.prev = 28;
          _context.t1 = _context["catch"](7);

          if (_context.t1.response && _context.t1.response.status !== 200) {
            _context.t1.message = "Unsuccessful response status code. ".concat(_context.t1.message);
          }

          throw _context.t1;

        case 32:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[7, 28], [19, 23]]);
}

function fastFailMetadataRequest(options) {
  var secondaryOptions, responded, r1, r2;
  return regeneratorRuntime.async(function fastFailMetadataRequest$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          secondaryOptions = _objectSpread({}, options, {
            url: options.url.replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS))
          }); // We race a connection between DNS/IP to metadata server. There are a couple
          // reasons for this:
          //
          // 1. the DNS is slow in some GCP environments; by checking both, we might
          //    detect the runtime environment signficantly faster.
          // 2. we can't just check the IP, which is tarpitted and slow to respond
          //    on a user's local machine.
          //
          // Additional logic has been added to make sure that we don't create an
          // unhandled rejection in scenarios where a failure happens sometime
          // after a success.
          //
          // Note, however, if a failure happens prior to a success, a rejection should
          // occur, this is for folks running locally.
          //

          responded = false;
          r1 = gaxios_1.request(options).then(function (res) {
            responded = true;
            return res;
          })["catch"](function (err) {
            if (responded) {
              return r2;
            } else {
              responded = true;
              throw err;
            }
          });
          r2 = gaxios_1.request(secondaryOptions).then(function (res) {
            responded = true;
            return res;
          })["catch"](function (err) {
            if (responded) {
              return r1;
            } else {
              responded = true;
              throw err;
            }
          });
          return _context2.abrupt("return", Promise.race([r1, r2]));

        case 5:
        case "end":
          return _context2.stop();
      }
    }
  });
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function instance(options) {
  return metadataAccessor('instance', options);
}

exports.instance = instance; // eslint-disable-next-line @typescript-eslint/no-explicit-any

function project(options) {
  return metadataAccessor('project', options);
}

exports.project = project;
/*
 * How many times should we retry detecting GCP environment.
 */

function detectGCPAvailableRetries() {
  return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;
}
/**
 * Determine if the metadata server is currently available.
 */


var cachedIsAvailableResponse;

function isAvailable() {
  var code;
  return regeneratorRuntime.async(function isAvailable$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.prev = 0;

          // If a user is instantiating several GCP libraries at the same time,
          // this may result in multiple calls to isAvailable(), to detect the
          // runtime environment. We use the same promise for each of these calls
          // to reduce the network load.
          if (cachedIsAvailableResponse === undefined) {
            cachedIsAvailableResponse = metadataAccessor('instance', undefined, detectGCPAvailableRetries(), // If the default HOST_ADDRESS has been overridden, we should not
            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in
            // a non-GCP environment):
            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));
          }

          _context3.next = 4;
          return regeneratorRuntime.awrap(cachedIsAvailableResponse);

        case 4:
          return _context3.abrupt("return", true);

        case 7:
          _context3.prev = 7;
          _context3.t0 = _context3["catch"](0);

          if (process.env.DEBUG_AUTH) {
            console.info(_context3.t0);
          }

          if (!(_context3.t0.type === 'request-timeout')) {
            _context3.next = 12;
            break;
          }

          return _context3.abrupt("return", false);

        case 12:
          if (!(_context3.t0.response && _context3.t0.response.status === 404)) {
            _context3.next = 16;
            break;
          }

          return _context3.abrupt("return", false);

        case 16:
          if (!(_context3.t0.response && _context3.t0.response.status === 404) && ( // A warning is emitted if we see an unexpected err.code, or err.code
          // is not populated:
          !_context3.t0.code || !['EHOSTDOWN', 'EHOSTUNREACH', 'ENETUNREACH', 'ENOENT', 'ENOTFOUND', 'ECONNREFUSED'].includes(_context3.t0.code))) {
            code = 'UNKNOWN';
            if (_context3.t0.code) code = _context3.t0.code;
            process.emitWarning("received unexpected error = ".concat(_context3.t0.message, " code = ").concat(code), 'MetadataLookupWarning');
          } // Failure to resolve the metadata service means that it is not available.


          return _context3.abrupt("return", false);

        case 18:
        case "end":
          return _context3.stop();
      }
    }
  }, null, null, [[0, 7]]);
}

exports.isAvailable = isAvailable;
/**
 * reset the memoized isAvailable() lookup.
 */

function resetIsAvailableCache() {
  cachedIsAvailableResponse = undefined;
}

exports.resetIsAvailableCache = resetIsAvailableCache;

function requestTimeout() {
  // In testing, we were able to reproduce behavior similar to
  // https://github.com/googleapis/google-auth-library-nodejs/issues/798
  // by making many concurrent network requests. Requests do not actually fail,
  // rather they take significantly longer to complete (and we hit our
  // default 3000ms timeout).
  //
  // This logic detects a GCF environment, using the documented environment
  // variables K_SERVICE and FUNCTION_NAME:
  // https://cloud.google.com/functions/docs/env-var and, in a GCF environment
  // eliminates timeouts (by setting the value to 0 to disable).
  return process.env.K_SERVICE || process.env.FUNCTION_NAME ? 0 : 3000;
}

exports.requestTimeout = requestTimeout;