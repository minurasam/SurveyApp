'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Explain = require('../explain').Explain;

var MongoError = require('../core/error').MongoError;

var Aspect = {
  READ_OPERATION: Symbol('READ_OPERATION'),
  WRITE_OPERATION: Symbol('WRITE_OPERATION'),
  RETRYABLE: Symbol('RETRYABLE'),
  EXECUTE_WITH_SELECTION: Symbol('EXECUTE_WITH_SELECTION'),
  NO_INHERIT_OPTIONS: Symbol('NO_INHERIT_OPTIONS'),
  EXPLAINABLE: Symbol('EXPLAINABLE')
};
/**
 * This class acts as a parent class for any operation and is responsible for setting this.options,
 * as well as setting and getting a session.
 * Additionally, this class implements `hasAspect`, which determines whether an operation has
 * a specific aspect.
 */

var OperationBase =
/*#__PURE__*/
function () {
  function OperationBase(options) {
    _classCallCheck(this, OperationBase);

    this.options = Object.assign({}, options);

    if (this.hasAspect(Aspect.EXPLAINABLE)) {
      this.explain = Explain.fromOptions(options);
    } else if (this.options.explain !== undefined) {
      throw new MongoError("explain is not supported on this command");
    }
  }

  _createClass(OperationBase, [{
    key: "hasAspect",
    value: function hasAspect(aspect) {
      if (this.constructor.aspects == null) {
        return false;
      }

      return this.constructor.aspects.has(aspect);
    }
  }, {
    key: "clearSession",
    value: function clearSession() {
      delete this.options.session;
    }
  }, {
    key: "execute",
    value: function execute() {
      throw new TypeError('`execute` must be implemented for OperationBase subclasses');
    }
  }, {
    key: "session",
    set: function set(session) {
      Object.assign(this.options, {
        session: session
      });
    },
    get: function get() {
      return this.options.session;
    }
  }, {
    key: "canRetryRead",
    get: function get() {
      return true;
    }
  }]);

  return OperationBase;
}();

function defineAspects(operation, aspects) {
  if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
    aspects = [aspects];
  }

  aspects = new Set(aspects);
  Object.defineProperty(operation, 'aspects', {
    value: aspects,
    writable: false
  });
  return aspects;
}

module.exports = {
  Aspect: Aspect,
  defineAspects: defineAspects,
  OperationBase: OperationBase
};