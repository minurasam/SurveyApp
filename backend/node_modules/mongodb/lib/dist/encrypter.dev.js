'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var MongoClient = require('./mongo_client');

var BSON = require('./core/connection/utils').retrieveBSON();

var MongoError = require('./core/error').MongoError;

try {
  require.resolve('mongodb-client-encryption');
} catch (err) {
  throw new MongoError('Auto-encryption requested, but the module is not installed. ' + 'Please add `mongodb-client-encryption` as a dependency of your project');
}

var mongodbClientEncryption = require('mongodb-client-encryption');

if (typeof mongodbClientEncryption.extension !== 'function') {
  throw new MongoError('loaded version of `mongodb-client-encryption` does not have property `extension`. ' + 'Please make sure you are loading the correct version of `mongodb-client-encryption`');
}

var AutoEncrypter = mongodbClientEncryption.extension(require('../index')).AutoEncrypter;
var kInternalClient = Symbol('internalClient');

var Encrypter =
/*#__PURE__*/
function () {
  /**
   * @param {MongoClient} client
   * @param {{autoEncryption: import('./mongo_client').AutoEncryptionOptions, bson: object}} options
   */
  function Encrypter(client, options) {
    _classCallCheck(this, Encrypter);

    this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
    this.needsConnecting = false;

    if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
      options.autoEncryption.keyVaultClient = client;
    } else if (options.autoEncryption.keyVaultClient == null) {
      options.autoEncryption.keyVaultClient = this.getInternalClient(client);
    }

    if (this.bypassAutoEncryption) {
      options.autoEncryption.metadataClient = undefined;
    } else if (options.maxPoolSize === 0) {
      options.autoEncryption.metadataClient = client;
    } else {
      options.autoEncryption.metadataClient = this.getInternalClient(client);
    }

    options.autoEncryption.bson = Encrypter.makeBSON(options);
    this.autoEncrypter = new AutoEncrypter(client, options.autoEncryption);
  }

  _createClass(Encrypter, [{
    key: "getInternalClient",
    value: function getInternalClient(client) {
      var _this = this;

      if (!this[kInternalClient]) {
        var clonedOptions = {};

        for (var _i = 0, _Object$keys = Object.keys(client.s.options); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          if (['autoEncryption', 'minPoolSize', 'servers', 'caseTranslate', 'dbName'].indexOf(key) !== -1) continue;
          clonedOptions[key] = client.s.options[key];
        }

        clonedOptions.minPoolSize = 0;
        var allEvents = [// APM
        'commandStarted', 'commandSucceeded', 'commandFailed', // SDAM
        'serverOpening', 'serverClosed', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', // Legacy
        'joined', 'left', 'ping', 'ha', // CMAP
        'connectionPoolCreated', 'connectionPoolClosed', 'connectionCreated', 'connectionReady', 'connectionClosed', 'connectionCheckOutStarted', 'connectionCheckOutFailed', 'connectionCheckedOut', 'connectionCheckedIn', 'connectionPoolCleared'];
        this[kInternalClient] = new MongoClient(client.s.url, clonedOptions);

        for (var _i2 = 0, _allEvents = allEvents; _i2 < _allEvents.length; _i2++) {
          var eventName = _allEvents[_i2];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = client.listeners(eventName)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var listener = _step.value;
              this[kInternalClient].on(eventName, listener);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        client.on('newListener', function (eventName, listener) {
          _this[kInternalClient].on(eventName, listener);
        });
        this.needsConnecting = true;
      }

      return this[kInternalClient];
    }
  }, {
    key: "connectInternalClient",
    value: function connectInternalClient(callback) {
      if (this.needsConnecting) {
        this.needsConnecting = false;
        return this[kInternalClient].connect(callback);
      }

      return callback();
    }
  }, {
    key: "close",
    value: function close(client, force, callback) {
      var _this2 = this;

      this.autoEncrypter.teardown(function (e) {
        if (_this2[kInternalClient] && client !== _this2[kInternalClient]) {
          return _this2[kInternalClient].close(force, callback);
        }

        callback(e);
      });
    }
  }], [{
    key: "makeBSON",
    value: function makeBSON(options) {
      return (options || {}).bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]);
    }
  }]);

  return Encrypter;
}();

module.exports = {
  Encrypter: Encrypter
};