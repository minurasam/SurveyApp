'use strict';

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Denque = require('denque');

var EventEmitter = require('events');

var isResumableError = require('./error').isResumableError;

var MongoError = require('./core').MongoError;

var Cursor = require('./cursor');

var relayEvents = require('./core/utils').relayEvents;

var maxWireVersion = require('./core/utils').maxWireVersion;

var maybePromise = require('./utils').maybePromise;

var now = require('./utils').now;

var calculateDurationInMs = require('./utils').calculateDurationInMs;

var AggregateOperation = require('./operations/aggregate');

var kResumeQueue = Symbol('resumeQueue');
var CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];
var CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(CHANGE_STREAM_OPTIONS);
var CHANGE_DOMAIN_TYPES = {
  COLLECTION: Symbol('Collection'),
  DATABASE: Symbol('Database'),
  CLUSTER: Symbol('Cluster')
};
/**
 * @typedef ResumeToken
 * @description Represents the logical starting point for a new or resuming {@link ChangeStream} on the server.
 * @see https://docs.mongodb.com/master/changeStreams/#change-stream-resume-token
 */

/**
 * @typedef OperationTime
 * @description Represents a specific point in time on a server. Can be retrieved by using {@link Db#command}
 * @see https://docs.mongodb.com/manual/reference/method/db.runCommand/#response
 */

/**
 * @typedef ChangeStreamOptions
 * @description Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.
 * @property {string} [fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.
 * @property {number} [maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query.
 * @property {ResumeToken} [resumeAfter] Allows you to start a changeStream after a specified event. See {@link https://docs.mongodb.com/master/changeStreams/#resumeafter-for-change-streams|ChangeStream documentation}.
 * @property {ResumeToken} [startAfter] Similar to resumeAfter, but will allow you to start after an invalidated event. See {@link https://docs.mongodb.com/master/changeStreams/#startafter-for-change-streams|ChangeStream documentation}.
 * @property {OperationTime} [startAtOperationTime] Will start the changeStream after the specified operationTime.
 * @property {number} [batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.
 * @property {object} [collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.
 * @property {ReadPreference} [readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.
 */

/**
 * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.
 * @class ChangeStream
 * @since 3.0.0
 * @param {(MongoClient|Db|Collection)} parent The parent object that created this change stream
 * @param {Array} pipeline An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents
 * @param {ChangeStreamOptions} [options] Optional settings
 * @fires ChangeStream#close
 * @fires ChangeStream#change
 * @fires ChangeStream#end
 * @fires ChangeStream#error
 * @fires ChangeStream#resumeTokenChanged
 * @return {ChangeStream} a ChangeStream instance.
 */

var ChangeStream =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(ChangeStream, _EventEmitter);

  function ChangeStream(parent, pipeline, options) {
    var _this;

    _classCallCheck(this, ChangeStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ChangeStream).call(this));

    var Collection = require('./collection');

    var Db = require('./db');

    var MongoClient = require('./mongo_client');

    _this.pipeline = pipeline || [];
    _this.options = options || {};
    _this.parent = parent;
    _this.namespace = parent.s.namespace;

    if (parent instanceof Collection) {
      _this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
      _this.topology = parent.s.db.serverConfig;
    } else if (parent instanceof Db) {
      _this.type = CHANGE_DOMAIN_TYPES.DATABASE;
      _this.topology = parent.serverConfig;
    } else if (parent instanceof MongoClient) {
      _this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
      _this.topology = parent.topology;
    } else {
      throw new TypeError('parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient');
    }

    _this.promiseLibrary = parent.s.promiseLibrary;

    if (!_this.options.readPreference && parent.s.readPreference) {
      _this.options.readPreference = parent.s.readPreference;
    }

    _this[kResumeQueue] = new Denque(); // Create contained Change Stream cursor

    _this.cursor = createChangeStreamCursor(_assertThisInitialized(_this), options);
    _this.closed = false; // Listen for any `change` listeners being added to ChangeStream

    _this.on('newListener', function (eventName) {
      if (eventName === 'change' && _this.cursor && _this.listenerCount('change') === 0) {
        _this.cursor.on('data', function (change) {
          return processNewChange(_assertThisInitialized(_this), change);
        });
      }
    }); // Listen for all `change` listeners being removed from ChangeStream


    _this.on('removeListener', function (eventName) {
      if (eventName === 'change' && _this.listenerCount('change') === 0 && _this.cursor) {
        _this.cursor.removeAllListeners('data');
      }
    });

    return _this;
  }
  /**
   * @property {ResumeToken} resumeToken
   * The cached resume token that will be used to resume
   * after the most recently returned change.
   */


  _createClass(ChangeStream, [{
    key: "hasNext",

    /**
     * Check if there is any document still available in the Change Stream
     * @function ChangeStream.prototype.hasNext
     * @param {ChangeStream~resultCallback} [callback] The result callback.
     * @throws {MongoError}
     * @returns {Promise|void} returns Promise if no callback passed
     */
    value: function hasNext(callback) {
      var _this2 = this;

      return maybePromise(this.parent, callback, function (cb) {
        getCursor(_this2, function (err, cursor) {
          if (err) return cb(err); // failed to resume, raise an error

          cursor.hasNext(cb);
        });
      });
    }
    /**
     * Get the next available document from the Change Stream, returns null if no more documents are available.
     * @function ChangeStream.prototype.next
     * @param {ChangeStream~resultCallback} [callback] The result callback.
     * @throws {MongoError}
     * @returns {Promise|void} returns Promise if no callback passed
     */

  }, {
    key: "next",
    value: function next(callback) {
      var _this3 = this;

      return maybePromise(this.parent, callback, function (cb) {
        getCursor(_this3, function (err, cursor) {
          if (err) return cb(err); // failed to resume, raise an error

          cursor.next(function (error, change) {
            if (error) {
              _this3[kResumeQueue].push(function () {
                return _this3.next(cb);
              });

              processError(_this3, error, cb);
              return;
            }

            processNewChange(_this3, change, cb);
          });
        });
      });
    }
    /**
     * Is the change stream closed
     * @method ChangeStream.prototype.isClosed
     * @return {boolean}
     */

  }, {
    key: "isClosed",
    value: function isClosed() {
      return this.closed || this.cursor && this.cursor.isClosed();
    }
    /**
     * Close the Change Stream
     * @method ChangeStream.prototype.close
     * @param {ChangeStream~resultCallback} [callback] The result callback.
     * @return {Promise} returns Promise if no callback passed
     */

  }, {
    key: "close",
    value: function close(callback) {
      var _this4 = this;

      return maybePromise(this.parent, callback, function (cb) {
        if (_this4.closed) return cb(); // flag the change stream as explicitly closed

        _this4.closed = true;
        if (!_this4.cursor) return cb(); // Tidy up the existing cursor

        var cursor = _this4.cursor;
        return cursor.close(function (err) {
          ['data', 'close', 'end', 'error'].forEach(function (event) {
            return cursor.removeAllListeners(event);
          });
          _this4.cursor = undefined;
          return cb(err);
        });
      });
    }
    /**
     * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.
     * @method
     * @param {Writable} destination The destination for writing data
     * @param {object} [options] {@link https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options|Pipe options}
     * @return {null}
     */

  }, {
    key: "pipe",
    value: function pipe(destination, options) {
      if (!this.pipeDestinations) {
        this.pipeDestinations = [];
      }

      this.pipeDestinations.push(destination);
      return this.cursor.pipe(destination, options);
    }
    /**
     * This method will remove the hooks set up for a previous pipe() call.
     * @param {Writable} [destination] The destination for writing data
     * @return {null}
     */

  }, {
    key: "unpipe",
    value: function unpipe(destination) {
      if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {
        this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);
      }

      return this.cursor.unpipe(destination);
    }
    /**
     * Return a modified Readable stream including a possible transform method.
     * @method
     * @param {object} [options] Optional settings.
     * @param {function} [options.transform] A transformation method applied to each document emitted by the stream.
     * @return {Cursor}
     */

  }, {
    key: "stream",
    value: function stream(options) {
      this.streamOptions = options;
      return this.cursor.stream(options);
    }
    /**
     * This method will cause a stream in flowing mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.
     * @return {null}
     */

  }, {
    key: "pause",
    value: function pause() {
      return this.cursor.pause();
    }
    /**
     * This method will cause the readable stream to resume emitting data events.
     * @return {null}
     */

  }, {
    key: "resume",
    value: function resume() {
      return this.cursor.resume();
    }
  }, {
    key: "resumeToken",
    get: function get() {
      return this.cursor.resumeToken;
    }
  }]);

  return ChangeStream;
}(EventEmitter);

var ChangeStreamCursor =
/*#__PURE__*/
function (_Cursor) {
  _inherits(ChangeStreamCursor, _Cursor);

  function ChangeStreamCursor(topology, operation, options) {
    var _this5;

    _classCallCheck(this, ChangeStreamCursor);

    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(ChangeStreamCursor).call(this, topology, operation, options));
    options = options || {};
    _this5._resumeToken = null;
    _this5.startAtOperationTime = options.startAtOperationTime;

    if (options.startAfter) {
      _this5.resumeToken = options.startAfter;
    } else if (options.resumeAfter) {
      _this5.resumeToken = options.resumeAfter;
    }

    return _this5;
  }

  _createClass(ChangeStreamCursor, [{
    key: "cacheResumeToken",
    value: function cacheResumeToken(resumeToken) {
      if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {
        this.resumeToken = this.cursorState.postBatchResumeToken;
      } else {
        this.resumeToken = resumeToken;
      }

      this.hasReceived = true;
    }
  }, {
    key: "_processBatch",
    value: function _processBatch(batchName, response) {
      var cursor = response.cursor;

      if (cursor.postBatchResumeToken) {
        this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;

        if (cursor[batchName].length === 0) {
          this.resumeToken = cursor.postBatchResumeToken;
        }
      }
    }
  }, {
    key: "_initializeCursor",
    value: function _initializeCursor(callback) {
      var _this6 = this;

      _get(_getPrototypeOf(ChangeStreamCursor.prototype), "_initializeCursor", this).call(this, function (err, result) {
        if (err || result == null) {
          callback(err, result);
          return;
        }

        var response = result.documents[0];

        if (_this6.startAtOperationTime == null && _this6.resumeAfter == null && _this6.startAfter == null && maxWireVersion(_this6.server) >= 7) {
          _this6.startAtOperationTime = response.operationTime;
        }

        _this6._processBatch('firstBatch', response);

        _this6.emit('init', result);

        _this6.emit('response');

        callback(err, result);
      });
    }
  }, {
    key: "_getMore",
    value: function _getMore(callback) {
      var _this7 = this;

      _get(_getPrototypeOf(ChangeStreamCursor.prototype), "_getMore", this).call(this, function (err, response) {
        if (err) {
          callback(err);
          return;
        }

        _this7._processBatch('nextBatch', response);

        _this7.emit('more', response);

        _this7.emit('response');

        callback(err, response);
      });
    }
  }, {
    key: "resumeToken",
    set: function set(token) {
      this._resumeToken = token;
      this.emit('resumeTokenChanged', token);
    },
    get: function get() {
      return this._resumeToken;
    }
  }, {
    key: "resumeOptions",
    get: function get() {
      var result = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = CURSOR_OPTIONS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var optionName = _step.value;
          if (this.options[optionName]) result[optionName] = this.options[optionName];
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (this.resumeToken || this.startAtOperationTime) {
        ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(function (key) {
          return delete result[key];
        });

        if (this.resumeToken) {
          var resumeKey = this.options.startAfter && !this.hasReceived ? 'startAfter' : 'resumeAfter';
          result[resumeKey] = this.resumeToken;
        } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {
          result.startAtOperationTime = this.startAtOperationTime;
        }
      }

      return result;
    }
  }]);

  return ChangeStreamCursor;
}(Cursor);
/**
 * @event ChangeStreamCursor#response
 * internal event DO NOT USE
 * @ignore
 */
// Create a new change stream cursor based on self's configuration


function createChangeStreamCursor(self, options) {
  var changeStreamStageOptions = {
    fullDocument: options.fullDocument || 'default'
  };
  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);

  if (self.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
    changeStreamStageOptions.allChangesForCluster = true;
  }

  var pipeline = [{
    $changeStream: changeStreamStageOptions
  }].concat(self.pipeline);
  var cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);
  var changeStreamCursor = new ChangeStreamCursor(self.topology, new AggregateOperation(self.parent, pipeline, options), cursorOptions);
  relayEvents(changeStreamCursor, self, ['resumeTokenChanged', 'end', 'close']);
  /**
   * Fired for each new matching change in the specified namespace. Attaching a `change`
   * event listener to a Change Stream will switch the stream into flowing mode. Data will
   * then be passed as soon as it is available.
   *
   * @event ChangeStream#change
   * @type {object}
   */

  if (self.listenerCount('change') > 0) {
    changeStreamCursor.on('data', function (change) {
      processNewChange(self, change);
    });
  }
  /**
   * Change stream close event
   *
   * @event ChangeStream#close
   * @type {null}
   */

  /**
   * Change stream end event
   *
   * @event ChangeStream#end
   * @type {null}
   */

  /**
   * Emitted each time the change stream stores a new resume token.
   *
   * @event ChangeStream#resumeTokenChanged
   * @type {ResumeToken}
   */

  /**
   * Fired when the stream encounters an error.
   *
   * @event ChangeStream#error
   * @type {Error}
   */


  changeStreamCursor.on('error', function (error) {
    processError(self, error);
  });

  if (self.pipeDestinations) {
    var cursorStream = changeStreamCursor.stream(self.streamOptions);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = self.pipeDestinations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var pipeDestination = _step2.value;
        cursorStream.pipe(pipeDestination);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  return changeStreamCursor;
}

function applyKnownOptions(target, source, optionNames) {
  optionNames.forEach(function (name) {
    if (source[name]) {
      target[name] = source[name];
    }
  });
  return target;
} // This method performs a basic server selection loop, satisfying the requirements of
// ChangeStream resumability until the new SDAM layer can be used.


var SELECTION_TIMEOUT = 30000;

function waitForTopologyConnected(topology, options, callback) {
  setTimeout(function () {
    if (options && options.start == null) {
      options.start = now();
    }

    var start = options.start || now();
    var timeout = options.timeout || SELECTION_TIMEOUT;
    var readPreference = options.readPreference;

    if (topology.isConnected({
      readPreference: readPreference
    })) {
      return callback();
    }

    if (calculateDurationInMs(start) > timeout) {
      return callback(new MongoError('Timed out waiting for connection'));
    }

    waitForTopologyConnected(topology, options, callback);
  }, 500); // this is an arbitrary wait time to allow SDAM to transition
}

function processNewChange(changeStream, change, callback) {
  var cursor = changeStream.cursor; // a null change means the cursor has been notified, implicitly closing the change stream

  if (change == null) {
    changeStream.closed = true;
  }

  if (changeStream.closed) {
    if (callback) callback(new MongoError('ChangeStream is closed'));
    return;
  }

  if (change && !change._id) {
    var noResumeTokenError = new Error('A change stream document has been received that lacks a resume token (_id).');
    if (!callback) return changeStream.emit('error', noResumeTokenError);
    return callback(noResumeTokenError);
  } // cache the resume token


  cursor.cacheResumeToken(change._id); // wipe the startAtOperationTime if there was one so that there won't be a conflict
  // between resumeToken and startAtOperationTime if we need to reconnect the cursor

  changeStream.options.startAtOperationTime = undefined; // Return the change

  if (!callback) return changeStream.emit('change', change);
  return callback(undefined, change);
}

function processError(changeStream, error, callback) {
  var topology = changeStream.topology;
  var cursor = changeStream.cursor; // If the change stream has been closed explictly, do not process error.

  if (changeStream.closed) {
    if (callback) callback(new MongoError('ChangeStream is closed'));
    return;
  } // if the resume succeeds, continue with the new cursor


  function resumeWithCursor(newCursor) {
    changeStream.cursor = newCursor;
    processResumeQueue(changeStream);
  } // otherwise, raise an error and close the change stream


  function unresumableError(err) {
    if (!callback) {
      changeStream.emit('error', err);
      changeStream.emit('close');
    }

    processResumeQueue(changeStream, err);
    changeStream.closed = true;
  }

  if (cursor && isResumableError(error, maxWireVersion(cursor.server))) {
    changeStream.cursor = undefined; // stop listening to all events from old cursor

    ['data', 'close', 'end', 'error'].forEach(function (event) {
      return cursor.removeAllListeners(event);
    }); // close internal cursor, ignore errors

    cursor.close();
    waitForTopologyConnected(topology, {
      readPreference: cursor.options.readPreference
    }, function (err) {
      // if the topology can't reconnect, close the stream
      if (err) return unresumableError(err); // create a new cursor, preserving the old cursor's options

      var newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions); // attempt to continue in emitter mode

      if (!callback) return resumeWithCursor(newCursor); // attempt to continue in iterator mode

      newCursor.hasNext(function (err) {
        // if there's an error immediately after resuming, close the stream
        if (err) return unresumableError(err);
        resumeWithCursor(newCursor);
      });
    });
    return;
  }

  if (!callback) return changeStream.emit('error', error);
  return callback(error);
}
/**
 * Safely provides a cursor across resume attempts
 *
 * @param {ChangeStream} changeStream the parent ChangeStream
 * @param {function} callback gets the cursor or error
 * @param {ChangeStreamCursor} [oldCursor] when resuming from an error, carry over options from previous cursor
 */


function getCursor(changeStream, callback) {
  if (changeStream.isClosed()) {
    callback(new MongoError('ChangeStream is closed.'));
    return;
  } // if a cursor exists and it is open, return it


  if (changeStream.cursor) {
    callback(undefined, changeStream.cursor);
    return;
  } // no cursor, queue callback until topology reconnects


  changeStream[kResumeQueue].push(callback);
}
/**
 * Drain the resume queue when a new has become available
 *
 * @param {ChangeStream} changeStream the parent ChangeStream
 * @param {ChangeStreamCursor?} changeStream.cursor the new cursor
 * @param {Error} [err] error getting a new cursor
 */


function processResumeQueue(changeStream, err) {
  while (changeStream[kResumeQueue].length) {
    var request = changeStream[kResumeQueue].pop();

    if (changeStream.isClosed() && !err) {
      request(new MongoError('Change Stream is not open.'));
      return;
    }

    request(err, changeStream.cursor);
  }
}
/**
 * The callback format for results
 * @callback ChangeStream~resultCallback
 * @param {MongoError} error An error instance representing the error during the execution.
 * @param {(object|null)} result The result object if the command was executed successfully.
 */


module.exports = ChangeStream;