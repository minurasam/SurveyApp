'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Denque = require('denque');

var EventEmitter = require('events').EventEmitter;

var Logger = require('../core/connection/logger');

var makeCounter = require('../utils').makeCounter;

var MongoError = require('../core/error').MongoError;

var Connection = require('./connection').Connection;

var eachAsync = require('../core/utils').eachAsync;

var connect = require('../core/connection/connect');

var relayEvents = require('../core/utils').relayEvents;

var errors = require('./errors');

var PoolClosedError = errors.PoolClosedError;
var WaitQueueTimeoutError = errors.WaitQueueTimeoutError;

var events = require('./events');

var ConnectionPoolCreatedEvent = events.ConnectionPoolCreatedEvent;
var ConnectionPoolClosedEvent = events.ConnectionPoolClosedEvent;
var ConnectionCreatedEvent = events.ConnectionCreatedEvent;
var ConnectionReadyEvent = events.ConnectionReadyEvent;
var ConnectionClosedEvent = events.ConnectionClosedEvent;
var ConnectionCheckOutStartedEvent = events.ConnectionCheckOutStartedEvent;
var ConnectionCheckOutFailedEvent = events.ConnectionCheckOutFailedEvent;
var ConnectionCheckedOutEvent = events.ConnectionCheckedOutEvent;
var ConnectionCheckedInEvent = events.ConnectionCheckedInEvent;
var ConnectionPoolClearedEvent = events.ConnectionPoolClearedEvent;
var kLogger = Symbol('logger');
var kConnections = Symbol('connections');
var kPermits = Symbol('permits');
var kMinPoolSizeTimer = Symbol('minPoolSizeTimer');
var kGeneration = Symbol('generation');
var kConnectionCounter = Symbol('connectionCounter');
var kCancellationToken = Symbol('cancellationToken');
var kWaitQueue = Symbol('waitQueue');
var kCancelled = Symbol('cancelled');
var VALID_POOL_OPTIONS = new Set([// `connect` options
'ssl', 'bson', 'connectionType', 'monitorCommands', 'socketTimeout', 'credentials', 'compression', // node Net options
'host', 'port', 'localAddress', 'localPort', 'family', 'hints', 'lookup', 'path', // node TLS options
'ca', 'cert', 'sigalgs', 'ciphers', 'clientCertEngine', 'crl', 'dhparam', 'ecdhCurve', 'honorCipherOrder', 'key', 'privateKeyEngine', 'privateKeyIdentifier', 'maxVersion', 'minVersion', 'passphrase', 'pfx', 'secureOptions', 'secureProtocol', 'sessionIdContext', 'allowHalfOpen', 'rejectUnauthorized', 'pskCallback', 'ALPNProtocols', 'servername', 'checkServerIdentity', 'session', 'minDHSize', 'secureContext', // spec options
'maxPoolSize', 'minPoolSize', 'maxIdleTimeMS', 'waitQueueTimeoutMS']);

function resolveOptions(options, defaults) {
  var newOptions = Array.from(VALID_POOL_OPTIONS).reduce(function (obj, key) {
    if (Object.prototype.hasOwnProperty.call(options, key)) {
      obj[key] = options[key];
    }

    return obj;
  }, {});
  return Object.freeze(Object.assign({}, defaults, newOptions));
}
/**
 * Configuration options for drivers wrapping the node driver.
 *
 * @typedef {Object} ConnectionPoolOptions
 * @property
 * @property {string} [host] The host to connect to
 * @property {number} [port] The port to connect to
 * @property {bson} [bson] The BSON instance to use for new connections
 * @property {number} [maxPoolSize=100] The maximum number of connections that may be associated with a pool at a given time. This includes in use and available connections.
 * @property {number} [minPoolSize=0] The minimum number of connections that MUST exist at any moment in a single connection pool.
 * @property {number} [maxIdleTimeMS] The maximum amount of time a connection should remain idle in the connection pool before being marked idle.
 * @property {number} [waitQueueTimeoutMS=0] The maximum amount of time operation execution should wait for a connection to become available. The default is 0 which means there is no limit.
 */

/**
 * A pool of connections which dynamically resizes, and emit events related to pool activity
 *
 * @property {number} generation An integer representing the SDAM generation of the pool
 * @property {number} totalConnectionCount An integer expressing how many total connections (active + in use) the pool currently has
 * @property {number} availableConnectionCount An integer expressing how many connections are currently available in the pool.
 * @property {string} address The address of the endpoint the pool is connected to
 *
 * @emits ConnectionPool#connectionPoolCreated
 * @emits ConnectionPool#connectionPoolClosed
 * @emits ConnectionPool#connectionCreated
 * @emits ConnectionPool#connectionReady
 * @emits ConnectionPool#connectionClosed
 * @emits ConnectionPool#connectionCheckOutStarted
 * @emits ConnectionPool#connectionCheckOutFailed
 * @emits ConnectionPool#connectionCheckedOut
 * @emits ConnectionPool#connectionCheckedIn
 * @emits ConnectionPool#connectionPoolCleared
 */


var ConnectionPool =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(ConnectionPool, _EventEmitter);

  /**
   * Create a new Connection Pool
   *
   * @param {ConnectionPoolOptions} options
   */
  function ConnectionPool(options) {
    var _this;

    _classCallCheck(this, ConnectionPool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionPool).call(this));
    options = options || {};
    _this.closed = false;
    _this.options = resolveOptions(options, {
      connectionType: Connection,
      maxPoolSize: typeof options.maxPoolSize === 'number' ? options.maxPoolSize : 100,
      minPoolSize: typeof options.minPoolSize === 'number' ? options.minPoolSize : 0,
      maxIdleTimeMS: typeof options.maxIdleTimeMS === 'number' ? options.maxIdleTimeMS : 0,
      waitQueueTimeoutMS: typeof options.waitQueueTimeoutMS === 'number' ? options.waitQueueTimeoutMS : 0,
      autoEncrypter: options.autoEncrypter,
      metadata: options.metadata
    });

    if (options.minSize > options.maxSize) {
      throw new TypeError('Connection pool minimum size must not be greater than maxiumum pool size');
    }

    _this[kLogger] = Logger('ConnectionPool', options);
    _this[kConnections] = new Denque();
    _this[kPermits] = _this.options.maxPoolSize;
    _this[kMinPoolSizeTimer] = undefined;
    _this[kGeneration] = 0;
    _this[kConnectionCounter] = makeCounter(1);
    _this[kCancellationToken] = new EventEmitter();

    _this[kCancellationToken].setMaxListeners(Infinity);

    _this[kWaitQueue] = new Denque();
    process.nextTick(function () {
      _this.emit('connectionPoolCreated', new ConnectionPoolCreatedEvent(_assertThisInitialized(_this)));

      ensureMinPoolSize(_assertThisInitialized(_this));
    });
    return _this;
  }

  _createClass(ConnectionPool, [{
    key: "checkOut",

    /**
     * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it
     * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or
     * explicitly destroyed by the new owner.
     *
     * @param {ConnectionPool~checkOutCallback} callback
     */
    value: function checkOut(callback) {
      var _this2 = this;

      this.emit('connectionCheckOutStarted', new ConnectionCheckOutStartedEvent(this));

      if (this.closed) {
        this.emit('connectionCheckOutFailed', new ConnectionCheckOutFailedEvent(this, 'poolClosed'));
        callback(new PoolClosedError(this));
        return;
      }

      var waitQueueMember = {
        callback: callback
      };
      var pool = this;
      var waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;

      if (waitQueueTimeoutMS) {
        waitQueueMember.timer = setTimeout(function () {
          waitQueueMember[kCancelled] = true;
          waitQueueMember.timer = undefined;
          pool.emit('connectionCheckOutFailed', new ConnectionCheckOutFailedEvent(pool, 'timeout'));
          waitQueueMember.callback(new WaitQueueTimeoutError(pool));
        }, waitQueueTimeoutMS);
      }

      this[kWaitQueue].push(waitQueueMember);
      process.nextTick(function () {
        return processWaitQueue(_this2);
      });
    }
    /**
     * Check a connection into the pool.
     *
     * @param {Connection} connection The connection to check in
     */

  }, {
    key: "checkIn",
    value: function checkIn(connection) {
      var _this3 = this;

      var poolClosed = this.closed;
      var stale = connectionIsStale(this, connection);
      var willDestroy = !!(poolClosed || stale || connection.closed);

      if (!willDestroy) {
        connection.markAvailable();
        this[kConnections].push(connection);
      }

      this.emit('connectionCheckedIn', new ConnectionCheckedInEvent(this, connection));

      if (willDestroy) {
        var reason = connection.closed ? 'error' : poolClosed ? 'poolClosed' : 'stale';
        destroyConnection(this, connection, reason);
      }

      process.nextTick(function () {
        return processWaitQueue(_this3);
      });
    }
    /**
     * Clear the pool
     *
     * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a
     * previous generation will eventually be pruned during subsequent checkouts.
     */

  }, {
    key: "clear",
    value: function clear() {
      this[kGeneration] += 1;
      this.emit('connectionPoolCleared', new ConnectionPoolClearedEvent(this));
    }
    /**
     * Close the pool
     *
     * @param {object} [options] Optional settings
     * @param {boolean} [options.force] Force close connections
     * @param {Function} callback
     */

  }, {
    key: "close",
    value: function close(options, callback) {
      var _this4 = this;

      if (typeof options === 'function') {
        callback = options;
      }

      options = Object.assign({
        force: false
      }, options);

      if (this.closed) {
        return callback();
      } // immediately cancel any in-flight connections


      this[kCancellationToken].emit('cancel'); // drain the wait queue

      while (this.waitQueueSize) {
        var waitQueueMember = this[kWaitQueue].pop();
        clearTimeout(waitQueueMember.timer);

        if (!waitQueueMember[kCancelled]) {
          waitQueueMember.callback(new MongoError('connection pool closed'));
        }
      } // clear the min pool size timer


      if (this[kMinPoolSizeTimer]) {
        clearTimeout(this[kMinPoolSizeTimer]);
      } // end the connection counter


      if (typeof this[kConnectionCounter]["return"] === 'function') {
        this[kConnectionCounter]["return"]();
      } // mark the pool as closed immediately


      this.closed = true;
      eachAsync(this[kConnections].toArray(), function (conn, cb) {
        _this4.emit('connectionClosed', new ConnectionClosedEvent(_this4, conn, 'poolClosed'));

        conn.destroy(options, cb);
      }, function (err) {
        _this4[kConnections].clear();

        _this4.emit('connectionPoolClosed', new ConnectionPoolClosedEvent(_this4));

        callback(err);
      });
    }
    /**
     * Runs a lambda with an implicitly checked out connection, checking that connection back in when the lambda
     * has completed by calling back.
     *
     * NOTE: please note the required signature of `fn`
     *
     * @param {ConnectionPool~withConnectionCallback} fn A function which operates on a managed connection
     * @param {Function} callback The original callback
     * @return {Promise}
     */

  }, {
    key: "withConnection",
    value: function withConnection(fn, callback) {
      var _this5 = this;

      this.checkOut(function (err, conn) {
        // don't callback with `err` here, we might want to act upon it inside `fn`
        fn(err, conn, function (fnErr, result) {
          if (typeof callback === 'function') {
            if (fnErr) {
              callback(fnErr);
            } else {
              callback(undefined, result);
            }
          }

          if (conn) {
            _this5.checkIn(conn);
          }
        });
      });
    }
  }, {
    key: "address",
    get: function get() {
      return "".concat(this.options.host, ":").concat(this.options.port);
    }
  }, {
    key: "generation",
    get: function get() {
      return this[kGeneration];
    }
  }, {
    key: "totalConnectionCount",
    get: function get() {
      return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);
    }
  }, {
    key: "availableConnectionCount",
    get: function get() {
      return this[kConnections].length;
    }
  }, {
    key: "waitQueueSize",
    get: function get() {
      return this[kWaitQueue].length;
    }
  }]);

  return ConnectionPool;
}(EventEmitter);

function ensureMinPoolSize(pool) {
  if (pool.closed || pool.options.minPoolSize === 0) {
    return;
  }

  var minPoolSize = pool.options.minPoolSize;

  for (var i = pool.totalConnectionCount; i < minPoolSize; ++i) {
    createConnection(pool);
  }

  pool[kMinPoolSizeTimer] = setTimeout(function () {
    return ensureMinPoolSize(pool);
  }, 10);
}

function connectionIsStale(pool, connection) {
  return connection.generation !== pool[kGeneration];
}

function connectionIsIdle(pool, connection) {
  return !!(pool.options.maxIdleTimeMS && connection.idleTime > pool.options.maxIdleTimeMS);
}

function createConnection(pool, callback) {
  var connectOptions = Object.assign({
    id: pool[kConnectionCounter].next().value,
    generation: pool[kGeneration]
  }, pool.options);
  pool[kPermits]--;
  connect(connectOptions, pool[kCancellationToken], function (err, connection) {
    if (err) {
      pool[kPermits]++;
      pool[kLogger].debug("connection attempt failed with error [".concat(JSON.stringify(err), "]"));

      if (typeof callback === 'function') {
        callback(err);
      }

      return;
    } // The pool might have closed since we started trying to create a connection


    if (pool.closed) {
      connection.destroy({
        force: true
      });
      return;
    } // forward all events from the connection to the pool


    relayEvents(connection, pool, ['commandStarted', 'commandFailed', 'commandSucceeded', 'clusterTimeReceived']);
    pool.emit('connectionCreated', new ConnectionCreatedEvent(pool, connection));
    connection.markAvailable();
    pool.emit('connectionReady', new ConnectionReadyEvent(pool, connection)); // if a callback has been provided, check out the connection immediately

    if (typeof callback === 'function') {
      callback(undefined, connection);
      return;
    } // otherwise add it to the pool for later acquisition, and try to process the wait queue


    pool[kConnections].push(connection);
    process.nextTick(function () {
      return processWaitQueue(pool);
    });
  });
}

function destroyConnection(pool, connection, reason) {
  pool.emit('connectionClosed', new ConnectionClosedEvent(pool, connection, reason)); // allow more connections to be created

  pool[kPermits]++; // destroy the connection

  process.nextTick(function () {
    return connection.destroy();
  });
}

function processWaitQueue(pool) {
  if (pool.closed) {
    return;
  }

  while (pool.waitQueueSize) {
    var waitQueueMember = pool[kWaitQueue].peekFront();

    if (waitQueueMember[kCancelled]) {
      pool[kWaitQueue].shift();
      continue;
    }

    if (!pool.availableConnectionCount) {
      break;
    }

    var connection = pool[kConnections].shift();
    var isStale = connectionIsStale(pool, connection);
    var isIdle = connectionIsIdle(pool, connection);

    if (!isStale && !isIdle && !connection.closed) {
      pool.emit('connectionCheckedOut', new ConnectionCheckedOutEvent(pool, connection));
      clearTimeout(waitQueueMember.timer);
      pool[kWaitQueue].shift();
      waitQueueMember.callback(undefined, connection);
      return;
    }

    var reason = connection.closed ? 'error' : isStale ? 'stale' : 'idle';
    destroyConnection(pool, connection, reason);
  }

  var maxPoolSize = pool.options.maxPoolSize;

  if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {
    createConnection(pool, function (err, connection) {
      var waitQueueMember = pool[kWaitQueue].shift();

      if (waitQueueMember == null || waitQueueMember[kCancelled]) {
        if (err == null) {
          pool[kConnections].push(connection);
        }

        return;
      }

      if (err) {
        pool.emit('connectionCheckOutFailed', new ConnectionCheckOutFailedEvent(pool, err));
      } else {
        pool.emit('connectionCheckedOut', new ConnectionCheckedOutEvent(pool, connection));
      }

      clearTimeout(waitQueueMember.timer);
      waitQueueMember.callback(err, connection);
    });
    return;
  }
}
/**
 * A callback provided to `withConnection`
 *
 * @callback ConnectionPool~withConnectionCallback
 * @param {MongoError} error An error instance representing the error during the execution.
 * @param {Connection} connection The managed connection which was checked out of the pool.
 * @param {Function} callback A function to call back after connection management is complete
 */

/**
 * A callback provided to `checkOut`
 *
 * @callback ConnectionPool~checkOutCallback
 * @param {MongoError} error An error instance representing the error during checkout
 * @param {Connection} connection A connection from the pool
 */

/**
 * Emitted once when the connection pool is created
 *
 * @event ConnectionPool#connectionPoolCreated
 * @type {PoolCreatedEvent}
 */

/**
 * Emitted once when the connection pool is closed
 *
 * @event ConnectionPool#connectionPoolClosed
 * @type {PoolClosedEvent}
 */

/**
 * Emitted each time a connection is created
 *
 * @event ConnectionPool#connectionCreated
 * @type {ConnectionCreatedEvent}
 */

/**
 * Emitted when a connection becomes established, and is ready to use
 *
 * @event ConnectionPool#connectionReady
 * @type {ConnectionReadyEvent}
 */

/**
 * Emitted when a connection is closed
 *
 * @event ConnectionPool#connectionClosed
 * @type {ConnectionClosedEvent}
 */

/**
 * Emitted when an attempt to check out a connection begins
 *
 * @event ConnectionPool#connectionCheckOutStarted
 * @type {ConnectionCheckOutStartedEvent}
 */

/**
 * Emitted when an attempt to check out a connection fails
 *
 * @event ConnectionPool#connectionCheckOutFailed
 * @type {ConnectionCheckOutFailedEvent}
 */

/**
 * Emitted each time a connection is successfully checked out of the connection pool
 *
 * @event ConnectionPool#connectionCheckedOut
 * @type {ConnectionCheckedOutEvent}
 */

/**
 * Emitted each time a connection is successfully checked into the connection pool
 *
 * @event ConnectionPool#connectionCheckedIn
 * @type {ConnectionCheckedInEvent}
 */

/**
 * Emitted each time the connection pool is cleared and it's generation incremented
 *
 * @event ConnectionPool#connectionPoolCleared
 * @type {PoolClearedEvent}
 */


module.exports = {
  ConnectionPool: ConnectionPool
};