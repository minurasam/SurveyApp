'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var AuthProvider = require('./auth_provider').AuthProvider;

var MongoCredentials = require('./mongo_credentials').MongoCredentials;

var MongoError = require('../error').MongoError;

var crypto = require('crypto');

var http = require('http');

var maxWireVersion = require('../utils').maxWireVersion;

var url = require('url');

var aws4;

try {
  aws4 = require('aws4');
} catch (e) {// don't do anything;
}

var ASCII_N = 110;
var AWS_RELATIVE_URI = 'http://169.254.170.2';
var AWS_EC2_URI = 'http://169.254.169.254';
var AWS_EC2_PATH = '/latest/meta-data/iam/security-credentials';

var MongoDBAWS =
/*#__PURE__*/
function (_AuthProvider) {
  _inherits(MongoDBAWS, _AuthProvider);

  function MongoDBAWS() {
    _classCallCheck(this, MongoDBAWS);

    return _possibleConstructorReturn(this, _getPrototypeOf(MongoDBAWS).apply(this, arguments));
  }

  _createClass(MongoDBAWS, [{
    key: "auth",
    value: function auth(authContext, callback) {
      var _this = this;

      var connection = authContext.connection;
      var credentials = authContext.credentials;

      if (maxWireVersion(connection) < 9) {
        callback(new MongoError('MONGODB-AWS authentication requires MongoDB version 4.4 or later'));
        return;
      }

      if (aws4 == null) {
        callback(new MongoError('MONGODB-AWS authentication requires the `aws4` module, please install it as a dependency of your project'));
        return;
      }

      if (credentials.username == null) {
        makeTempCredentials(credentials, function (err, tempCredentials) {
          if (err) return callback(err);
          authContext.credentials = tempCredentials;

          _this.auth(authContext, callback);
        });
        return;
      }

      var username = credentials.username;
      var password = credentials.password;
      var db = credentials.source;
      var token = credentials.mechanismProperties.AWS_SESSION_TOKEN;
      var bson = this.bson;
      crypto.randomBytes(32, function (err, nonce) {
        if (err) {
          callback(err);
          return;
        }

        var saslStart = {
          saslStart: 1,
          mechanism: 'MONGODB-AWS',
          payload: bson.serialize({
            r: nonce,
            p: ASCII_N
          })
        };
        connection.command("".concat(db, ".$cmd"), saslStart, function (err, result) {
          if (err) return callback(err);
          var res = result.result;
          var serverResponse = bson.deserialize(res.payload.buffer);
          var host = serverResponse.h;
          var serverNonce = serverResponse.s.buffer;

          if (serverNonce.length !== 64) {
            callback(new MongoError("Invalid server nonce length ".concat(serverNonce.length, ", expected 64")));
            return;
          }

          if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {
            callback(new MongoError('Server nonce does not begin with client nonce'));
            return;
          }

          if (host.length < 1 || host.length > 255 || host.indexOf('..') !== -1) {
            callback(new MongoError("Server returned an invalid host: \"".concat(host, "\"")));
            return;
          }

          var body = 'Action=GetCallerIdentity&Version=2011-06-15';
          var options = aws4.sign({
            method: 'POST',
            host: host,
            region: deriveRegion(serverResponse.h),
            service: 'sts',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
              'Content-Length': body.length,
              'X-MongoDB-Server-Nonce': serverNonce.toString('base64'),
              'X-MongoDB-GS2-CB-Flag': 'n'
            },
            path: '/',
            body: body
          }, {
            accessKeyId: username,
            secretAccessKey: password,
            token: token
          });
          var authorization = options.headers.Authorization;
          var date = options.headers['X-Amz-Date'];
          var payload = {
            a: authorization,
            d: date
          };

          if (token) {
            payload.t = token;
          }

          var saslContinue = {
            saslContinue: 1,
            conversationId: 1,
            payload: bson.serialize(payload)
          };
          connection.command("".concat(db, ".$cmd"), saslContinue, function (err) {
            if (err) return callback(err);
            callback();
          });
        });
      });
    }
  }]);

  return MongoDBAWS;
}(AuthProvider);

function makeTempCredentials(credentials, callback) {
  function done(creds) {
    if (creds.AccessKeyId == null || creds.SecretAccessKey == null || creds.Token == null) {
      callback(new MongoError('Could not obtain temporary MONGODB-AWS credentials'));
      return;
    }

    callback(undefined, new MongoCredentials({
      username: creds.AccessKeyId,
      password: creds.SecretAccessKey,
      source: credentials.source,
      mechanism: 'MONGODB-AWS',
      mechanismProperties: {
        AWS_SESSION_TOKEN: creds.Token
      }
    }));
  } // If the environment variable AWS_CONTAINER_CREDENTIALS_RELATIVE_URI
  // is set then drivers MUST assume that it was set by an AWS ECS agent


  if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
    request("".concat(AWS_RELATIVE_URI).concat(process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI), function (err, res) {
      if (err) return callback(err);
      done(res);
    });
    return;
  } // Otherwise assume we are on an EC2 instance
  // get a token


  request("".concat(AWS_EC2_URI, "/latest/api/token"), {
    method: 'PUT',
    json: false,
    headers: {
      'X-aws-ec2-metadata-token-ttl-seconds': 30
    }
  }, function (err, token) {
    if (err) return callback(err); // get role name

    request("".concat(AWS_EC2_URI, "/").concat(AWS_EC2_PATH), {
      json: false,
      headers: {
        'X-aws-ec2-metadata-token': token
      }
    }, function (err, roleName) {
      if (err) return callback(err); // get temp credentials

      request("".concat(AWS_EC2_URI, "/").concat(AWS_EC2_PATH, "/").concat(roleName), {
        headers: {
          'X-aws-ec2-metadata-token': token
        }
      }, function (err, creds) {
        if (err) return callback(err);
        done(creds);
      });
    });
  });
}

function deriveRegion(host) {
  var parts = host.split('.');

  if (parts.length === 1 || parts[1] === 'amazonaws') {
    return 'us-east-1';
  }

  return parts[1];
}

function request(uri, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = Object.assign({
    method: 'GET',
    timeout: 10000,
    json: true
  }, url.parse(uri), options);
  var req = http.request(options, function (res) {
    res.setEncoding('utf8');
    var data = '';
    res.on('data', function (d) {
      return data += d;
    });
    res.on('end', function () {
      if (options.json === false) {
        callback(undefined, data);
        return;
      }

      try {
        var parsed = JSON.parse(data);
        callback(undefined, parsed);
      } catch (err) {
        callback(new MongoError("Invalid JSON response: \"".concat(data, "\"")));
      }
    });
  });
  req.on('error', function (err) {
    return callback(err);
  });
  req.end();
}

module.exports = MongoDBAWS;