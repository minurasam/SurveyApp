'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var crypto = require('crypto');

var Buffer = require('safe-buffer').Buffer;

var retrieveBSON = require('../connection/utils').retrieveBSON;

var MongoError = require('../error').MongoError;

var AuthProvider = require('./auth_provider').AuthProvider;

var emitWarningOnce = require('../../utils').emitWarning;

var BSON = retrieveBSON();
var Binary = BSON.Binary;
var saslprep;

try {
  saslprep = require('saslprep');
} catch (e) {// don't do anything;
}

var ScramSHA =
/*#__PURE__*/
function (_AuthProvider) {
  _inherits(ScramSHA, _AuthProvider);

  function ScramSHA(bson, cryptoMethod) {
    var _this;

    _classCallCheck(this, ScramSHA);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA).call(this, bson));
    _this.cryptoMethod = cryptoMethod || 'sha1';
    return _this;
  }

  _createClass(ScramSHA, [{
    key: "prepare",
    value: function prepare(handshakeDoc, authContext, callback) {
      var cryptoMethod = this.cryptoMethod;

      if (cryptoMethod === 'sha256' && saslprep == null) {
        emitWarningOnce('Warning: no saslprep library specified. Passwords will not be sanitized');
      }

      crypto.randomBytes(24, function (err, nonce) {
        if (err) {
          return callback(err);
        } // store the nonce for later use


        Object.assign(authContext, {
          nonce: nonce
        });
        var credentials = authContext.credentials;
        var request = Object.assign({}, handshakeDoc, {
          speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {
            db: credentials.source
          })
        });
        callback(undefined, request);
      });
    }
  }, {
    key: "auth",
    value: function auth(authContext, callback) {
      var response = authContext.response;

      if (response && response.speculativeAuthenticate) {
        continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);
        return;
      }

      executeScram(this.cryptoMethod, authContext, callback);
    }
  }]);

  return ScramSHA;
}(AuthProvider);

function cleanUsername(username) {
  return username.replace('=', '=3D').replace(',', '=2C');
}

function clientFirstMessageBare(username, nonce) {
  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.
  // Since the username is not sasl-prep-d, we need to do this here.
  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);
}

function makeFirstMessage(cryptoMethod, credentials, nonce) {
  var username = cleanUsername(credentials.username);
  var mechanism = cryptoMethod === 'sha1' ? 'SCRAM-SHA-1' : 'SCRAM-SHA-256'; // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.
  // Since the username is not sasl-prep-d, we need to do this here.

  return {
    saslStart: 1,
    mechanism: mechanism,
    payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),
    autoAuthorize: 1,
    options: {
      skipEmptyExchange: true
    }
  };
}

function executeScram(cryptoMethod, authContext, callback) {
  var connection = authContext.connection;
  var credentials = authContext.credentials;
  var nonce = authContext.nonce;
  var db = credentials.source;
  var saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
  connection.command("".concat(db, ".$cmd"), saslStartCmd, function (_err, result) {
    var err = resolveError(_err, result);

    if (err) {
      return callback(err);
    }

    continueScramConversation(cryptoMethod, result.result, authContext, callback);
  });
}

function continueScramConversation(cryptoMethod, response, authContext, callback) {
  var connection = authContext.connection;
  var credentials = authContext.credentials;
  var nonce = authContext.nonce;
  var db = credentials.source;
  var username = cleanUsername(credentials.username);
  var password = credentials.password;
  var processedPassword;

  if (cryptoMethod === 'sha256') {
    processedPassword = saslprep ? saslprep(password) : password;
  } else {
    try {
      processedPassword = passwordDigest(username, password);
    } catch (e) {
      return callback(e);
    }
  }

  var payload = Buffer.isBuffer(response.payload) ? new Binary(response.payload) : response.payload;
  var dict = parsePayload(payload.value());
  var iterations = parseInt(dict.i, 10);

  if (iterations && iterations < 4096) {
    callback(new MongoError("Server returned an invalid iteration count ".concat(iterations)), false);
    return;
  }

  var salt = dict.s;
  var rnonce = dict.r;

  if (rnonce.startsWith('nonce')) {
    callback(new MongoError("Server returned an invalid nonce: ".concat(rnonce)), false);
    return;
  } // Set up start of proof


  var withoutProof = "c=biws,r=".concat(rnonce);
  var saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);
  var clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');
  var serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');
  var storedKey = H(cryptoMethod, clientKey);
  var authMessage = [clientFirstMessageBare(username, nonce), payload.value().toString('base64'), withoutProof].join(',');
  var clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
  var clientProof = "p=".concat(xor(clientKey, clientSignature));
  var clientFinal = [withoutProof, clientProof].join(',');
  var serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
  var saslContinueCmd = {
    saslContinue: 1,
    conversationId: response.conversationId,
    payload: new Binary(Buffer.from(clientFinal))
  };
  connection.command("".concat(db, ".$cmd"), saslContinueCmd, function (_err, result) {
    var err = resolveError(_err, result);

    if (err) {
      return callback(err);
    }

    var r = result.result;
    var parsedResponse = parsePayload(r.payload.value());

    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {
      callback(new MongoError('Server returned an invalid signature'));
      return;
    }

    if (!r || r.done !== false) {
      return callback(err, r);
    }

    var retrySaslContinueCmd = {
      saslContinue: 1,
      conversationId: r.conversationId,
      payload: Buffer.alloc(0)
    };
    connection.command("".concat(db, ".$cmd"), retrySaslContinueCmd, callback);
  });
}

function parsePayload(payload) {
  var dict = {};
  var parts = payload.split(',');

  for (var i = 0; i < parts.length; i++) {
    var valueParts = parts[i].split('=');
    dict[valueParts[0]] = valueParts[1];
  }

  return dict;
}

function passwordDigest(username, password) {
  if (typeof username !== 'string') {
    throw new MongoError('username must be a string');
  }

  if (typeof password !== 'string') {
    throw new MongoError('password must be a string');
  }

  if (password.length === 0) {
    throw new MongoError('password cannot be empty');
  }

  var md5 = crypto.createHash('md5');
  md5.update("".concat(username, ":mongo:").concat(password), 'utf8');
  return md5.digest('hex');
} // XOR two buffers


function xor(a, b) {
  if (!Buffer.isBuffer(a)) {
    a = Buffer.from(a);
  }

  if (!Buffer.isBuffer(b)) {
    b = Buffer.from(b);
  }

  var length = Math.max(a.length, b.length);
  var res = [];

  for (var i = 0; i < length; i += 1) {
    res.push(a[i] ^ b[i]);
  }

  return Buffer.from(res).toString('base64');
}

function H(method, text) {
  return crypto.createHash(method).update(text).digest();
}

function HMAC(method, key, text) {
  return crypto.createHmac(method, key).update(text).digest();
}

var _hiCache = {};
var _hiCacheCount = 0;

function _hiCachePurge() {
  _hiCache = {};
  _hiCacheCount = 0;
}

var hiLengthMap = {
  sha256: 32,
  sha1: 20
};

function HI(data, salt, iterations, cryptoMethod) {
  // omit the work if already generated
  var key = [data, salt.toString('base64'), iterations].join('_');

  if (_hiCache[key] !== undefined) {
    return _hiCache[key];
  } // generate the salt


  var saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth

  if (_hiCacheCount >= 200) {
    _hiCachePurge();
  }

  _hiCache[key] = saltedData;
  _hiCacheCount += 1;
  return saltedData;
}

function compareDigest(lhs, rhs) {
  if (lhs.length !== rhs.length) {
    return false;
  }

  if (typeof crypto.timingSafeEqual === 'function') {
    return crypto.timingSafeEqual(lhs, rhs);
  }

  var result = 0;

  for (var i = 0; i < lhs.length; i++) {
    result |= lhs[i] ^ rhs[i];
  }

  return result === 0;
}

function resolveError(err, result) {
  if (err) return err;
  var r = result.result;
  if (r.$err || r.errmsg) return new MongoError(r);
}

var ScramSHA1 =
/*#__PURE__*/
function (_ScramSHA) {
  _inherits(ScramSHA1, _ScramSHA);

  function ScramSHA1(bson) {
    _classCallCheck(this, ScramSHA1);

    return _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA1).call(this, bson, 'sha1'));
  }

  return ScramSHA1;
}(ScramSHA);

var ScramSHA256 =
/*#__PURE__*/
function (_ScramSHA2) {
  _inherits(ScramSHA256, _ScramSHA2);

  function ScramSHA256(bson) {
    _classCallCheck(this, ScramSHA256);

    return _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA256).call(this, bson, 'sha256'));
  }

  return ScramSHA256;
}(ScramSHA);

module.exports = {
  ScramSHA1: ScramSHA1,
  ScramSHA256: ScramSHA256
};