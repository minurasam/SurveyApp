'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var dns = require('dns');

var AuthProvider = require('./auth_provider').AuthProvider;

var retrieveKerberos = require('../utils').retrieveKerberos;

var MongoError = require('../error').MongoError;

var kerberos;

var GSSAPI =
/*#__PURE__*/
function (_AuthProvider) {
  _inherits(GSSAPI, _AuthProvider);

  function GSSAPI() {
    _classCallCheck(this, GSSAPI);

    return _possibleConstructorReturn(this, _getPrototypeOf(GSSAPI).apply(this, arguments));
  }

  _createClass(GSSAPI, [{
    key: "auth",
    value: function auth(authContext, callback) {
      var connection = authContext.connection;
      var credentials = authContext.credentials;
      if (credentials == null) return callback(new MongoError('credentials required'));
      var username = credentials.username;

      function externalCommand(command, cb) {
        return connection.command('$external.$cmd', command, cb);
      }

      makeKerberosClient(authContext, function (err, client) {
        if (err) return callback(err);
        if (client == null) return callback(new MongoError('gssapi client missing'));
        client.step('', function (err, payload) {
          if (err) return callback(err);
          externalCommand(saslStart(payload), function (err, response) {
            if (err) return callback(err);
            var result = response.result;
            negotiate(client, 10, result.payload, function (err, payload) {
              if (err) return callback(err);
              externalCommand(saslContinue(payload, result.conversationId), function (err, response) {
                if (err) return callback(err);
                var result = response.result;
                finalize(client, username, result.payload, function (err, payload) {
                  if (err) return callback(err);
                  externalCommand({
                    saslContinue: 1,
                    conversationId: result.conversationId,
                    payload: payload
                  }, function (err, result) {
                    if (err) return callback(err);
                    callback(undefined, result);
                  });
                });
              });
            });
          });
        });
      });
    }
  }]);

  return GSSAPI;
}(AuthProvider);

module.exports = GSSAPI;

function makeKerberosClient(authContext, callback) {
  var host = authContext.options.host;
  var port = authContext.options.port;
  var credentials = authContext.credentials;

  if (!host || !port || !credentials) {
    return callback(new MongoError("Connection must specify: ".concat(host ? 'host' : '', ", ").concat(port ? 'port' : '', ", ").concat(credentials ? 'host' : 'credentials', ".")));
  }

  if (kerberos == null) {
    try {
      kerberos = retrieveKerberos();
    } catch (e) {
      return callback(e);
    }
  }

  var username = credentials.username;
  var password = credentials.password;
  var mechanismProperties = credentials.mechanismProperties;
  var serviceName = mechanismProperties['gssapiservicename'] || mechanismProperties['gssapiServiceName'] || 'mongodb';
  performGssapiCanonicalizeHostName(host, mechanismProperties, function (err, host) {
    if (err) return callback(err);
    var initOptions = {};

    if (password != null) {
      Object.assign(initOptions, {
        user: username,
        password: password
      });
    }

    kerberos.initializeClient("".concat(serviceName).concat(process.platform === 'win32' ? '/' : '@').concat(host), initOptions, function (err, client) {
      if (err) return callback(new MongoError(err));
      callback(null, client);
    });
  });
}

function saslStart(payload) {
  return {
    saslStart: 1,
    mechanism: 'GSSAPI',
    payload: payload,
    autoAuthorize: 1
  };
}

function saslContinue(payload, conversationId) {
  return {
    saslContinue: 1,
    conversationId: conversationId,
    payload: payload
  };
}

function negotiate(client, retries, payload, callback) {
  client.step(payload, function (err, response) {
    // Retries exhausted, raise error
    if (err && retries === 0) return callback(err); // Adjust number of retries and call step again

    if (err) return negotiate(client, retries - 1, payload, callback); // Return the payload

    callback(undefined, response || '');
  });
}

function finalize(client, user, payload, callback) {
  // GSS Client Unwrap
  client.unwrap(payload, function (err, response) {
    if (err) return callback(err); // Wrap the response

    client.wrap(response || '', {
      user: user
    }, function (err, wrapped) {
      if (err) return callback(err); // Return the payload

      callback(undefined, wrapped);
    });
  });
}

function performGssapiCanonicalizeHostName(host, mechanismProperties, callback) {
  var canonicalizeHostName = typeof mechanismProperties.gssapiCanonicalizeHostName === 'boolean' ? mechanismProperties.gssapiCanonicalizeHostName : false;
  if (!canonicalizeHostName) return callback(undefined, host); // Attempt to resolve the host name

  dns.resolveCname(host, function (err, r) {
    if (err) return callback(err); // Get the first resolve host id

    if (Array.isArray(r) && r.length > 0) {
      return callback(undefined, r[0]);
    }

    callback(undefined, host);
  });
}