'use strict';

var _makeStateMachine;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ServerType = require('./common').ServerType;

var EventEmitter = require('events');

var connect = require('../connection/connect');

var Connection = require('../../cmap/connection').Connection;

var common = require('./common');

var makeStateMachine = require('../utils').makeStateMachine;

var MongoNetworkError = require('../error').MongoNetworkError;

var BSON = require('../connection/utils').retrieveBSON();

var makeInterruptableAsyncInterval = require('../../utils').makeInterruptableAsyncInterval;

var calculateDurationInMs = require('../../utils').calculateDurationInMs;

var now = require('../../utils').now;

var sdamEvents = require('./events');

var ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;
var ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;
var ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;
var kServer = Symbol('server');
var kMonitorId = Symbol('monitorId');
var kConnection = Symbol('connection');
var kCancellationToken = Symbol('cancellationToken');
var kRTTPinger = Symbol('rttPinger');
var kRoundTripTime = Symbol('roundTripTime');
var STATE_CLOSED = common.STATE_CLOSED;
var STATE_CLOSING = common.STATE_CLOSING;
var STATE_IDLE = 'idle';
var STATE_MONITORING = 'monitoring';
var stateTransition = makeStateMachine((_makeStateMachine = {}, _defineProperty(_makeStateMachine, STATE_CLOSING, [STATE_CLOSING, STATE_IDLE, STATE_CLOSED]), _defineProperty(_makeStateMachine, STATE_CLOSED, [STATE_CLOSED, STATE_MONITORING]), _defineProperty(_makeStateMachine, STATE_IDLE, [STATE_IDLE, STATE_MONITORING, STATE_CLOSING]), _defineProperty(_makeStateMachine, STATE_MONITORING, [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]), _makeStateMachine));
var INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);

function isInCloseState(monitor) {
  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;
}

var Monitor =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Monitor, _EventEmitter);

  function Monitor(server, options) {
    var _this;

    _classCallCheck(this, Monitor);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Monitor).call(this, options));
    _this[kServer] = server;
    _this[kConnection] = undefined;
    _this[kCancellationToken] = new EventEmitter();

    _this[kCancellationToken].setMaxListeners(Infinity);

    _this[kMonitorId] = null;
    _this.s = {
      state: STATE_CLOSED
    };
    _this.address = server.description.address;
    _this.options = Object.freeze({
      connectTimeoutMS: typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 10000,
      heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,
      minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500
    }); // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration

    var connectOptions = Object.assign({
      id: '<monitor>',
      host: server.description.host,
      port: server.description.port,
      bson: server.s.bson,
      connectionType: Connection
    }, server.s.options, _this.options, // force BSON serialization options
    {
      raw: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: true
    }); // ensure no authentication is used for monitoring

    delete connectOptions.credentials; // ensure encryption is not requested for monitoring

    delete connectOptions.autoEncrypter;
    _this.connectOptions = Object.freeze(connectOptions);
    return _this;
  }

  _createClass(Monitor, [{
    key: "connect",
    value: function connect() {
      if (this.s.state !== STATE_CLOSED) {
        return;
      } // start


      var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
        interval: heartbeatFrequencyMS,
        minInterval: minHeartbeatFrequencyMS,
        immediate: true
      });
    }
  }, {
    key: "requestCheck",
    value: function requestCheck() {
      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
        return;
      }

      this[kMonitorId].wake();
    }
  }, {
    key: "reset",
    value: function reset() {
      var topologyVersion = this[kServer].description.topologyVersion;

      if (isInCloseState(this) || topologyVersion == null) {
        return;
      }

      stateTransition(this, STATE_CLOSING);
      resetMonitorState(this); // restart monitor

      stateTransition(this, STATE_IDLE); // restart monitoring

      var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
        interval: heartbeatFrequencyMS,
        minInterval: minHeartbeatFrequencyMS
      });
    }
  }, {
    key: "close",
    value: function close() {
      if (isInCloseState(this)) {
        return;
      }

      stateTransition(this, STATE_CLOSING);
      resetMonitorState(this); // close monitor

      this.emit('close');
      stateTransition(this, STATE_CLOSED);
    }
  }]);

  return Monitor;
}(EventEmitter);

function resetMonitorState(monitor) {
  if (monitor[kMonitorId]) {
    monitor[kMonitorId].stop();
    monitor[kMonitorId] = null;
  }

  if (monitor[kRTTPinger]) {
    monitor[kRTTPinger].close();
    monitor[kRTTPinger] = undefined;
  }

  monitor[kCancellationToken].emit('cancel');

  if (monitor[kMonitorId]) {
    clearTimeout(monitor[kMonitorId]);
    monitor[kMonitorId] = undefined;
  }

  if (monitor[kConnection]) {
    monitor[kConnection].destroy({
      force: true
    });
  }
}

function checkServer(monitor, callback) {
  var start = now();
  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));

  function failureHandler(err) {
    if (monitor[kConnection]) {
      monitor[kConnection].destroy({
        force: true
      });
      monitor[kConnection] = undefined;
    }

    monitor.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));
    monitor.emit('resetServer', err);
    monitor.emit('resetConnectionPool');
    callback(err);
  }

  if (monitor[kConnection] != null && !monitor[kConnection].closed) {
    var connectTimeoutMS = monitor.options.connectTimeoutMS;
    var maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
    var topologyVersion = monitor[kServer].description.topologyVersion;
    var isAwaitable = topologyVersion != null;
    var cmd = {
      ismaster: true
    };
    var options = {
      socketTimeout: connectTimeoutMS
    };

    if (isAwaitable) {
      cmd.maxAwaitTimeMS = maxAwaitTimeMS;
      cmd.topologyVersion = makeTopologyVersion(topologyVersion);

      if (connectTimeoutMS) {
        options.socketTimeout = connectTimeoutMS + maxAwaitTimeMS;
      }

      options.exhaustAllowed = true;

      if (monitor[kRTTPinger] == null) {
        monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);
      }
    }

    monitor[kConnection].command('admin.$cmd', cmd, options, function (err, result) {
      if (err) {
        failureHandler(err);
        return;
      }

      var isMaster = result.result;
      var rttPinger = monitor[kRTTPinger];
      var duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);
      monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address)); // if we are using the streaming protocol then we immediately issue another `started`
      // event, otherwise the "check" is complete and return to the main monitor loop

      if (isAwaitable && isMaster.topologyVersion) {
        monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));
        start = now();
      } else {
        if (monitor[kRTTPinger]) {
          monitor[kRTTPinger].close();
          monitor[kRTTPinger] = undefined;
        }

        callback(undefined, isMaster);
      }
    });
    return;
  } // connecting does an implicit `ismaster`


  connect(monitor.connectOptions, monitor[kCancellationToken], function (err, conn) {
    if (conn && isInCloseState(monitor)) {
      conn.destroy({
        force: true
      });
      return;
    }

    if (err) {
      monitor[kConnection] = undefined; // we already reset the connection pool on network errors in all cases

      if (!(err instanceof MongoNetworkError)) {
        monitor.emit('resetConnectionPool');
      }

      failureHandler(err);
      return;
    }

    monitor[kConnection] = conn;
    monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));
    callback(undefined, conn.ismaster);
  });
}

function monitorServer(monitor) {
  return function (callback) {
    stateTransition(monitor, STATE_MONITORING);

    function done() {
      if (!isInCloseState(monitor)) {
        stateTransition(monitor, STATE_IDLE);
      }

      callback();
    } // TODO: the next line is a legacy event, remove in v4


    process.nextTick(function () {
      return monitor.emit('monitoring', monitor[kServer]);
    });
    checkServer(monitor, function (err, isMaster) {
      if (err) {
        // otherwise an error occured on initial discovery, also bail
        if (monitor[kServer].description.type === ServerType.Unknown) {
          monitor.emit('resetServer', err);
          return done();
        }
      } // if the check indicates streaming is supported, immediately reschedule monitoring


      if (isMaster && isMaster.topologyVersion) {
        setTimeout(function () {
          if (!isInCloseState(monitor)) {
            monitor[kMonitorId].wake();
          }
        });
      }

      done();
    });
  };
}

function makeTopologyVersion(tv) {
  return {
    processId: tv.processId,
    counter: BSON.Long.fromNumber(tv.counter)
  };
}

var RTTPinger =
/*#__PURE__*/
function () {
  function RTTPinger(cancellationToken, options) {
    var _this2 = this;

    _classCallCheck(this, RTTPinger);

    this[kConnection] = null;
    this[kCancellationToken] = cancellationToken;
    this[kRoundTripTime] = 0;
    this.closed = false;
    var heartbeatFrequencyMS = options.heartbeatFrequencyMS;
    this[kMonitorId] = setTimeout(function () {
      return measureRoundTripTime(_this2, options);
    }, heartbeatFrequencyMS);
  }

  _createClass(RTTPinger, [{
    key: "close",
    value: function close() {
      this.closed = true;
      clearTimeout(this[kMonitorId]);
      this[kMonitorId] = undefined;

      if (this[kConnection]) {
        this[kConnection].destroy({
          force: true
        });
      }
    }
  }, {
    key: "roundTripTime",
    get: function get() {
      return this[kRoundTripTime];
    }
  }]);

  return RTTPinger;
}();

function measureRoundTripTime(rttPinger, options) {
  var start = now();
  var cancellationToken = rttPinger[kCancellationToken];
  var heartbeatFrequencyMS = options.heartbeatFrequencyMS;

  if (rttPinger.closed) {
    return;
  }

  function measureAndReschedule(conn) {
    if (rttPinger.closed) {
      conn.destroy({
        force: true
      });
      return;
    }

    if (rttPinger[kConnection] == null) {
      rttPinger[kConnection] = conn;
    }

    rttPinger[kRoundTripTime] = calculateDurationInMs(start);
    rttPinger[kMonitorId] = setTimeout(function () {
      return measureRoundTripTime(rttPinger, options);
    }, heartbeatFrequencyMS);
  }

  if (rttPinger[kConnection] == null) {
    connect(options, cancellationToken, function (err, conn) {
      if (err) {
        rttPinger[kConnection] = undefined;
        rttPinger[kRoundTripTime] = 0;
        return;
      }

      measureAndReschedule(conn);
    });
    return;
  }

  rttPinger[kConnection].command('admin.$cmd', {
    ismaster: 1
  }, function (err) {
    if (err) {
      rttPinger[kConnection] = undefined;
      rttPinger[kRoundTripTime] = 0;
      return;
    }

    measureAndReschedule();
  });
}

module.exports = {
  Monitor: Monitor
};