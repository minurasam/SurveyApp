'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var ServerType = require('./common').ServerType;

var TopologyType = require('./common').TopologyType;

var ReadPreference = require('../topologies/read_preference');

var MongoError = require('../error').MongoError; // max staleness constants


var IDLE_WRITE_PERIOD = 10000;
var SMALLEST_MAX_STALENESS_SECONDS = 90;
/**
 * Returns a server selector that selects for writable servers
 */

function writableServerSelector() {
  return function (topologyDescription, servers) {
    return latencyWindowReducer(topologyDescription, servers.filter(function (s) {
      return s.isWritable;
    }));
  };
}
/**
 * Reduces the passed in array of servers by the rules of the "Max Staleness" specification
 * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst
 *
 * @param {ReadPreference} readPreference The read preference providing max staleness guidance
 * @param {topologyDescription} topologyDescription The topology description
 * @param {ServerDescription[]} servers The list of server descriptions to be reduced
 * @return {ServerDescription[]} The list of servers that satisfy the requirements of max staleness
 */


function maxStalenessReducer(readPreference, topologyDescription, servers) {
  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
    return servers;
  }

  var maxStaleness = readPreference.maxStalenessSeconds;
  var maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;

  if (maxStaleness < maxStalenessVariance) {
    throw new MongoError("maxStalenessSeconds must be at least ".concat(maxStalenessVariance, " seconds"));
  }

  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
    throw new MongoError("maxStalenessSeconds must be at least ".concat(SMALLEST_MAX_STALENESS_SECONDS, " seconds"));
  }

  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {
    var primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
    return servers.reduce(function (result, server) {
      var stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
      var staleness = stalenessMS / 1000;
      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);
      return result;
    }, []);
  }

  if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {
    if (servers.length === 0) {
      return servers;
    }

    var sMax = servers.reduce(function (max, s) {
      return s.lastWriteDate > max.lastWriteDate ? s : max;
    });
    return servers.reduce(function (result, server) {
      var stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
      var staleness = stalenessMS / 1000;
      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);
      return result;
    }, []);
  }

  return servers;
}
/**
 * Determines whether a server's tags match a given set of tags
 *
 * @param {String[]} tagSet The requested tag set to match
 * @param {String[]} serverTags The server's tags
 */


function tagSetMatch(tagSet, serverTags) {
  var keys = Object.keys(tagSet);
  var serverTagKeys = Object.keys(serverTags);

  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];

    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
      return false;
    }
  }

  return true;
}
/**
 * Reduces a set of server descriptions based on tags requested by the read preference
 *
 * @param {ReadPreference} readPreference The read preference providing the requested tags
 * @param {ServerDescription[]} servers The list of server descriptions to reduce
 * @return {ServerDescription[]} The list of servers matching the requested tags
 */


function tagSetReducer(readPreference, servers) {
  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
    return servers;
  }

  var _loop = function _loop(i) {
    var tagSet = readPreference.tags[i];
    var serversMatchingTagset = servers.reduce(function (matched, server) {
      if (tagSetMatch(tagSet, server.tags)) matched.push(server);
      return matched;
    }, []);

    if (serversMatchingTagset.length) {
      return {
        v: serversMatchingTagset
      };
    }
  };

  for (var i = 0; i < readPreference.tags.length; ++i) {
    var _ret = _loop(i);

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return [];
}
/**
 * Reduces a list of servers to ensure they fall within an acceptable latency window. This is
 * further specified in the "Server Selection" specification, found here:
 * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst
 *
 * @param {topologyDescription} topologyDescription The topology description
 * @param {ServerDescription[]} servers The list of servers to reduce
 * @returns {ServerDescription[]} The servers which fall within an acceptable latency window
 */


function latencyWindowReducer(topologyDescription, servers) {
  var low = servers.reduce(function (min, server) {
    return min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min);
  }, -1);
  var high = low + topologyDescription.localThresholdMS;
  return servers.reduce(function (result, server) {
    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);
    return result;
  }, []);
} // filters


function primaryFilter(server) {
  return server.type === ServerType.RSPrimary;
}

function secondaryFilter(server) {
  return server.type === ServerType.RSSecondary;
}

function nearestFilter(server) {
  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;
}

function knownFilter(server) {
  return server.type !== ServerType.Unknown;
}
/**
 * Returns a function which selects servers based on a provided read preference
 *
 * @param {ReadPreference} readPreference The read preference to select with
 */


function readPreferenceServerSelector(readPreference) {
  if (!readPreference.isValid()) {
    throw new TypeError('Invalid read preference specified');
  }

  return function (topologyDescription, servers) {
    var commonWireVersion = topologyDescription.commonWireVersion;

    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
      throw new MongoError("Minimum wire version '".concat(readPreference.minWireVersion, "' required, but found '").concat(commonWireVersion, "'"));
    }

    if (topologyDescription.type === TopologyType.Unknown) {
      return [];
    }

    if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {
      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
    }

    var mode = readPreference.mode;

    if (mode === ReadPreference.PRIMARY) {
      return servers.filter(primaryFilter);
    }

    if (mode === ReadPreference.PRIMARY_PREFERRED) {
      var result = servers.filter(primaryFilter);

      if (result.length) {
        return result;
      }
    }

    var filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
    var selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));

    if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
      return servers.filter(primaryFilter);
    }

    return selectedServers;
  };
}

module.exports = {
  writableServerSelector: writableServerSelector,
  readPreferenceServerSelector: readPreferenceServerSelector
};