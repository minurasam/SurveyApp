'use strict';

var _makeStateMachine;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var EventEmitter = require('events');

var ConnectionPool = require('../../cmap/connection_pool').ConnectionPool;

var CMAP_EVENT_NAMES = require('../../cmap/events').CMAP_EVENT_NAMES;

var MongoError = require('../error').MongoError;

var relayEvents = require('../utils').relayEvents;

var BSON = require('../connection/utils').retrieveBSON();

var Logger = require('../connection/logger');

var ServerDescription = require('./server_description').ServerDescription;

var compareTopologyVersion = require('./server_description').compareTopologyVersion;

var ReadPreference = require('../topologies/read_preference');

var Monitor = require('./monitor').Monitor;

var MongoNetworkError = require('../error').MongoNetworkError;

var MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;

var collationNotSupported = require('../utils').collationNotSupported;

var debugOptions = require('../connection/utils').debugOptions;

var isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError;

var isRetryableWriteError = require('../error').isRetryableWriteError;

var isNodeShuttingDownError = require('../error').isNodeShuttingDownError;

var isNetworkErrorBeforeHandshake = require('../error').isNetworkErrorBeforeHandshake;

var maxWireVersion = require('../utils').maxWireVersion;

var makeStateMachine = require('../utils').makeStateMachine;

var common = require('./common');

var ServerType = common.ServerType;

var isTransactionCommand = require('../transactions').isTransactionCommand; // Used for filtering out fields for logging


var DEBUG_FIELDS = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'servername'];
var STATE_CLOSING = common.STATE_CLOSING;
var STATE_CLOSED = common.STATE_CLOSED;
var STATE_CONNECTING = common.STATE_CONNECTING;
var STATE_CONNECTED = common.STATE_CONNECTED;
var stateTransition = makeStateMachine((_makeStateMachine = {}, _defineProperty(_makeStateMachine, STATE_CLOSED, [STATE_CLOSED, STATE_CONNECTING]), _defineProperty(_makeStateMachine, STATE_CONNECTING, [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED]), _defineProperty(_makeStateMachine, STATE_CONNECTED, [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED]), _defineProperty(_makeStateMachine, STATE_CLOSING, [STATE_CLOSING, STATE_CLOSED]), _makeStateMachine));
var kMonitor = Symbol('monitor');
/**
 *
 * @fires Server#serverHeartbeatStarted
 * @fires Server#serverHeartbeatSucceeded
 * @fires Server#serverHeartbeatFailed
 */

var Server =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Server, _EventEmitter);

  /**
   * Create a server
   *
   * @param {ServerDescription} description
   * @param {Object} options
   */
  function Server(description, options, topology) {
    var _this;

    _classCallCheck(this, Server);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Server).call(this));
    _this.s = {
      // the server description
      description: description,
      // a saved copy of the incoming options
      options: options,
      // the server logger
      logger: Logger('Server', options),
      // the bson parser
      bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),
      // the server state
      state: STATE_CLOSED,
      credentials: options.credentials,
      topology: topology
    }; // create the connection pool
    // NOTE: this used to happen in `connect`, we supported overriding pool options there

    var poolOptions = Object.assign({
      host: _this.description.host,
      port: _this.description.port,
      bson: _this.s.bson
    }, options);
    _this.s.pool = new ConnectionPool(poolOptions);
    relayEvents(_this.s.pool, _assertThisInitialized(_this), ['commandStarted', 'commandSucceeded', 'commandFailed'].concat(CMAP_EVENT_NAMES));

    _this.s.pool.on('clusterTimeReceived', function (clusterTime) {
      _this.clusterTime = clusterTime;
    }); // create the monitor


    _this[kMonitor] = new Monitor(_assertThisInitialized(_this), _this.s.options);
    relayEvents(_this[kMonitor], _assertThisInitialized(_this), ['serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', // legacy events
    'monitoring']);

    _this[kMonitor].on('resetConnectionPool', function () {
      _this.s.pool.clear();
    });

    _this[kMonitor].on('resetServer', function (error) {
      return markServerUnknown(_assertThisInitialized(_this), error);
    });

    _this[kMonitor].on('serverHeartbeatSucceeded', function (event) {
      _this.emit('descriptionReceived', new ServerDescription(_this.description.address, event.reply, {
        roundTripTime: calculateRoundTripTime(_this.description.roundTripTime, event.duration)
      }));

      if (_this.s.state === STATE_CONNECTING) {
        stateTransition(_assertThisInitialized(_this), STATE_CONNECTED);

        _this.emit('connect', _assertThisInitialized(_this));
      }
    });

    return _this;
  }

  _createClass(Server, [{
    key: "connect",

    /**
     * Initiate server connect
     */
    value: function connect() {
      if (this.s.state !== STATE_CLOSED) {
        return;
      }

      stateTransition(this, STATE_CONNECTING);
      this[kMonitor].connect();
    }
    /**
     * Destroy the server connection
     *
     * @param {object} [options] Optional settings
     * @param {Boolean} [options.force=false] Force destroy the pool
     */

  }, {
    key: "destroy",
    value: function destroy(options, callback) {
      var _this2 = this;

      if (typeof options === 'function') callback = options, options = {};
      options = Object.assign({}, {
        force: false
      }, options);

      if (this.s.state === STATE_CLOSED) {
        if (typeof callback === 'function') {
          callback();
        }

        return;
      }

      stateTransition(this, STATE_CLOSING);
      this[kMonitor].close();
      this.s.pool.close(options, function (err) {
        stateTransition(_this2, STATE_CLOSED);

        _this2.emit('closed');

        if (typeof callback === 'function') {
          callback(err);
        }
      });
    }
    /**
     * Immediately schedule monitoring of this server. If there already an attempt being made
     * this will be a no-op.
     */

  }, {
    key: "requestCheck",
    value: function requestCheck() {
      this[kMonitor].requestCheck();
    }
    /**
     * Execute a command
     *
     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
     * @param {object} cmd The command hash
     * @param {object} [options] Optional settings
     * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
     * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.
     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
     * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.
     * @param {ClientSession} [options.session] Session to use for the operation
     * @param {opResultCallback} callback A callback function
     */

  }, {
    key: "command",
    value: function command(ns, cmd, options, callback) {
      var _this3 = this;

      if (typeof options === 'function') {
        callback = options, options = {}, options = options || {};
      }

      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
        callback(new MongoError('server is closed'));
        return;
      }

      var error = basicReadValidations(this, options);

      if (error) {
        return callback(error);
      } // Clone the options


      options = Object.assign({}, options, {
        wireProtocolCommand: false
      }); // Debug log

      if (this.s.logger.isDebug()) {
        this.s.logger.debug("executing command [".concat(JSON.stringify({
          ns: ns,
          cmd: cmd,
          options: debugOptions(DEBUG_FIELDS, options)
        }), "] against ").concat(this.name));
      } // error if collation not supported


      if (collationNotSupported(this, cmd)) {
        callback(new MongoError("server ".concat(this.name, " does not support collation")));
        return;
      }

      this.s.pool.withConnection(function (err, conn, cb) {
        if (err) {
          markServerUnknown(_this3, err);
          return cb(err);
        }

        conn.command(ns, cmd, options, makeOperationHandler(_this3, conn, cmd, options, cb));
      }, callback);
    }
    /**
     * Execute a query against the server
     *
     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
     * @param {object} cmd The command document for the query
     * @param {object} options Optional settings
     * @param {function} callback
     */

  }, {
    key: "query",
    value: function query(ns, cmd, cursorState, options, callback) {
      var _this4 = this;

      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
        callback(new MongoError('server is closed'));
        return;
      }

      this.s.pool.withConnection(function (err, conn, cb) {
        if (err) {
          markServerUnknown(_this4, err);
          return cb(err);
        }

        conn.query(ns, cmd, cursorState, options, makeOperationHandler(_this4, conn, cmd, options, cb));
      }, callback);
    }
    /**
     * Execute a `getMore` against the server
     *
     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
     * @param {object} cursorState State data associated with the cursor calling this method
     * @param {object} options Optional settings
     * @param {function} callback
     */

  }, {
    key: "getMore",
    value: function getMore(ns, cursorState, batchSize, options, callback) {
      var _this5 = this;

      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
        callback(new MongoError('server is closed'));
        return;
      }

      this.s.pool.withConnection(function (err, conn, cb) {
        if (err) {
          markServerUnknown(_this5, err);
          return cb(err);
        }

        conn.getMore(ns, cursorState, batchSize, options, makeOperationHandler(_this5, conn, null, options, cb));
      }, callback);
    }
    /**
     * Execute a `killCursors` command against the server
     *
     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
     * @param {object} cursorState State data associated with the cursor calling this method
     * @param {function} callback
     */

  }, {
    key: "killCursors",
    value: function killCursors(ns, cursorState, callback) {
      var _this6 = this;

      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
        if (typeof callback === 'function') {
          callback(new MongoError('server is closed'));
        }

        return;
      }

      this.s.pool.withConnection(function (err, conn, cb) {
        if (err) {
          markServerUnknown(_this6, err);
          return cb(err);
        }

        conn.killCursors(ns, cursorState, makeOperationHandler(_this6, conn, null, undefined, cb));
      }, callback);
    }
    /**
     * Insert one or more documents
     * @method
     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
     * @param {array} ops An array of documents to insert
     * @param {boolean} [options.ordered=true] Execute in order or out of order
     * @param {object} [options.writeConcern={}] Write concern for the operation
     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
     * @param {ClientSession} [options.session] Session to use for the operation
     * @param {opResultCallback} callback A callback function
     */

  }, {
    key: "insert",
    value: function insert(ns, ops, options, callback) {
      executeWriteOperation({
        server: this,
        op: 'insert',
        ns: ns,
        ops: ops
      }, options, callback);
    }
    /**
     * Perform one or more update operations
     * @method
     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
     * @param {array} ops An array of updates
     * @param {boolean} [options.ordered=true] Execute in order or out of order
     * @param {object} [options.writeConcern={}] Write concern for the operation
     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
     * @param {ClientSession} [options.session] Session to use for the operation
     * @param {opResultCallback} callback A callback function
     */

  }, {
    key: "update",
    value: function update(ns, ops, options, callback) {
      executeWriteOperation({
        server: this,
        op: 'update',
        ns: ns,
        ops: ops
      }, options, callback);
    }
    /**
     * Perform one or more remove operations
     * @method
     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
     * @param {array} ops An array of removes
     * @param {boolean} [options.ordered=true] Execute in order or out of order
     * @param {object} [options.writeConcern={}] Write concern for the operation
     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
     * @param {ClientSession} [options.session] Session to use for the operation
     * @param {opResultCallback} callback A callback function
     */

  }, {
    key: "remove",
    value: function remove(ns, ops, options, callback) {
      executeWriteOperation({
        server: this,
        op: 'remove',
        ns: ns,
        ops: ops
      }, options, callback);
    }
  }, {
    key: "description",
    get: function get() {
      return this.s.description;
    }
  }, {
    key: "name",
    get: function get() {
      return this.s.description.address;
    }
  }, {
    key: "autoEncrypter",
    get: function get() {
      if (this.s.options && this.s.options.autoEncrypter) {
        return this.s.options.autoEncrypter;
      }

      return null;
    }
  }]);

  return Server;
}(EventEmitter);

Object.defineProperty(Server.prototype, 'clusterTime', {
  get: function get() {
    return this.s.topology.clusterTime;
  },
  set: function set(clusterTime) {
    this.s.topology.clusterTime = clusterTime;
  }
});

function supportsRetryableWrites(server) {
  return server.description.maxWireVersion >= 6 && server.description.logicalSessionTimeoutMinutes && server.description.type !== ServerType.Standalone;
}

function calculateRoundTripTime(oldRtt, duration) {
  if (oldRtt === -1) {
    return duration;
  }

  var alpha = 0.2;
  return alpha * duration + (1 - alpha) * oldRtt;
}

function basicReadValidations(server, options) {
  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {
    return new MongoError('readPreference must be an instance of ReadPreference');
  }
}

function executeWriteOperation(args, options, callback) {
  if (typeof options === 'function') callback = options, options = {};
  options = options || {}; // TODO: once we drop Node 4, use destructuring either here or in arguments.

  var server = args.server;
  var op = args.op;
  var ns = args.ns;
  var ops = Array.isArray(args.ops) ? args.ops : [args.ops];

  if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {
    callback(new MongoError('server is closed'));
    return;
  }

  if (collationNotSupported(server, options)) {
    callback(new MongoError("server ".concat(server.name, " does not support collation")));
    return;
  }

  var unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;

  if (unacknowledgedWrite || maxWireVersion(server) < 5) {
    if ((op === 'update' || op === 'remove') && ops.find(function (o) {
      return o.hint;
    })) {
      callback(new MongoError("servers < 3.4 do not support hint on ".concat(op)));
      return;
    }
  }

  server.s.pool.withConnection(function (err, conn, cb) {
    if (err) {
      markServerUnknown(server, err);
      return cb(err);
    }

    conn[op](ns, ops, options, makeOperationHandler(server, conn, ops, options, cb));
  }, callback);
}

function markServerUnknown(server, error) {
  if (error instanceof MongoNetworkError && !(error instanceof MongoNetworkTimeoutError)) {
    server[kMonitor].reset();
  }

  server.emit('descriptionReceived', new ServerDescription(server.description.address, null, {
    error: error,
    topologyVersion: error && error.topologyVersion ? error.topologyVersion : server.description.topologyVersion
  }));
}

function connectionIsStale(pool, connection) {
  return connection.generation !== pool.generation;
}

function shouldHandleStateChangeError(server, err) {
  var etv = err.topologyVersion;
  var stv = server.description.topologyVersion;
  return compareTopologyVersion(stv, etv) < 0;
}

function inActiveTransaction(session, cmd) {
  return session && session.inTransaction() && !isTransactionCommand(cmd);
}

function makeOperationHandler(server, connection, cmd, options, callback) {
  var session = options && options.session;
  return function handleOperationResult(err, result) {
    if (err && !connectionIsStale(server.s.pool, connection)) {
      if (err instanceof MongoNetworkError) {
        if (session && !session.hasEnded) {
          session.serverSession.isDirty = true;
        }

        if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {
          err.addErrorLabel('RetryableWriteError');
        }

        if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {
          markServerUnknown(server, err);
          server.s.pool.clear();
        }
      } else {
        // if pre-4.4 server, then add error label if its a retryable write error
        if (maxWireVersion(server) < 9 && isRetryableWriteError(err) && !inActiveTransaction(session, cmd)) {
          err.addErrorLabel('RetryableWriteError');
        }

        if (isSDAMUnrecoverableError(err)) {
          if (shouldHandleStateChangeError(server, err)) {
            if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {
              server.s.pool.clear();
            }

            markServerUnknown(server, err);
            process.nextTick(function () {
              return server.requestCheck();
            });
          }
        }
      }
    }

    callback(err, result);
  };
}

module.exports = {
  Server: Server
};