"use strict";
/**
 * Copyright 2018 Google LLC
 *
 * Distributed under MIT license.
 * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
 */

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GoogleToken = void 0;

var fs = require("fs");

var gaxios_1 = require("gaxios");

var jws = require("jws");

var path = require("path");

var util_1 = require("util");

var readFile = fs.readFile ? util_1.promisify(fs.readFile) : function _callee() {
  return regeneratorRuntime.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          throw new ErrorWithCode('use key rather than keyFile.', 'MISSING_CREDENTIALS');

        case 1:
        case "end":
          return _context.stop();
      }
    }
  });
};
var GOOGLE_TOKEN_URL = 'https://www.googleapis.com/oauth2/v4/token';
var GOOGLE_REVOKE_TOKEN_URL = 'https://accounts.google.com/o/oauth2/revoke?token=';

var ErrorWithCode =
/*#__PURE__*/
function (_Error) {
  _inherits(ErrorWithCode, _Error);

  function ErrorWithCode(message, code) {
    var _this;

    _classCallCheck(this, ErrorWithCode);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ErrorWithCode).call(this, message));
    _this.code = code;
    return _this;
  }

  return ErrorWithCode;
}(_wrapNativeSuper(Error));

var getPem;

var GoogleToken =
/*#__PURE__*/
function () {
  /**
   * Create a GoogleToken.
   *
   * @param options  Configuration object.
   */
  function GoogleToken(options) {
    _classCallCheck(this, GoogleToken);

    this.configure(options);
  }

  _createClass(GoogleToken, [{
    key: "hasExpired",

    /**
     * Returns whether the token has expired.
     *
     * @return true if the token has expired, false otherwise.
     */
    value: function hasExpired() {
      var now = new Date().getTime();

      if (this.rawToken && this.expiresAt) {
        return now >= this.expiresAt;
      } else {
        return true;
      }
    }
    /**
     * Returns whether the token will expire within eagerRefreshThresholdMillis
     *
     * @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.
     */

  }, {
    key: "isTokenExpiring",
    value: function isTokenExpiring() {
      var _a;

      var now = new Date().getTime();
      var eagerRefreshThresholdMillis = (_a = this.eagerRefreshThresholdMillis) !== null && _a !== void 0 ? _a : 0;

      if (this.rawToken && this.expiresAt) {
        return this.expiresAt <= now + eagerRefreshThresholdMillis;
      } else {
        return true;
      }
    }
  }, {
    key: "getToken",
    value: function getToken(callback) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (_typeof(callback) === 'object') {
        opts = callback;
        callback = undefined;
      }

      opts = Object.assign({
        forceRefresh: false
      }, opts);

      if (callback) {
        var cb = callback;
        this.getTokenAsync(opts).then(function (t) {
          return cb(null, t);
        }, callback);
        return;
      }

      return this.getTokenAsync(opts);
    }
    /**
     * Given a keyFile, extract the key and client email if available
     * @param keyFile Path to a json, pem, or p12 file that contains the key.
     * @returns an object with privateKey and clientEmail properties
     */

  }, {
    key: "getCredentials",
    value: function getCredentials(keyFile) {
      var ext, key, body, privateKey, clientEmail, _privateKey, _privateKey2;

      return regeneratorRuntime.async(function getCredentials$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              ext = path.extname(keyFile);
              _context2.t0 = ext;
              _context2.next = _context2.t0 === '.json' ? 4 : _context2.t0 === '.der' ? 13 : _context2.t0 === '.crt' ? 13 : _context2.t0 === '.pem' ? 13 : _context2.t0 === '.p12' ? 17 : _context2.t0 === '.pfx' ? 17 : 25;
              break;

            case 4:
              _context2.next = 6;
              return regeneratorRuntime.awrap(readFile(keyFile, 'utf8'));

            case 6:
              key = _context2.sent;
              body = JSON.parse(key);
              privateKey = body.private_key;
              clientEmail = body.client_email;

              if (!(!privateKey || !clientEmail)) {
                _context2.next = 12;
                break;
              }

              throw new ErrorWithCode('private_key and client_email are required.', 'MISSING_CREDENTIALS');

            case 12:
              return _context2.abrupt("return", {
                privateKey: privateKey,
                clientEmail: clientEmail
              });

            case 13:
              _context2.next = 15;
              return regeneratorRuntime.awrap(readFile(keyFile, 'utf8'));

            case 15:
              _privateKey = _context2.sent;
              return _context2.abrupt("return", {
                privateKey: _privateKey
              });

            case 17:
              if (getPem) {
                _context2.next = 21;
                break;
              }

              _context2.next = 20;
              return regeneratorRuntime.awrap(Promise.resolve().then(function () {
                return require('google-p12-pem');
              }));

            case 20:
              getPem = _context2.sent.getPem;

            case 21:
              _context2.next = 23;
              return regeneratorRuntime.awrap(getPem(keyFile));

            case 23:
              _privateKey2 = _context2.sent;
              return _context2.abrupt("return", {
                privateKey: _privateKey2
              });

            case 25:
              throw new ErrorWithCode('Unknown certificate type. Type is determined based on file extension. ' + 'Current supported extensions are *.json, *.pem, and *.p12.', 'UNKNOWN_CERTIFICATE_TYPE');

            case 26:
            case "end":
              return _context2.stop();
          }
        }
      });
    }
  }, {
    key: "getTokenAsync",
    value: function getTokenAsync(opts) {
      return regeneratorRuntime.async(function getTokenAsync$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(this.inFlightRequest && !opts.forceRefresh)) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", this.inFlightRequest);

            case 2:
              _context3.prev = 2;
              _context3.next = 5;
              return regeneratorRuntime.awrap(this.inFlightRequest = this.getTokenAsyncInner(opts));

            case 5:
              return _context3.abrupt("return", _context3.sent);

            case 6:
              _context3.prev = 6;
              this.inFlightRequest = undefined;
              return _context3.finish(6);

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[2,, 6, 9]]);
    }
  }, {
    key: "getTokenAsyncInner",
    value: function getTokenAsyncInner(opts) {
      var creds;
      return regeneratorRuntime.async(function getTokenAsyncInner$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!(this.isTokenExpiring() === false && opts.forceRefresh === false)) {
                _context4.next = 2;
                break;
              }

              return _context4.abrupt("return", Promise.resolve(this.rawToken));

            case 2:
              if (!(!this.key && !this.keyFile)) {
                _context4.next = 4;
                break;
              }

              throw new Error('No key or keyFile set.');

            case 4:
              if (!(!this.key && this.keyFile)) {
                _context4.next = 11;
                break;
              }

              _context4.next = 7;
              return regeneratorRuntime.awrap(this.getCredentials(this.keyFile));

            case 7:
              creds = _context4.sent;
              this.key = creds.privateKey;
              this.iss = creds.clientEmail || this.iss;

              if (!creds.clientEmail) {
                this.ensureEmail();
              }

            case 11:
              return _context4.abrupt("return", this.requestToken());

            case 12:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "ensureEmail",
    value: function ensureEmail() {
      if (!this.iss) {
        throw new ErrorWithCode('email is required.', 'MISSING_CREDENTIALS');
      }
    }
  }, {
    key: "revokeToken",
    value: function revokeToken(callback) {
      if (callback) {
        this.revokeTokenAsync().then(function () {
          return callback();
        }, callback);
        return;
      }

      return this.revokeTokenAsync();
    }
  }, {
    key: "revokeTokenAsync",
    value: function revokeTokenAsync() {
      var url;
      return regeneratorRuntime.async(function revokeTokenAsync$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (this.accessToken) {
                _context5.next = 2;
                break;
              }

              throw new Error('No token to revoke.');

            case 2:
              url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;
              _context5.next = 5;
              return regeneratorRuntime.awrap(gaxios_1.request({
                url: url
              }));

            case 5:
              this.configure({
                email: this.iss,
                sub: this.sub,
                key: this.key,
                keyFile: this.keyFile,
                scope: this.scope,
                additionalClaims: this.additionalClaims
              });

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
    /**
     * Configure the GoogleToken for re-use.
     * @param  {object} options Configuration object.
     */

  }, {
    key: "configure",
    value: function configure() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.keyFile = options.keyFile;
      this.key = options.key;
      this.rawToken = undefined;
      this.iss = options.email || options.iss;
      this.sub = options.sub;
      this.additionalClaims = options.additionalClaims;

      if (_typeof(options.scope) === 'object') {
        this.scope = options.scope.join(' ');
      } else {
        this.scope = options.scope;
      }

      this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;
    }
    /**
     * Request the token from Google.
     */

  }, {
    key: "requestToken",
    value: function requestToken() {
      var iat, additionalClaims, payload, signedJWT, r, body, desc;
      return regeneratorRuntime.async(function requestToken$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              iat = Math.floor(new Date().getTime() / 1000);
              additionalClaims = this.additionalClaims || {};
              payload = Object.assign({
                iss: this.iss,
                scope: this.scope,
                aud: GOOGLE_TOKEN_URL,
                exp: iat + 3600,
                iat: iat,
                sub: this.sub
              }, additionalClaims);
              signedJWT = jws.sign({
                header: {
                  alg: 'RS256'
                },
                payload: payload,
                secret: this.key
              });
              _context6.prev = 4;
              _context6.next = 7;
              return regeneratorRuntime.awrap(gaxios_1.request({
                method: 'POST',
                url: GOOGLE_TOKEN_URL,
                data: {
                  grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                  assertion: signedJWT
                },
                headers: {
                  'Content-Type': 'application/x-www-form-urlencoded'
                },
                responseType: 'json'
              }));

            case 7:
              r = _context6.sent;
              this.rawToken = r.data;
              this.expiresAt = r.data.expires_in === null || r.data.expires_in === undefined ? undefined : (iat + r.data.expires_in) * 1000;
              return _context6.abrupt("return", this.rawToken);

            case 13:
              _context6.prev = 13;
              _context6.t0 = _context6["catch"](4);
              this.rawToken = undefined;
              this.tokenExpires = undefined;
              body = _context6.t0.response && _context6.t0.response.data ? _context6.t0.response.data : {};

              if (body.error) {
                desc = body.error_description ? ": ".concat(body.error_description) : '';
                _context6.t0.message = "".concat(body.error).concat(desc);
              }

              throw _context6.t0;

            case 20:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this, [[4, 13]]);
    }
  }, {
    key: "accessToken",
    get: function get() {
      return this.rawToken ? this.rawToken.access_token : undefined;
    }
  }, {
    key: "idToken",
    get: function get() {
      return this.rawToken ? this.rawToken.id_token : undefined;
    }
  }, {
    key: "tokenType",
    get: function get() {
      return this.rawToken ? this.rawToken.token_type : undefined;
    }
  }, {
    key: "refreshToken",
    get: function get() {
      return this.rawToken ? this.rawToken.refresh_token : undefined;
    }
  }]);

  return GoogleToken;
}();

exports.GoogleToken = GoogleToken;