#!/usr/bin/env node
'use strict';

var fs = require('fs');

var path = require('path');

var mimeScore = require('mime-score');

var db = require('mime-db');

var chalk = require('chalk');

var STANDARD_FACET_SCORE = 900;
var byExtension = {}; // Clear out any conflict extensions in mime-db

var _loop = function _loop(type) {
  var entry = db[type];
  entry.type = type;
  if (!entry.extensions) return "continue";
  entry.extensions.forEach(function (ext) {
    if (ext in byExtension) {
      var e0 = entry;
      var e1 = byExtension[ext];
      e0.pri = mimeScore(e0.type, e0.source);
      e1.pri = mimeScore(e1.type, e1.source);
      var drop = e0.pri < e1.pri ? e0 : e1;
      var keep = e0.pri >= e1.pri ? e0 : e1;
      drop.extensions = drop.extensions.filter(function (e) {
        return e !== ext;
      });
      console.log("".concat(ext, ": Keeping ").concat(chalk.green(keep.type), " (").concat(keep.pri, "), dropping ").concat(chalk.red(drop.type), " (").concat(drop.pri, ")"));
    }

    byExtension[ext] = entry;
  });
};

for (var type in db) {
  var _ret = _loop(type);

  if (_ret === "continue") continue;
}

function writeTypesFile(types, path) {
  fs.writeFileSync(path, JSON.stringify(types));
} // Segregate into standard and non-standard types based on facet per
// https://tools.ietf.org/html/rfc6838#section-3.1


var types = {};
Object.keys(db).sort().forEach(function (k) {
  var entry = db[k];
  types[entry.type] = entry.extensions;
});
writeTypesFile(types, path.join(__dirname, '..', 'types.json'));