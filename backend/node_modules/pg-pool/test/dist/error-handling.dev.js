'use strict';

var net = require('net');

var co = require('co');

var expect = require('expect.js');

var describe = require('mocha').describe;

var it = require('mocha').it;

var Pool = require('../');

describe('pool error handling', function () {
  it('Should complete these queries without dying', function (done) {
    var pool = new Pool();
    var errors = 0;
    var shouldGet = 0;

    function runErrorQuery() {
      shouldGet++;
      return new Promise(function (resolve, reject) {
        pool.query("SELECT 'asd'+1 ").then(function (res) {
          reject(res); // this should always error
        })["catch"](function (err) {
          errors++;
          resolve(err);
        });
      });
    }

    var ps = [];

    for (var i = 0; i < 5; i++) {
      ps.push(runErrorQuery());
    }

    Promise.all(ps).then(function () {
      expect(shouldGet).to.eql(errors);
      pool.end(done);
    });
  });
  describe('calling release more than once', function () {
    it('should throw each time', co.wrap(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee() {
      var pool, client;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              pool = new Pool();
              _context.next = 3;
              return pool.connect();

            case 3:
              client = _context.sent;
              client.release();
              expect(function () {
                return client.release();
              }).to.throwError();
              expect(function () {
                return client.release();
              }).to.throwError();
              _context.next = 9;
              return pool.end();

            case 9:
              return _context.abrupt("return", _context.sent);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it('should throw each time with callbacks', function (done) {
      var pool = new Pool();
      pool.connect(function (err, client, clientDone) {
        expect(err).not.to.be.an(Error);
        clientDone();
        expect(function () {
          return clientDone();
        }).to.throwError();
        expect(function () {
          return clientDone();
        }).to.throwError();
        pool.end(done);
      });
    });
  });
  describe('calling connect after end', function () {
    it('should return an error',
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee2() {
      var pool, res, wait;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              pool = new Pool();
              _context2.next = 3;
              return pool.query('SELECT $1::text as name', ['hi']);

            case 3:
              res = _context2.sent;
              expect(res.rows[0].name).to.equal('hi');
              wait = pool.end();
              pool.query('select now()');
              _context2.next = 9;
              return wait;

            case 9:
              expect(function () {
                return pool.query('select now()');
              }).to.reject();

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
  });
  describe('using an ended pool', function () {
    it('rejects all additional promises', function (done) {
      var pool = new Pool();
      var promises = [];
      pool.end().then(function () {
        var squash = function squash(promise) {
          return promise["catch"](function (e) {
            return 'okay!';
          });
        };

        promises.push(squash(pool.connect()));
        promises.push(squash(pool.query('SELECT NOW()')));
        promises.push(squash(pool.end()));
        Promise.all(promises).then(function (res) {
          expect(res).to.eql(['okay!', 'okay!', 'okay!']);
          done();
        });
      });
    });
    it('returns an error on all additional callbacks', function (done) {
      var pool = new Pool();
      pool.end(function () {
        pool.query('SELECT *', function (err) {
          expect(err).to.be.an(Error);
          pool.connect(function (err) {
            expect(err).to.be.an(Error);
            pool.end(function (err) {
              expect(err).to.be.an(Error);
              done();
            });
          });
        });
      });
    });
  });
  describe('error from idle client', function () {
    it('removes client from pool', co.wrap(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee3() {
      var pool, client;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              pool = new Pool();
              _context3.next = 3;
              return pool.connect();

            case 3:
              client = _context3.sent;
              expect(pool.totalCount).to.equal(1);
              expect(pool.waitingCount).to.equal(0);
              expect(pool.idleCount).to.equal(0);
              client.release();
              _context3.next = 10;
              return new Promise(function (resolve, reject) {
                process.nextTick(function () {
                  var poolError;
                  pool.once('error', function (err) {
                    poolError = err;
                  });
                  var clientError;
                  client.once('error', function (err) {
                    clientError = err;
                  });
                  client.emit('error', new Error('expected'));
                  expect(clientError.message).to.equal('expected');
                  expect(poolError.message).to.equal('expected');
                  expect(pool.idleCount).to.equal(0);
                  expect(pool.totalCount).to.equal(0);
                  pool.end().then(resolve, reject);
                });
              });

            case 10:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
  });
  describe('error from in-use client', function () {
    it('keeps the client in the pool', co.wrap(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee4() {
      var pool, client;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              pool = new Pool();
              _context4.next = 3;
              return pool.connect();

            case 3:
              client = _context4.sent;
              expect(pool.totalCount).to.equal(1);
              expect(pool.waitingCount).to.equal(0);
              expect(pool.idleCount).to.equal(0);
              _context4.next = 9;
              return new Promise(function (resolve, reject) {
                process.nextTick(function () {
                  var poolError;
                  pool.once('error', function (err) {
                    poolError = err;
                  });
                  var clientError;
                  client.once('error', function (err) {
                    clientError = err;
                  });
                  client.emit('error', new Error('expected'));
                  expect(clientError.message).to.equal('expected');
                  expect(poolError).not.to.be.ok();
                  expect(pool.idleCount).to.equal(0);
                  expect(pool.totalCount).to.equal(1);
                  client.release();
                  pool.end().then(resolve, reject);
                });
              });

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
  });
  describe('passing a function to pool.query', function () {
    it('calls back with error', function (done) {
      var pool = new Pool();
      console.log('passing fn to query');
      pool.query(function (err) {
        expect(err).to.be.an(Error);
        pool.end(done);
      });
    });
  });
  describe('pool with lots of errors', function () {
    it('continues to work and provide new clients', co.wrap(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee5() {
      var pool, errors, i, res;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              pool = new Pool({
                max: 1
              });
              errors = [];
              i = 0;

            case 3:
              if (!(i < 20)) {
                _context5.next = 15;
                break;
              }

              _context5.prev = 4;
              _context5.next = 7;
              return pool.query('invalid sql');

            case 7:
              _context5.next = 12;
              break;

            case 9:
              _context5.prev = 9;
              _context5.t0 = _context5["catch"](4);
              errors.push(_context5.t0);

            case 12:
              i++;
              _context5.next = 3;
              break;

            case 15:
              expect(errors).to.have.length(20);
              expect(pool.idleCount).to.equal(0);
              expect(pool.query).to.be.a(Function);
              _context5.next = 20;
              return pool.query('SELECT $1::text as name', ['brianc']);

            case 20:
              res = _context5.sent;
              expect(res.rows).to.have.length(1);
              expect(res.rows[0].name).to.equal('brianc');
              return _context5.abrupt("return", pool.end());

            case 24:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, null, [[4, 9]]);
    })));
  });
  it('should continue with queued items after a connection failure', function (done) {
    var closeServer = net.createServer(function (socket) {
      socket.destroy();
    }).unref();
    closeServer.listen(function () {
      var pool = new Pool({
        max: 1,
        port: closeServer.address().port,
        host: 'localhost'
      });
      pool.connect(function (err) {
        expect(err).to.be.an(Error);

        if (err.code) {
          expect(err.code).to.be('ECONNRESET');
        }
      });
      pool.connect(function (err) {
        expect(err).to.be.an(Error);

        if (err.code) {
          expect(err.code).to.be('ECONNRESET');
        }

        closeServer.close(function () {
          pool.end(done);
        });
      });
    });
  });
  it('handles post-checkout client failures in pool.query', function (done) {
    var pool = new Pool({
      max: 1
    });
    pool.on('error', function () {// We double close the connection in this test, prevent exception caused by that
    });
    pool.query('SELECT pg_sleep(5)', [], function (err) {
      expect(err).to.be.an(Error);
      done();
    });
    setTimeout(function () {
      pool._clients[0].end();
    }, 1000);
  });
});