"use strict";

var expect = require('expect.js');

var co = require('co');

var _ = require('lodash');

var describe = require('mocha').describe;

var it = require('mocha').it;

var Pool = require('../');

describe('maxUses', function () {
  it('can create a single client and use it once', co.wrap(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee() {
    var pool, client, res;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            pool = new Pool({
              maxUses: 2
            });
            expect(pool.waitingCount).to.equal(0);
            _context.next = 4;
            return pool.connect();

          case 4:
            client = _context.sent;
            _context.next = 7;
            return client.query('SELECT $1::text as name', ['hi']);

          case 7:
            res = _context.sent;
            expect(res.rows[0].name).to.equal('hi');
            client.release();
            pool.end();

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));
  it('getting a connection a second time returns the same connection and releasing it also closes it', co.wrap(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee2() {
    var pool, client, client2;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            pool = new Pool({
              maxUses: 2
            });
            expect(pool.waitingCount).to.equal(0);
            _context2.next = 4;
            return pool.connect();

          case 4:
            client = _context2.sent;
            client.release();
            _context2.next = 8;
            return pool.connect();

          case 8:
            client2 = _context2.sent;
            expect(client).to.equal(client2);
            expect(client2._ending).to.equal(false);
            client2.release();
            expect(client2._ending).to.equal(true);
            _context2.next = 15;
            return pool.end();

          case 15:
            return _context2.abrupt("return", _context2.sent);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  })));
  it('getting a connection a third time returns a new connection', co.wrap(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee3() {
    var pool, client, client2, client3;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            pool = new Pool({
              maxUses: 2
            });
            expect(pool.waitingCount).to.equal(0);
            _context3.next = 4;
            return pool.connect();

          case 4:
            client = _context3.sent;
            client.release();
            _context3.next = 8;
            return pool.connect();

          case 8:
            client2 = _context3.sent;
            expect(client).to.equal(client2);
            client2.release();
            _context3.next = 13;
            return pool.connect();

          case 13:
            client3 = _context3.sent;
            expect(client3).not.to.equal(client2);
            client3.release();
            _context3.next = 18;
            return pool.end();

          case 18:
            return _context3.abrupt("return", _context3.sent);

          case 19:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })));
  it('getting a connection from a pending request gets a fresh client when the released candidate is expended', co.wrap(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee4() {
    var pool, client1, client3Promise;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            pool = new Pool({
              max: 1,
              maxUses: 2
            });
            expect(pool.waitingCount).to.equal(0);
            _context4.next = 4;
            return pool.connect();

          case 4:
            client1 = _context4.sent;
            pool.connect().then(function (client2) {
              expect(client2).to.equal(client1);
              expect(pool.waitingCount).to.equal(1); // Releasing the client this time should also expend it since maxUses is 2, causing client3 to be a fresh client

              client2.release();
            });
            client3Promise = pool.connect().then(function (client3) {
              // client3 should be a fresh client since client2's release caused the first client to be expended
              expect(pool.waitingCount).to.equal(0);
              expect(client3).not.to.equal(client1);
              return client3.release();
            }); // There should be two pending requests since we have 3 connect requests but a max size of 1

            expect(pool.waitingCount).to.equal(2); // Releasing the client should not yet expend it since maxUses is 2

            client1.release();
            _context4.next = 11;
            return client3Promise;

          case 11:
            _context4.next = 13;
            return pool.end();

          case 13:
            return _context4.abrupt("return", _context4.sent);

          case 14:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  })));
  it('logs when removing an expended client', co.wrap(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee5() {
    var messages, log, pool, client;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            messages = [];

            log = function log(msg) {
              messages.push(msg);
            };

            pool = new Pool({
              maxUses: 1,
              log: log
            });
            _context5.next = 5;
            return pool.connect();

          case 5:
            client = _context5.sent;
            client.release();
            expect(messages).to.contain('remove expended client');
            _context5.next = 10;
            return pool.end();

          case 10:
            return _context5.abrupt("return", _context5.sent);

          case 11:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  })));
});