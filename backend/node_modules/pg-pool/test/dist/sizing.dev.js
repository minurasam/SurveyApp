"use strict";

var expect = require('expect.js');

var co = require('co');

var _ = require('lodash');

var describe = require('mocha').describe;

var it = require('mocha').it;

var Pool = require('../');

describe('pool size of 1', function () {
  it('can create a single client and use it once', co.wrap(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee() {
    var pool, client, res;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            pool = new Pool({
              max: 1
            });
            expect(pool.waitingCount).to.equal(0);
            _context.next = 4;
            return pool.connect();

          case 4:
            client = _context.sent;
            _context.next = 7;
            return client.query('SELECT $1::text as name', ['hi']);

          case 7:
            res = _context.sent;
            expect(res.rows[0].name).to.equal('hi');
            client.release();
            pool.end();

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));
  it('can create a single client and use it multiple times', co.wrap(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee2() {
    var pool, client, wait, client2;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            pool = new Pool({
              max: 1
            });
            expect(pool.waitingCount).to.equal(0);
            _context2.next = 4;
            return pool.connect();

          case 4:
            client = _context2.sent;
            wait = pool.connect();
            expect(pool.waitingCount).to.equal(1);
            client.release();
            _context2.next = 10;
            return wait;

          case 10:
            client2 = _context2.sent;
            expect(client).to.equal(client2);
            client2.release();
            _context2.next = 15;
            return pool.end();

          case 15:
            return _context2.abrupt("return", _context2.sent);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  })));
  it('can only send 1 query at a time', co.wrap(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee3() {
    var pool, versionResult, version, queryColumn, queryText, queries, results, counts;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            pool = new Pool({
              max: 1
            }); // the query text column name changed in PostgreSQL 9.2

            _context3.next = 3;
            return pool.query('SHOW server_version_num');

          case 3:
            versionResult = _context3.sent;
            version = parseInt(versionResult.rows[0].server_version_num, 10);
            queryColumn = version < 90200 ? 'current_query' : 'query';
            queryText = 'SELECT COUNT(*) as counts FROM pg_stat_activity WHERE ' + queryColumn + ' = $1';
            queries = _.times(20, function () {
              return pool.query(queryText, [queryText]);
            });
            _context3.next = 10;
            return Promise.all(queries);

          case 10:
            results = _context3.sent;
            counts = results.map(function (res) {
              return parseInt(res.rows[0].counts, 10);
            });
            expect(counts).to.eql(_.times(20, function (i) {
              return 1;
            }));
            _context3.next = 15;
            return pool.end();

          case 15:
            return _context3.abrupt("return", _context3.sent);

          case 16:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })));
});