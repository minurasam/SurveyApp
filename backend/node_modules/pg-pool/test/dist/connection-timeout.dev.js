'use strict';

var _this = void 0;

var net = require('net');

var co = require('co');

var expect = require('expect.js');

var describe = require('mocha').describe;

var it = require('mocha').it;

var before = require('mocha').before;

var after = require('mocha').after;

var Pool = require('../');

describe('connection timeout', function () {
  var connectionFailure = new Error('Temporary connection failure');
  before(function (done) {
    _this.server = net.createServer(function (socket) {
      socket.on('data', function () {// discard any buffered data or the server wont terminate
      });
    });

    _this.server.listen(function () {
      _this.port = _this.server.address().port;
      done();
    });
  });
  after(function (done) {
    _this.server.close(done);
  });
  it('should callback with an error if timeout is passed', function (done) {
    var pool = new Pool({
      connectionTimeoutMillis: 10,
      port: _this.port,
      host: 'localhost'
    });
    pool.connect(function (err, client, release) {
      expect(err).to.be.an(Error);
      expect(err.message).to.contain('timeout');
      expect(client).to.equal(undefined);
      expect(pool.idleCount).to.equal(0);
      done();
    });
  });
  it('should reject promise with an error if timeout is passed', function (done) {
    var pool = new Pool({
      connectionTimeoutMillis: 10,
      port: _this.port,
      host: 'localhost'
    });
    pool.connect()["catch"](function (err) {
      expect(err).to.be.an(Error);
      expect(err.message).to.contain('timeout');
      expect(pool.idleCount).to.equal(0);
      done();
    });
  });
  it('should handle multiple timeouts', co.wrap(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee() {
    var errors, pool, i;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            errors = [];
            pool = new Pool({
              connectionTimeoutMillis: 1,
              port: this.port,
              host: 'localhost'
            });
            i = 0;

          case 3:
            if (!(i < 15)) {
              _context.next = 15;
              break;
            }

            _context.prev = 4;
            _context.next = 7;
            return pool.connect();

          case 7:
            _context.next = 12;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](4);
            errors.push(_context.t0);

          case 12:
            i++;
            _context.next = 3;
            break;

          case 15:
            expect(errors).to.have.length(15);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[4, 9]]);
  }).bind(_this)));
  it('should timeout on checkout of used connection', function (done) {
    var pool = new Pool({
      connectionTimeoutMillis: 100,
      max: 1
    });
    pool.connect(function (err, client, release) {
      expect(err).to.be(undefined);
      expect(client).to.not.be(undefined);
      pool.connect(function (err, client) {
        expect(err).to.be.an(Error);
        expect(client).to.be(undefined);
        release();
        pool.end(done);
      });
    });
  });
  it('should not break further pending checkouts on a timeout', function (done) {
    var pool = new Pool({
      connectionTimeoutMillis: 200,
      max: 1
    });
    pool.connect(function (err, client, releaseOuter) {
      expect(err).to.be(undefined);
      pool.connect(function (err, client) {
        expect(err).to.be.an(Error);
        expect(client).to.be(undefined);
        releaseOuter();
      });
      setTimeout(function () {
        pool.connect(function (err, client, releaseInner) {
          expect(err).to.be(undefined);
          expect(client).to.not.be(undefined);
          releaseInner();
          pool.end(done);
        });
      }, 100);
    });
  });
  it('should timeout on query if all clients are busy', function (done) {
    var pool = new Pool({
      connectionTimeoutMillis: 100,
      max: 1
    });
    pool.connect(function (err, client, release) {
      expect(err).to.be(undefined);
      expect(client).to.not.be(undefined);
      pool.query('select now()', function (err, result) {
        expect(err).to.be.an(Error);
        expect(result).to.be(undefined);
        release();
        pool.end(done);
      });
    });
  });
  it('should recover from timeout errors', function (done) {
    var pool = new Pool({
      connectionTimeoutMillis: 100,
      max: 1
    });
    pool.connect(function (err, client, release) {
      expect(err).to.be(undefined);
      expect(client).to.not.be(undefined);
      pool.query('select now()', function (err, result) {
        expect(err).to.be.an(Error);
        expect(result).to.be(undefined);
        release();
        pool.query('select $1::text as name', ['brianc'], function (err, res) {
          expect(err).to.be(undefined);
          expect(res.rows).to.have.length(1);
          pool.end(done);
        });
      });
    });
  });
  it('continues processing after a connection failure', function (done) {
    var Client = require('pg').Client;

    var orgConnect = Client.prototype.connect;
    var called = false;

    Client.prototype.connect = function (cb) {
      // Simulate a failure on first call
      if (!called) {
        called = true;
        return setTimeout(function () {
          cb(connectionFailure);
        }, 100);
      } // And pass-through the second call


      orgConnect.call(this, cb);
    };

    var pool = new Pool({
      Client: Client,
      connectionTimeoutMillis: 1000,
      max: 1
    });
    pool.connect(function (err, client, release) {
      expect(err).to.be(connectionFailure);
      pool.query('select $1::text as name', ['brianc'], function (err, res) {
        expect(err).to.be(undefined);
        expect(res.rows).to.have.length(1);
        pool.end(done);
      });
    });
  });
  it('releases newly connected clients if the queued already timed out', function (done) {
    var Client = require('pg').Client;

    var orgConnect = Client.prototype.connect;
    var connection = 0;

    Client.prototype.connect = function (cb) {
      var _this2 = this;

      // Simulate a failure on first call
      if (connection === 0) {
        connection++;
        return setTimeout(function () {
          cb(connectionFailure);
        }, 300);
      } // And second connect taking > connection timeout


      if (connection === 1) {
        connection++;
        return setTimeout(function () {
          orgConnect.call(_this2, cb);
        }, 1000);
      }

      orgConnect.call(this, cb);
    };

    var pool = new Pool({
      Client: Client,
      connectionTimeoutMillis: 1000,
      max: 1
    }); // Direct connect

    pool.connect(function (err, client, release) {
      expect(err).to.be(connectionFailure);
    }); // Queued

    var called = 0;
    pool.connect(function (err, client, release) {
      // Verify the callback is only called once
      expect(called++).to.be(0);
      expect(err).to.be.an(Error);
      pool.query('select $1::text as name', ['brianc'], function (err, res) {
        expect(err).to.be(undefined);
        expect(res.rows).to.have.length(1);
        pool.end(done);
      });
    });
  });
});