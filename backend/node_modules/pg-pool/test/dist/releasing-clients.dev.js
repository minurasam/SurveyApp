"use strict";

var Pool = require('../');

var expect = require('expect.js');

var net = require('net');

describe('releasing clients', function () {
  it('removes a client which cannot be queried', function _callee() {
    var pool, client, err, _ref, rows;

    return regeneratorRuntime.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // make a pool w/ only 1 client
            pool = new Pool({
              max: 1
            });
            expect(pool.totalCount).to.eql(0);
            _context.next = 4;
            return regeneratorRuntime.awrap(pool.connect());

          case 4:
            client = _context.sent;
            expect(pool.totalCount).to.eql(1);
            expect(pool.idleCount).to.eql(0); // reach into the client and sever its connection

            client.connection.end(); // wait for the client to error out

            _context.next = 10;
            return regeneratorRuntime.awrap(new Promise(function (resolve) {
              return client.once('error', resolve);
            }));

          case 10:
            err = _context.sent;
            expect(err).to.be.ok();
            expect(pool.totalCount).to.eql(1);
            expect(pool.idleCount).to.eql(0); // try to return it to the pool - this removes it because its broken

            client.release();
            expect(pool.totalCount).to.eql(0);
            expect(pool.idleCount).to.eql(0); // make sure pool still works

            _context.next = 19;
            return regeneratorRuntime.awrap(pool.query('SELECT NOW()'));

          case 19:
            _ref = _context.sent;
            rows = _ref.rows;
            expect(rows).to.have.length(1);
            _context.next = 24;
            return regeneratorRuntime.awrap(pool.end());

          case 24:
          case "end":
            return _context.stop();
        }
      }
    });
  });
  it('removes a client which is ending', function _callee2() {
    var pool, client, _ref2, rows;

    return regeneratorRuntime.async(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            // make a pool w/ only 1 client
            pool = new Pool({
              max: 1
            });
            expect(pool.totalCount).to.eql(0);
            _context2.next = 4;
            return regeneratorRuntime.awrap(pool.connect());

          case 4:
            client = _context2.sent;
            expect(pool.totalCount).to.eql(1);
            expect(pool.idleCount).to.eql(0); // end the client gracefully (but you shouldn't do this with pooled clients)

            client.end(); // try to return it to the pool

            client.release();
            expect(pool.totalCount).to.eql(0);
            expect(pool.idleCount).to.eql(0); // make sure pool still works

            _context2.next = 13;
            return regeneratorRuntime.awrap(pool.query('SELECT NOW()'));

          case 13:
            _ref2 = _context2.sent;
            rows = _ref2.rows;
            expect(rows).to.have.length(1);
            _context2.next = 18;
            return regeneratorRuntime.awrap(pool.end());

          case 18:
          case "end":
            return _context2.stop();
        }
      }
    });
  });
});