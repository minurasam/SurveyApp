'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventEmitter = require('events').EventEmitter;

var NOOP = function NOOP() {};

var removeWhere = function removeWhere(list, predicate) {
  var i = list.findIndex(predicate);
  return i === -1 ? undefined : list.splice(i, 1)[0];
};

var IdleItem = function IdleItem(client, idleListener, timeoutId) {
  _classCallCheck(this, IdleItem);

  this.client = client;
  this.idleListener = idleListener;
  this.timeoutId = timeoutId;
};

var PendingItem = function PendingItem(callback) {
  _classCallCheck(this, PendingItem);

  this.callback = callback;
};

function throwOnDoubleRelease() {
  throw new Error('Release called on client which has already been released to the pool.');
}

function promisify(Promise, callback) {
  if (callback) {
    return {
      callback: callback,
      result: undefined
    };
  }

  var rej;
  var res;

  var cb = function cb(err, client) {
    err ? rej(err) : res(client);
  };

  var result = new Promise(function (resolve, reject) {
    res = resolve;
    rej = reject;
  });
  return {
    callback: cb,
    result: result
  };
}

function makeIdleListener(pool, client) {
  return function idleListener(err) {
    err.client = client;
    client.removeListener('error', idleListener);
    client.on('error', function () {
      pool.log('additional client error after disconnection due to error', err);
    });

    pool._remove(client); // TODO - document that once the pool emits an error
    // the client has already been closed & purged and is unusable


    pool.emit('error', err, client);
  };
}

var Pool =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Pool, _EventEmitter);

  function Pool(options, Client) {
    var _this;

    _classCallCheck(this, Pool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Pool).call(this));
    _this.options = Object.assign({}, options);

    if (options != null && 'password' in options) {
      // "hiding" the password so it doesn't show up in stack traces
      // or if the client is console.logged
      Object.defineProperty(_this.options, 'password', {
        configurable: true,
        enumerable: false,
        writable: true,
        value: options.password
      });
    }

    if (options != null && options.ssl && options.ssl.key) {
      // "hiding" the ssl->key so it doesn't show up in stack traces
      // or if the client is console.logged
      Object.defineProperty(_this.options.ssl, 'key', {
        enumerable: false
      });
    }

    _this.options.max = _this.options.max || _this.options.poolSize || 10;
    _this.options.maxUses = _this.options.maxUses || Infinity;

    _this.log = _this.options.log || function () {};

    _this.Client = _this.options.Client || Client || require('pg').Client;
    _this.Promise = _this.options.Promise || global.Promise;

    if (typeof _this.options.idleTimeoutMillis === 'undefined') {
      _this.options.idleTimeoutMillis = 10000;
    }

    _this._clients = [];
    _this._idle = [];
    _this._pendingQueue = [];
    _this._endCallback = undefined;
    _this.ending = false;
    _this.ended = false;
    return _this;
  }

  _createClass(Pool, [{
    key: "_isFull",
    value: function _isFull() {
      return this._clients.length >= this.options.max;
    }
  }, {
    key: "_pulseQueue",
    value: function _pulseQueue() {
      var _this2 = this;

      this.log('pulse queue');

      if (this.ended) {
        this.log('pulse queue ended');
        return;
      }

      if (this.ending) {
        this.log('pulse queue on ending');

        if (this._idle.length) {
          this._idle.slice().map(function (item) {
            _this2._remove(item.client);
          });
        }

        if (!this._clients.length) {
          this.ended = true;

          this._endCallback();
        }

        return;
      } // if we don't have any waiting, do nothing


      if (!this._pendingQueue.length) {
        this.log('no queued requests');
        return;
      } // if we don't have any idle clients and we have no more room do nothing


      if (!this._idle.length && this._isFull()) {
        return;
      }

      var pendingItem = this._pendingQueue.shift();

      if (this._idle.length) {
        var idleItem = this._idle.pop();

        clearTimeout(idleItem.timeoutId);
        var client = idleItem.client;
        var idleListener = idleItem.idleListener;
        return this._acquireClient(client, pendingItem, idleListener, false);
      }

      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }

      throw new Error('unexpected condition');
    }
  }, {
    key: "_remove",
    value: function _remove(client) {
      var removed = removeWhere(this._idle, function (item) {
        return item.client === client;
      });

      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }

      this._clients = this._clients.filter(function (c) {
        return c !== client;
      });
      client.end();
      this.emit('remove', client);
    }
  }, {
    key: "connect",
    value: function connect(cb) {
      var _this3 = this;

      if (this.ending) {
        var err = new Error('Cannot use a pool after calling end on the pool');
        return cb ? cb(err) : this.Promise.reject(err);
      }

      var response = promisify(this.Promise, cb);
      var result = response.result; // if we don't have to connect a new client, don't do so

      if (this._clients.length >= this.options.max || this._idle.length) {
        // if we have idle clients schedule a pulse immediately
        if (this._idle.length) {
          process.nextTick(function () {
            return _this3._pulseQueue();
          });
        }

        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));

          return result;
        }

        var queueCallback = function queueCallback(err, res, done) {
          clearTimeout(tid);
          response.callback(err, res, done);
        };

        var pendingItem = new PendingItem(queueCallback); // set connection timeout on checking out an existing client

        var tid = setTimeout(function () {
          // remove the callback from pending waiters because
          // we're going to call it with a timeout error
          removeWhere(_this3._pendingQueue, function (i) {
            return i.callback === queueCallback;
          });
          pendingItem.timedOut = true;
          response.callback(new Error('timeout exceeded when trying to connect'));
        }, this.options.connectionTimeoutMillis);

        this._pendingQueue.push(pendingItem);

        return result;
      }

      this.newClient(new PendingItem(response.callback));
      return result;
    }
  }, {
    key: "newClient",
    value: function newClient(pendingItem) {
      var _this4 = this;

      var client = new this.Client(this.options);

      this._clients.push(client);

      var idleListener = makeIdleListener(this, client);
      this.log('checking client timeout'); // connection timeout logic

      var tid;
      var timeoutHit = false;

      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(function () {
          _this4.log('ending client due to timeout');

          timeoutHit = true; // force kill the node driver, and let libpq do its teardown

          client.connection ? client.connection.stream.destroy() : client.end();
        }, this.options.connectionTimeoutMillis);
      }

      this.log('connecting new client');
      client.connect(function (err) {
        if (tid) {
          clearTimeout(tid);
        }

        client.on('error', idleListener);

        if (err) {
          _this4.log('client failed to connect', err); // remove the dead client from our list of clients


          _this4._clients = _this4._clients.filter(function (c) {
            return c !== client;
          });

          if (timeoutHit) {
            err.message = 'Connection terminated due to connection timeout';
          } // this client won’t be released, so move on immediately


          _this4._pulseQueue();

          if (!pendingItem.timedOut) {
            pendingItem.callback(err, undefined, NOOP);
          }
        } else {
          _this4.log('new client connected');

          return _this4._acquireClient(client, pendingItem, idleListener, true);
        }
      });
    } // acquire a client for a pending work item

  }, {
    key: "_acquireClient",
    value: function _acquireClient(client, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit('connect', client);
      }

      this.emit('acquire', client);
      client.release = this._releaseOnce(client, idleListener);
      client.removeListener('error', idleListener);

      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client, function (err) {
            if (err) {
              client.release(err);
              return pendingItem.callback(err, undefined, NOOP);
            }

            pendingItem.callback(undefined, client, client.release);
          });
        } else {
          pendingItem.callback(undefined, client, client.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client, client.release);
        } else {
          client.release();
        }
      }
    } // returns a function that wraps _release and throws if called more than once

  }, {
    key: "_releaseOnce",
    value: function _releaseOnce(client, idleListener) {
      var _this5 = this;

      var released = false;
      return function (err) {
        if (released) {
          throwOnDoubleRelease();
        }

        released = true;

        _this5._release(client, idleListener, err);
      };
    } // release a client back to the poll, include an error
    // to remove it from the pool

  }, {
    key: "_release",
    value: function _release(client, idleListener, err) {
      var _this6 = this;

      client.on('error', idleListener);
      client._poolUseCount = (client._poolUseCount || 0) + 1; // TODO(bmc): expose a proper, public interface _queryable and _ending

      if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
        if (client._poolUseCount >= this.options.maxUses) {
          this.log('remove expended client');
        }

        this._remove(client);

        this._pulseQueue();

        return;
      } // idle timeout


      var tid;

      if (this.options.idleTimeoutMillis) {
        tid = setTimeout(function () {
          _this6.log('remove idle client');

          _this6._remove(client);
        }, this.options.idleTimeoutMillis);
      }

      this._idle.push(new IdleItem(client, idleListener, tid));

      this._pulseQueue();
    }
  }, {
    key: "query",
    value: function query(text, values, cb) {
      var _this7 = this;

      // guard clause against passing a function as the first parameter
      if (typeof text === 'function') {
        var _response = promisify(this.Promise, text);

        setImmediate(function () {
          return _response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'));
        });
        return _response.result;
      } // allow plain text query without values


      if (typeof values === 'function') {
        cb = values;
        values = undefined;
      }

      var response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect(function (err, client) {
        if (err) {
          return cb(err);
        }

        var clientReleased = false;

        var onError = function onError(err) {
          if (clientReleased) {
            return;
          }

          clientReleased = true;
          client.release(err);
          cb(err);
        };

        client.once('error', onError);

        _this7.log('dispatching query');

        client.query(text, values, function (err, res) {
          _this7.log('query dispatched');

          client.removeListener('error', onError);

          if (clientReleased) {
            return;
          }

          clientReleased = true;
          client.release(err);

          if (err) {
            return cb(err);
          } else {
            return cb(undefined, res);
          }
        });
      });
      return response.result;
    }
  }, {
    key: "end",
    value: function end(cb) {
      this.log('ending');

      if (this.ending) {
        var err = new Error('Called end on pool more than once');
        return cb ? cb(err) : this.Promise.reject(err);
      }

      this.ending = true;
      var promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;

      this._pulseQueue();

      return promised.result;
    }
  }, {
    key: "waitingCount",
    get: function get() {
      return this._pendingQueue.length;
    }
  }, {
    key: "idleCount",
    get: function get() {
      return this._idle.length;
    }
  }, {
    key: "totalCount",
    get: function get() {
      return this._clients.length;
    }
  }]);

  return Pool;
}(EventEmitter);

module.exports = Pool;