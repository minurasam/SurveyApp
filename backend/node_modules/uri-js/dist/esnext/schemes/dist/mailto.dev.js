"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _uri = require("../uri");

var _punycode = _interopRequireDefault(require("punycode"));

var _util = require("../util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var O = {};
var isIRI = true; //RFC 3986

var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive

var PCT_ENCODED$ = (0, _util.subexp)((0, _util.subexp)("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + (0, _util.subexp)("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + (0, _util.subexp)("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');

var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = (0, _util.merge)(QTEXT$$, "[\\\"\\\\]");
var DOT_ATOM_TEXT$ = (0, _util.subexp)(ATEXT$$ + "+" + (0, _util.subexp)("\\." + ATEXT$$ + "+") + "*");
var QUOTED_PAIR$ = (0, _util.subexp)("\\\\" + VCHAR$$);
var QCONTENT$ = (0, _util.subexp)(QTEXT$$ + "|" + QUOTED_PAIR$);
var QUOTED_STRING$ = (0, _util.subexp)('\\"' + QCONTENT$ + "*" + '\\"'); //RFC 6068

var DTEXT_NO_OBS$$ = "[\\x21-\\x5A\\x5E-\\x7E]"; //%d33-90 / %d94-126

var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var QCHAR$ = (0, _util.subexp)(UNRESERVED$$ + "|" + PCT_ENCODED$ + "|" + SOME_DELIMS$$);
var DOMAIN$ = (0, _util.subexp)(DOT_ATOM_TEXT$ + "|" + "\\[" + DTEXT_NO_OBS$$ + "*" + "\\]");
var LOCAL_PART$ = (0, _util.subexp)(DOT_ATOM_TEXT$ + "|" + QUOTED_STRING$);
var ADDR_SPEC$ = (0, _util.subexp)(LOCAL_PART$ + "\\@" + DOMAIN$);
var TO$ = (0, _util.subexp)(ADDR_SPEC$ + (0, _util.subexp)("\\," + ADDR_SPEC$) + "*");
var HFNAME$ = (0, _util.subexp)(QCHAR$ + "*");
var HFVALUE$ = HFNAME$;
var HFIELD$ = (0, _util.subexp)(HFNAME$ + "\\=" + HFVALUE$);
var HFIELDS2$ = (0, _util.subexp)(HFIELD$ + (0, _util.subexp)("\\&" + HFIELD$) + "*");
var HFIELDS$ = (0, _util.subexp)("\\?" + HFIELDS2$);
var MAILTO_URI = new RegExp("^mailto\\:" + TO$ + "?" + HFIELDS$ + "?$");
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp((0, _util.merge)("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_DOMAIN = new RegExp((0, _util.merge)("[^]", ATEXT$$, "[\\.]", "[\\[]", DTEXT_NO_OBS$$, "[\\]]"), "g");
var NOT_HFNAME = new RegExp((0, _util.merge)("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
var TO = new RegExp("^" + TO$ + "$");
var HFIELDS = new RegExp("^" + HFIELDS2$ + "$");

function decodeUnreserved(str) {
  var decStr = (0, _uri.pctDecChars)(str);
  return !decStr.match(UNRESERVED) ? str : decStr;
}

var handler = {
  scheme: "mailto",
  parse: function parse(components, options) {
    var mailtoComponents = components;
    var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
    mailtoComponents.path = undefined;

    if (mailtoComponents.query) {
      var unknownHeaders = false;
      var headers = {};
      var hfields = mailtoComponents.query.split("&");

      for (var x = 0, xl = hfields.length; x < xl; ++x) {
        var hfield = hfields[x].split("=");

        switch (hfield[0]) {
          case "to":
            var toAddrs = hfield[1].split(",");

            for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
              to.push(toAddrs[_x]);
            }

            break;

          case "subject":
            mailtoComponents.subject = (0, _uri.unescapeComponent)(hfield[1], options);
            break;

          case "body":
            mailtoComponents.body = (0, _uri.unescapeComponent)(hfield[1], options);
            break;

          default:
            unknownHeaders = true;
            headers[(0, _uri.unescapeComponent)(hfield[0], options)] = (0, _uri.unescapeComponent)(hfield[1], options);
            break;
        }
      }

      if (unknownHeaders) mailtoComponents.headers = headers;
    }

    mailtoComponents.query = undefined;

    for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
      var addr = to[_x2].split("@");

      addr[0] = (0, _uri.unescapeComponent)(addr[0]);

      if (!options.unicodeSupport) {
        //convert Unicode IDN -> ASCII IDN
        try {
          addr[1] = _punycode["default"].toASCII((0, _uri.unescapeComponent)(addr[1], options).toLowerCase());
        } catch (e) {
          mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
        }
      } else {
        addr[1] = (0, _uri.unescapeComponent)(addr[1], options).toLowerCase();
      }

      to[_x2] = addr.join("@");
    }

    return mailtoComponents;
  },
  serialize: function serialize(mailtoComponents, options) {
    var components = mailtoComponents;
    var to = (0, _util.toArray)(mailtoComponents.to);

    if (to) {
      for (var x = 0, xl = to.length; x < xl; ++x) {
        var toAddr = String(to[x]);
        var atIdx = toAddr.lastIndexOf("@");
        var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, _util.toUpperCase).replace(NOT_LOCAL_PART, _uri.pctEncChar);
        var domain = toAddr.slice(atIdx + 1); //convert IDN via punycode

        try {
          domain = !options.iri ? _punycode["default"].toASCII((0, _uri.unescapeComponent)(domain, options).toLowerCase()) : _punycode["default"].toUnicode(domain);
        } catch (e) {
          components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
        }

        to[x] = localPart + "@" + domain;
      }

      components.path = to.join(",");
    }

    var headers = mailtoComponents.headers = mailtoComponents.headers || {};
    if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
    if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
    var fields = [];

    for (var name in headers) {
      if (headers[name] !== O[name]) {
        fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, _util.toUpperCase).replace(NOT_HFNAME, _uri.pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, _util.toUpperCase).replace(NOT_HFVALUE, _uri.pctEncChar));
      }
    }

    if (fields.length) {
      components.query = fields.join("&");
    }

    return components;
  }
};
var _default = handler;
exports["default"] = _default;