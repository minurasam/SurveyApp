"use strict"; // Copyright 2020 Google LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.closeSession = exports.request = exports.sessions = void 0;

var http2 = require("http2");

var zlib = require("zlib");

var url_1 = require("url");

var qs = require("qs");

var extend = require("extend");

var stream_1 = require("stream");

var util = require("util");

var process = require("process");

var common_1 = require("gaxios/build/src/common");

var _http2$constants = http2.constants,
    HTTP2_HEADER_CONTENT_ENCODING = _http2$constants.HTTP2_HEADER_CONTENT_ENCODING,
    HTTP2_HEADER_CONTENT_TYPE = _http2$constants.HTTP2_HEADER_CONTENT_TYPE,
    HTTP2_HEADER_METHOD = _http2$constants.HTTP2_HEADER_METHOD,
    HTTP2_HEADER_PATH = _http2$constants.HTTP2_HEADER_PATH,
    HTTP2_HEADER_STATUS = _http2$constants.HTTP2_HEADER_STATUS;
var DEBUG = !!process.env.HTTP2_DEBUG;
/**
 * List of sessions current in use.
 * @private
 */

exports.sessions = {};
var warned = false;
/**
 * Public method to make an http2 request.
 * @param config - Request options.
 */

function request(config) {
  var _Object$assign;

  var message, opts, url, sessionData, pathWithQs, q, headers, res, chunks, session, req;
  return regeneratorRuntime.async(function request$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          // Make sure users know this API is unstable
          if (!warned) {
            message = "\n      The HTTP/2 API in googleapis is unstable! This is an early implementation\n      that should not be used in production.  It may change in unpredictable\n      ways. Please only use this for experimentation.\n    ";
            process.emitWarning(message, 'GOOG_HTTP2');
            warned = true;
          }

          opts = extend(true, {}, config);
          opts.validateStatus = opts.validateStatus || validateStatus;
          opts.responseType = opts.responseType || 'json';
          url = new url_1.URL(opts.url); // Check for an existing session to this host, or go create a new one.

          sessionData = _getClient(url.host); // Since we're using this session, clear the timeout handle to ensure
          // it stays in memory and connected for a while further.

          if (sessionData.timeoutHandle !== undefined) {
            clearTimeout(sessionData.timeoutHandle);
          } // Assemble the querystring based on config.params.  We're using the
          // `qs` module to make life a little easier.


          pathWithQs = url.pathname;

          if (config.params && Object.keys(config.params).length > 0) {
            q = qs.stringify(opts.params);
            pathWithQs += "?".concat(q);
          } // Assemble the headers based on basic HTTP2 primitives (path, method) and
          // custom headers sent from the consumer.  Note: I am using `Object.assign`
          // here making the assumption these objects are not deep.  If it turns out
          // they are, we may need to use the `extend` npm module for deep cloning.


          headers = Object.assign({}, opts.headers, (_Object$assign = {}, _defineProperty(_Object$assign, HTTP2_HEADER_PATH, pathWithQs), _defineProperty(_Object$assign, HTTP2_HEADER_METHOD, config.method || 'GET'), _Object$assign)); // NOTE: This is working around an upstream bug in `apirequest.ts`. The
          // request path assumes that the `content-type` header is going to be set in
          // the underlying HTTP Client. This hack provides bug for bug compatability
          // with this bug in gaxios:
          // https://github.com/googleapis/gaxios/blob/master/src/gaxios.ts#L202

          if (!headers[HTTP2_HEADER_CONTENT_TYPE]) {
            if (opts.responseType !== 'text') {
              headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/json';
            }
          }

          res = {
            config: config,
            request: {},
            headers: [],
            status: 0,
            data: {},
            statusText: ''
          };
          chunks = [];
          session = sessionData.session;
          return _context.abrupt("return", new Promise(function (resolve, reject) {
            try {
              req = session.request(headers).on('response', function (headers) {
                res.headers = headers;
                res.status = Number(headers[HTTP2_HEADER_STATUS]);
                var stream = req;

                if (headers[HTTP2_HEADER_CONTENT_ENCODING] === 'gzip') {
                  stream = req.pipe(zlib.createGunzip());
                }

                if (opts.responseType === 'stream') {
                  res.data = stream;
                  resolve(res);
                  return;
                }

                stream.on('data', function (d) {
                  chunks.push(d);
                }).on('error', function (err) {
                  reject(err);
                  return;
                }).on('end', function () {
                  var buf = Buffer.concat(chunks); // eslint-disable-next-line @typescript-eslint/no-explicit-any

                  var data = buf;

                  if (buf) {
                    if (opts.responseType === 'json') {
                      try {
                        data = JSON.parse(buf.toString('utf8'));
                      } catch (_a) {
                        data = buf.toString('utf8');
                      }
                    } else if (opts.responseType === 'text') {
                      data = buf.toString('utf8');
                    } else if (opts.responseType === 'arraybuffer') {
                      data = buf.buffer;
                    }

                    res.data = data;
                  }

                  if (!opts.validateStatus(res.status)) {
                    var _message = "Request failed with status code ".concat(res.status, ". ");

                    if (res.data && _typeof(res.data) === 'object') {
                      var body = util.inspect(res.data, {
                        depth: 5
                      });
                      _message = "".concat(_message, "\n'").concat(body);
                    }

                    reject(new common_1.GaxiosError(_message, opts, res));
                  }

                  resolve(res);
                  return;
                });
              }).on('error', function (e) {
                reject(e);
                return;
              });
            } catch (e) {
              closeSession(url);
              reject(e);
            }

            res.request = req; // If data was provided, write it to the request in the form of
            // a stream, string data, or a basic object.

            if (config.data) {
              if (config.data instanceof stream_1.Stream) {
                config.data.pipe(req);
              } else if (typeof config.data === 'string') {
                var data = Buffer.from(config.data);
                req.end(data);
              } else if (_typeof(config.data) === 'object') {
                var _data = JSON.stringify(config.data);

                req.end(_data);
              }
            } // Create a timeout so the Http2Session will be cleaned up after
            // a period of non-use. 500 milliseconds was chosen because it's
            // a nice round number, and I don't know what would be a better
            // choice. Keeping this channel open will hold a file descriptor
            // which will prevent the process from exiting.


            sessionData.timeoutHandle = setTimeout(function () {
              closeSession(url);
            }, 500);
          }));

        case 15:
        case "end":
          return _context.stop();
      }
    }
  });
}

exports.request = request;
/**
 * By default, throw for any non-2xx status code
 * @param status - status code from the HTTP response
 */

function validateStatus(status) {
  return status >= 200 && status < 300;
}
/**
 * Obtain an existing h2 session or go create a new one.
 * @param host - The hostname to which the session belongs.
 */


function _getClient(host) {
  if (!exports.sessions[host]) {
    if (DEBUG) {
      console.log("Creating client for ".concat(host));
    }

    var session = http2.connect("https://".concat(host));
    session.on('error', function (e) {
      console.error("*ERROR*: ".concat(e));
      delete exports.sessions[host];
    }).on('goaway', function (errorCode, lastStreamId) {
      console.error("*GOAWAY*: ".concat(errorCode, " : ").concat(lastStreamId));
      delete exports.sessions[host];
    });
    exports.sessions[host] = {
      session: session
    };
  } else {
    if (DEBUG) {
      console.log("Used cached client for ".concat(host));
    }
  }

  return exports.sessions[host];
}

function closeSession(url) {
  var sessionData, session;
  return regeneratorRuntime.async(function closeSession$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          sessionData = exports.sessions[url.host];

          if (sessionData) {
            _context2.next = 3;
            break;
          }

          return _context2.abrupt("return");

        case 3:
          session = sessionData.session;
          delete exports.sessions[url.host];

          if (DEBUG) {
            console.error("Closing ".concat(url.host));
          }

          session.close(function () {
            if (DEBUG) {
              console.error("Closed ".concat(url.host));
            }
          });
          setTimeout(function () {
            if (session && !session.destroyed) {
              if (DEBUG) {
                console.log("Forcing close ".concat(url.host));
              }

              if (session) {
                session.destroy();
              }
            }
          }, 1000);

        case 8:
        case "end":
          return _context2.stop();
      }
    }
  });
}

exports.closeSession = closeSession;