"use strict"; // Copyright 2020 Google LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAPIRequest = void 0;

var google_auth_library_1 = require("google-auth-library");

var qs = require("qs");

var stream = require("stream");

var urlTemplate = require("url-template");

var uuid = require("uuid");

var extend = require("extend");

var isbrowser_1 = require("./isbrowser");

var h2 = require("./http2"); // eslint-disable-next-line @typescript-eslint/no-var-requires


var pkg = require('../../package.json'); // eslint-disable-next-line @typescript-eslint/no-explicit-any


function isReadableStream(obj) {
  return obj !== null && _typeof(obj) === 'object' && typeof obj.pipe === 'function' && obj.readable !== false && typeof obj._read === 'function' && _typeof(obj._readableState) === 'object';
}

function getMissingParams(params, required) {
  var missing = new Array();
  required.forEach(function (param) {
    // Is the required param in the params object?
    if (params[param] === undefined) {
      missing.push(param);
    }
  }); // If there are any required params missing, return their names in array,
  // otherwise return null

  return missing.length > 0 ? missing : null;
}

function createAPIRequest(parameters, callback) {
  if (callback) {
    createAPIRequestAsync(parameters).then(function (r) {
      return callback(null, r);
    }, callback);
  } else {
    return createAPIRequestAsync(parameters);
  }
}

exports.createAPIRequest = createAPIRequest;

function createAPIRequestAsync(parameters) {
  var _a, options, params, media, resource, authClient, defaultMime, headers, missingParams, originalUrl, path, multipartUpload, browserMultipartUpload, multipart, userAgent, authHeaders, mooOpts;

  return regeneratorRuntime.async(function createAPIRequestAsync$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          browserMultipartUpload = function _ref2(multipart) {
            var boundary = uuid.v4();
            var finale = "--".concat(boundary, "--");
            headers['content-type'] = "multipart/related; boundary=".concat(boundary);
            var content = '';
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = multipart[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var part = _step2.value;
                var preamble = "--".concat(boundary, "\r\ncontent-type: ").concat(part['content-type'], "\r\n\r\n");
                content += preamble;

                if (typeof part.body === 'string') {
                  content += part.body;
                  content += '\r\n';
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            content += finale;
            options.data = content;
          };

          multipartUpload = function _ref(multipart) {
            var boundary = uuid.v4();
            var finale = "--".concat(boundary, "--");
            var rStream = new stream.PassThrough({
              flush: function flush(callback) {
                this.push('\r\n');
                this.push(finale);
                callback();
              }
            });
            var pStream = new ProgressStream();
            var isStream = isReadableStream(multipart[1].body);
            headers['content-type'] = "multipart/related; boundary=".concat(boundary);
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = multipart[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var part = _step.value;
                var preamble = "--".concat(boundary, "\r\ncontent-type: ").concat(part['content-type'], "\r\n\r\n");
                rStream.push(preamble);

                if (typeof part.body === 'string') {
                  rStream.push(part.body);
                  rStream.push('\r\n');
                } else {
                  // Gaxios does not natively support onUploadProgress in node.js.
                  // Pipe through the pStream first to read the number of bytes read
                  // for the purpose of tracking progress.
                  pStream.on('progress', function (bytesRead) {
                    if (options.onUploadProgress) {
                      options.onUploadProgress({
                        bytesRead: bytesRead
                      });
                    }
                  });
                  part.body.pipe(pStream).pipe(rStream);
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            if (!isStream) {
              rStream.push(finale);
              rStream.push(null);
            }

            options.data = rStream;
          };

          // Combine the GaxiosOptions options passed with this specific
          // API call with the global options configured at the API Context
          // level, or at the global level.
          options = extend(true, {}, // Ensure we don't leak settings upstream
          ((_a = parameters.context.google) === null || _a === void 0 ? void 0 : _a._options) || {}, // Google level options
          parameters.context._options || {}, // Per-API options
          parameters.options // API call params
          );
          params = extend(true, {}, // New base object
          options.params, // Combined global/per-api params
          parameters.params // API call params
          );
          options.userAgentDirectives = options.userAgentDirectives || [];
          media = params.media || {};
          /**
           * In a previous version of this API, the request body was stuffed in a field
           * named `resource`.  This caused lots of problems, because it's not uncommon
           * to have an actual named parameter required which is also named `resource`.
           * This meant that users would have to use `resource_` in those cases, which
           * pretty much nobody figures out on their own. The request body is now
           * documented as being in the `requestBody` property, but we also need to keep
           * using `resource` for reasons of back-compat. Cases that need to be covered
           * here:
           * - user provides just a `resource` with a request body
           * - user provides both a `resource` and a `resource_`
           * - user provides just a `requestBody`
           * - user provides both a `requestBody` and a `resource`
           */

          resource = params.requestBody;

          if (!params.requestBody && params.resource && (!parameters.requiredParams.includes('resource') || typeof params.resource !== 'string')) {
            resource = params.resource;
            delete params.resource;
          }

          delete params.requestBody;
          authClient = params.auth || options.auth;
          defaultMime = typeof media.body === 'string' ? 'text/plain' : 'application/octet-stream';
          delete params.media;
          delete params.auth; // Grab headers from user provided options

          headers = params.headers || {};
          populateAPIHeader(headers);
          delete params.headers; // Un-alias parameters that were modified due to conflicts with reserved names

          Object.keys(params).forEach(function (key) {
            if (key.slice(-1) === '_') {
              var newKey = key.slice(0, -1);
              params[newKey] = params[key];
              delete params[key];
            }
          }); // Check for missing required parameters in the API request

          missingParams = getMissingParams(params, parameters.requiredParams);

          if (!missingParams) {
            _context.next = 20;
            break;
          }

          throw new Error('Missing required parameters: ' + missingParams.join(', '));

        case 20:
          // Parse urls
          if (options.url) {
            options.url = urlTemplate.parse(options.url).expand(params);
          }

          if (parameters.mediaUrl) {
            parameters.mediaUrl = urlTemplate.parse(parameters.mediaUrl).expand(params);
          } // Rewrite url if rootUrl is globally set


          if (parameters.context._options.rootUrl !== undefined && options.url !== undefined) {
            originalUrl = new URL(options.url);
            path = originalUrl.href.substr(originalUrl.origin.length);
            options.url = new URL(path, parameters.context._options.rootUrl).href;
          } // When forming the querystring, override the serializer so that array
          // values are serialized like this:
          // myParams: ['one', 'two'] ---> 'myParams=one&myParams=two'
          // This serializer also encodes spaces in the querystring as `%20`,
          // whereas the default serializer in gaxios encodes to a `+`.


          options.paramsSerializer = function (params) {
            return qs.stringify(params, {
              arrayFormat: 'repeat'
            });
          }; // delete path params from the params object so they do not end up in query


          parameters.pathParams.forEach(function (param) {
            return delete params[param];
          }); // if authClient is actually a string, use it as an API KEY

          if (typeof authClient === 'string') {
            params.key = params.key || authClient;
            authClient = undefined;
          }

          if (parameters.mediaUrl && media.body) {
            options.url = parameters.mediaUrl;

            if (resource) {
              params.uploadType = 'multipart';
              multipart = [{
                'content-type': 'application/json',
                body: JSON.stringify(resource)
              }, {
                'content-type': media.mimeType || resource && resource.mimeType || defaultMime,
                body: media.body
              }];

              if (!isbrowser_1.isBrowser()) {
                // gaxios doesn't support multipart/related uploads, so it has to
                // be implemented here.
                multipartUpload(multipart);
              } else {
                browserMultipartUpload(multipart);
              }
            } else {
              params.uploadType = 'media';
              Object.assign(headers, {
                'content-type': media.mimeType || defaultMime
              });
              options.data = media.body;
            }
          } else {
            options.data = resource || undefined;
          }

          options.headers = extend(true, options.headers || {}, headers);
          options.params = params;

          if (!isbrowser_1.isBrowser()) {
            options.headers['Accept-Encoding'] = 'gzip';
            options.userAgentDirectives.push({
              product: 'google-api-nodejs-client',
              version: pkg.version,
              comment: 'gzip'
            });
            userAgent = options.userAgentDirectives.map(function (d) {
              var line = "".concat(d.product, "/").concat(d.version);

              if (d.comment) {
                line += " (".concat(d.comment, ")");
              }

              return line;
            }).join(' ');
            options.headers['User-Agent'] = userAgent;
          } // By default gaxios treats any 2xx as valid, and all non 2xx status
          // codes as errors.  This is a problem for HTTP 304s when used along
          // with an eTag.


          if (!options.validateStatus) {
            options.validateStatus = function (status) {
              return status >= 200 && status < 300 || status === 304;
            };
          } // Retry by default


          options.retry = options.retry === undefined ? true : options.retry;
          delete options.auth; // is overridden by our auth code
          // Perform the HTTP request.  NOTE: this function used to return a
          // mikeal/request object. Since the transition to Axios, the method is
          // now void.  This may be a source of confusion for users upgrading from
          // version 24.0 -> 25.0 or up.

          if (!(authClient && _typeof(authClient) === 'object')) {
            _context.next = 46;
            break;
          }

          if (!options.http2) {
            _context.next = 43;
            break;
          }

          _context.next = 37;
          return regeneratorRuntime.awrap(authClient.getRequestHeaders(options.url));

        case 37:
          authHeaders = _context.sent;
          mooOpts = Object.assign({}, options);
          mooOpts.headers = Object.assign(mooOpts.headers, authHeaders);
          return _context.abrupt("return", h2.request(mooOpts));

        case 43:
          return _context.abrupt("return", authClient.request(options));

        case 44:
          _context.next = 47;
          break;

        case 46:
          return _context.abrupt("return", new google_auth_library_1.DefaultTransporter().request(options));

        case 47:
        case "end":
          return _context.stop();
      }
    }
  });
}
/**
 * Basic Passthrough Stream that records the number of bytes read
 * every time the cursor is moved.
 */


var ProgressStream =
/*#__PURE__*/
function (_stream$Transform) {
  _inherits(ProgressStream, _stream$Transform);

  function ProgressStream() {
    var _this;

    _classCallCheck(this, ProgressStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ProgressStream).apply(this, arguments));
    _this.bytesRead = 0;
    return _this;
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  _createClass(ProgressStream, [{
    key: "_transform",
    value: function _transform(chunk, encoding, callback) {
      this.bytesRead += chunk.length;
      this.emit('progress', this.bytesRead);
      this.push(chunk);
      callback();
    }
  }]);

  return ProgressStream;
}(stream.Transform);

function populateAPIHeader(headers) {
  // TODO: we should eventually think about adding browser support for this
  // populating the gl-web header (web support should also be added to
  // google-auth-library-nodejs).
  if (!isbrowser_1.isBrowser()) {
    headers['x-goog-api-client'] = "gdcl/".concat(pkg.version, " gl-node/").concat(process.versions.node);
  }
}