"use strict";
exports.__esModule = true;
exports.serialize = void 0;
var buffer_writer_1 = require("./buffer-writer");
var writer = new buffer_writer_1.Writer();
var startup = function (opts) {
    // protocol version
    writer.addInt16(3).addInt16(0);
    for (var _i = 0, _a = Object.keys(opts); _i < _a.length; _i++) {
        var key = _a[_i];
        writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString('client_encoding').addCString('UTF8');
    var bodyBuffer = writer.addCString('').flush();
    // this message is sent without a code
    var length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
};
var requestSsl = function () {
    var response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
};
var password = function (password) {
    return writer.addCString(password).flush(112 /* startup */);
};
var sendSASLInitialResponseMessage = function (mechanism, initialResponse) {
    // 0x70 = 'p'
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112 /* startup */);
};
var sendSCRAMClientFinalMessage = function (additionalData) {
    return writer.addString(additionalData).flush(112 /* startup */);
};
var query = function (text) {
    return writer.addCString(text).flush(81 /* query */);
};
var emptyArray = [];
var parse = function (query) {
    // expect something like this:
    // { name: 'queryName',
    //   text: 'select * from blah',
    //   types: ['int8', 'bool'] }
    // normalize missing query names to allow for null
    var name = query.name || '';
    if (name.length > 63) {
        /* eslint-disable no-console */
        console.error('Warning! Postgres only supports 63 characters for query names.');
        console.error('You supplied %s (%s)', name, name.length);
        console.error('This can cause conflicts and silent errors executing queries');
        /* eslint-enable no-console */
    }
    var types = query.types || emptyArray;
    var len = types.length;
    var buffer = writer
        .addCString(name) // name of query
        .addCString(query.text) // actual query text
        .addInt16(len);
    for (var i = 0; i < len; i++) {
        buffer.addInt32(types[i]);
    }
    return writer.flush(80 /* parse */);
};
var paramWriter = new buffer_writer_1.Writer();
var writeValues = function (values, valueMapper) {
    for (var i = 0; i < values.length; i++) {
        var mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
        if (mappedVal == null) {
            // add the param type (string) to the writer
            writer.addInt16(0 /* STRING */);
            // write -1 to the param writer to indicate null
            paramWriter.addInt32(-1);
        }
        else if (mappedVal instanceof Buffer) {
            // add the param type (binary) to the writer
            writer.addInt16(1 /* BINARY */);
            // add the buffer to the param writer
            paramWriter.addInt32(mappedVal.length);
            paramWriter.add(mappedVal);
        }
        else {
            // add the param type (string) to the writer
            writer.addInt16(0 /* STRING */);
            paramWriter.addInt32(Buffer.byteLength(mappedVal));
            paramWriter.addString(mappedVal);
        }
    }
};
var bind = function (config) {
    if (config === void 0) { config = {}; }
    // normalize config
    var portal = config.portal || '';
    var statement = config.statement || '';
    var binary = config.binary || false;
    var values = config.values || emptyArray;
    var len = values.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values, config.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    // format code
    writer.addInt16(binary ? 1 /* BINARY */ : 0 /* STRING */);
    return writer.flush(66 /* bind */);
};
var emptyExecute = Buffer.from([69 /* execute */, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00]);
var execute = function (config) {
    // this is the happy path for most queries
    if (!config || (!config.portal && !config.rows)) {
        return emptyExecute;
    }
    var portal = config.portal || '';
    var rows = config.rows || 0;
    var portalLength = Buffer.byteLength(portal);
    var len = 4 + portalLength + 1 + 4;
    // one extra bit for code
    var buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69 /* execute */;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, 'utf-8');
    buff[portalLength + 5] = 0; // null terminate portal cString
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
};
var cancel = function (processID, secretKey) {
    var buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
};
var cstringMessage = function (code, string) {
    var stringLen = Buffer.byteLength(string);
    var len = 4 + stringLen + 1;
    // one extra bit for code
    var buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string, 5, 'utf-8');
    buffer[len] = 0; // null terminate cString
    return buffer;
};
var emptyDescribePortal = writer.addCString('P').flush(68 /* describe */);
var emptyDescribeStatement = writer.addCString('S').flush(68 /* describe */);
var describe = function (msg) {
    return msg.name
        ? cstringMessage(68 /* describe */, "" + msg.type + (msg.name || ''))
        : msg.type === 'P'
            ? emptyDescribePortal
            : emptyDescribeStatement;
};
var close = function (msg) {
    var text = "" + msg.type + (msg.name || '');
    return cstringMessage(67 /* close */, text);
};
var copyData = function (chunk) {
    return writer.add(chunk).flush(100 /* copyFromChunk */);
};
var copyFail = function (message) {
    return cstringMessage(102 /* copyFail */, message);
};
var codeOnlyBuffer = function (code) { return Buffer.from([code, 0x00, 0x00, 0x00, 0x04]); };
var flushBuffer = codeOnlyBuffer(72 /* flush */);
var syncBuffer = codeOnlyBuffer(83 /* sync */);
var endBuffer = codeOnlyBuffer(88 /* end */);
var copyDoneBuffer = codeOnlyBuffer(99 /* copyDone */);
var serialize = {
    startup: startup,
    password: password,
    requestSsl: requestSsl,
    sendSASLInitialResponseMessage: sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage: sendSCRAMClientFinalMessage,
    query: query,
    parse: parse,
    bind: bind,
    execute: execute,
    describe: describe,
    close: close,
    flush: function () { return flushBuffer; },
    sync: function () { return syncBuffer; },
    end: function () { return endBuffer; },
    copyData: copyData,
    copyDone: function () { return copyDoneBuffer; },
    copyFail: copyFail,
    cancel: cancel
};
exports.serialize = serialize;
