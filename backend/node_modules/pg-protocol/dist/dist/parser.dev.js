"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parser = void 0;

var messages_1 = require("./messages");

var buffer_reader_1 = require("./buffer-reader");

var assert_1 = __importDefault(require("assert")); // every message is prefixed with a single bye


var CODE_LENGTH = 1; // every message has an int32 length which includes itself but does
// NOT include the code in the length

var LEN_LENGTH = 4;
var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
var emptyBuffer = Buffer.allocUnsafe(0);

var Parser =
/*#__PURE__*/
function () {
  function Parser(opts) {
    _classCallCheck(this, Parser);

    this.buffer = emptyBuffer;
    this.bufferLength = 0;
    this.bufferOffset = 0;
    this.reader = new buffer_reader_1.BufferReader();

    if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {
      throw new Error('Binary mode not supported yet');
    }

    this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';
  }

  _createClass(Parser, [{
    key: "parse",
    value: function parse(buffer, callback) {
      this.mergeBuffer(buffer);
      var bufferFullLength = this.bufferOffset + this.bufferLength;
      var offset = this.bufferOffset;

      while (offset + HEADER_LENGTH <= bufferFullLength) {
        // code is 1 byte long - it identifies the message type
        var code = this.buffer[offset]; // length is 1 Uint32BE - it is the length of the message EXCLUDING the code

        var length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        var fullMessageLength = CODE_LENGTH + length;

        if (fullMessageLength + offset <= bufferFullLength) {
          var message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
          callback(message);
          offset += fullMessageLength;
        } else {
          break;
        }
      }

      if (offset === bufferFullLength) {
        // No more use for the buffer
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        // Adjust the cursors of remainingBuffer
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
  }, {
    key: "mergeBuffer",
    value: function mergeBuffer(buffer) {
      if (this.bufferLength > 0) {
        var newLength = this.bufferLength + buffer.byteLength;
        var newFullLength = newLength + this.bufferOffset;

        if (newFullLength > this.buffer.byteLength) {
          // We can't concat the new buffer with the remaining one
          var newBuffer;

          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer
            newBuffer = this.buffer;
          } else {
            // Allocate a new larger buffer
            var newBufferLength = this.buffer.byteLength * 2;

            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }

            newBuffer = Buffer.allocUnsafe(newBufferLength);
          } // Move the remaining buffer to the new one


          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        } // Concat the new buffer with the remaining one


        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer;
        this.bufferOffset = 0;
        this.bufferLength = buffer.byteLength;
      }
    }
  }, {
    key: "handlePacket",
    value: function handlePacket(offset, code, length, bytes) {
      switch (code) {
        case 50
        /* BindComplete */
        :
          return messages_1.bindComplete;

        case 49
        /* ParseComplete */
        :
          return messages_1.parseComplete;

        case 51
        /* CloseComplete */
        :
          return messages_1.closeComplete;

        case 110
        /* NoData */
        :
          return messages_1.noData;

        case 115
        /* PortalSuspended */
        :
          return messages_1.portalSuspended;

        case 99
        /* CopyDone */
        :
          return messages_1.copyDone;

        case 87
        /* ReplicationStart */
        :
          return messages_1.replicationStart;

        case 73
        /* EmptyQuery */
        :
          return messages_1.emptyQuery;

        case 68
        /* DataRow */
        :
          return this.parseDataRowMessage(offset, length, bytes);

        case 67
        /* CommandComplete */
        :
          return this.parseCommandCompleteMessage(offset, length, bytes);

        case 90
        /* ReadyForQuery */
        :
          return this.parseReadyForQueryMessage(offset, length, bytes);

        case 65
        /* NotificationResponse */
        :
          return this.parseNotificationMessage(offset, length, bytes);

        case 82
        /* AuthenticationResponse */
        :
          return this.parseAuthenticationResponse(offset, length, bytes);

        case 83
        /* ParameterStatus */
        :
          return this.parseParameterStatusMessage(offset, length, bytes);

        case 75
        /* BackendKeyData */
        :
          return this.parseBackendKeyData(offset, length, bytes);

        case 69
        /* ErrorMessage */
        :
          return this.parseErrorMessage(offset, length, bytes, 'error');

        case 78
        /* NoticeMessage */
        :
          return this.parseErrorMessage(offset, length, bytes, 'notice');

        case 84
        /* RowDescriptionMessage */
        :
          return this.parseRowDescriptionMessage(offset, length, bytes);

        case 116
        /* ParameterDescriptionMessage */
        :
          return this.parseParameterDescriptionMessage(offset, length, bytes);

        case 71
        /* CopyIn */
        :
          return this.parseCopyInMessage(offset, length, bytes);

        case 72
        /* CopyOut */
        :
          return this.parseCopyOutMessage(offset, length, bytes);

        case 100
        /* CopyData */
        :
          return this.parseCopyData(offset, length, bytes);

        default:
          assert_1["default"].fail("unknown message code: ".concat(code.toString(16)));
      }
    }
  }, {
    key: "parseReadyForQueryMessage",
    value: function parseReadyForQueryMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      var status = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length, status);
    }
  }, {
    key: "parseCommandCompleteMessage",
    value: function parseCommandCompleteMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      var text = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length, text);
    }
  }, {
    key: "parseCopyData",
    value: function parseCopyData(offset, length, bytes) {
      var chunk = bytes.slice(offset, offset + (length - 4));
      return new messages_1.CopyDataMessage(length, chunk);
    }
  }, {
    key: "parseCopyInMessage",
    value: function parseCopyInMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, 'copyInResponse');
    }
  }, {
    key: "parseCopyOutMessage",
    value: function parseCopyOutMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse');
    }
  }, {
    key: "parseCopyMessage",
    value: function parseCopyMessage(offset, length, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      var isBinary = this.reader["byte"]() !== 0;
      var columnCount = this.reader.int16();
      var message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);

      for (var i = 0; i < columnCount; i++) {
        message.columnTypes[i] = this.reader.int16();
      }

      return message;
    }
  }, {
    key: "parseNotificationMessage",
    value: function parseNotificationMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      var processId = this.reader.int32();
      var channel = this.reader.cstring();
      var payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
    }
  }, {
    key: "parseRowDescriptionMessage",
    value: function parseRowDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      var fieldCount = this.reader.int16();
      var message = new messages_1.RowDescriptionMessage(length, fieldCount);

      for (var i = 0; i < fieldCount; i++) {
        message.fields[i] = this.parseField();
      }

      return message;
    }
  }, {
    key: "parseField",
    value: function parseField() {
      var name = this.reader.cstring();
      var tableID = this.reader.int32();
      var columnID = this.reader.int16();
      var dataTypeID = this.reader.int32();
      var dataTypeSize = this.reader.int16();
      var dataTypeModifier = this.reader.int32();
      var mode = this.reader.int16() === 0 ? 'text' : 'binary';
      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
  }, {
    key: "parseParameterDescriptionMessage",
    value: function parseParameterDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      var parameterCount = this.reader.int16();
      var message = new messages_1.ParameterDescriptionMessage(length, parameterCount);

      for (var i = 0; i < parameterCount; i++) {
        message.dataTypeIDs[i] = this.reader.int32();
      }

      return message;
    }
  }, {
    key: "parseDataRowMessage",
    value: function parseDataRowMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      var fieldCount = this.reader.int16();
      var fields = new Array(fieldCount);

      for (var i = 0; i < fieldCount; i++) {
        var len = this.reader.int32(); // a -1 for length means the value of the field is null

        fields[i] = len === -1 ? null : this.reader.string(len);
      }

      return new messages_1.DataRowMessage(length, fields);
    }
  }, {
    key: "parseParameterStatusMessage",
    value: function parseParameterStatusMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      var name = this.reader.cstring();
      var value = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length, name, value);
    }
  }, {
    key: "parseBackendKeyData",
    value: function parseBackendKeyData(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      var processID = this.reader.int32();
      var secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
  }, {
    key: "parseAuthenticationResponse",
    value: function parseAuthenticationResponse(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      var code = this.reader.int32(); // TODO(bmc): maybe better types here

      var message = {
        name: 'authenticationOk',
        length: length
      };

      switch (code) {
        case 0:
          // AuthenticationOk
          break;

        case 3:
          // AuthenticationCleartextPassword
          if (message.length === 8) {
            message.name = 'authenticationCleartextPassword';
          }

          break;

        case 5:
          // AuthenticationMD5Password
          if (message.length === 12) {
            message.name = 'authenticationMD5Password';
            var salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length, salt);
          }

          break;

        case 10:
          // AuthenticationSASL
          message.name = 'authenticationSASL';
          message.mechanisms = [];
          var mechanism;

          do {
            mechanism = this.reader.cstring();

            if (mechanism) {
              message.mechanisms.push(mechanism);
            }
          } while (mechanism);

          break;

        case 11:
          // AuthenticationSASLContinue
          message.name = 'authenticationSASLContinue';
          message.data = this.reader.string(length - 8);
          break;

        case 12:
          // AuthenticationSASLFinal
          message.name = 'authenticationSASLFinal';
          message.data = this.reader.string(length - 8);
          break;

        default:
          throw new Error('Unknown authenticationOk message type ' + code);
      }

      return message;
    }
  }, {
    key: "parseErrorMessage",
    value: function parseErrorMessage(offset, length, bytes, name) {
      this.reader.setBuffer(offset, bytes);
      var fields = {};
      var fieldType = this.reader.string(1);

      while (fieldType !== '\0') {
        fields[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }

      var messageValue = fields.M;
      var message = name === 'notice' ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
      message.severity = fields.S;
      message.code = fields.C;
      message.detail = fields.D;
      message.hint = fields.H;
      message.position = fields.P;
      message.internalPosition = fields.p;
      message.internalQuery = fields.q;
      message.where = fields.W;
      message.schema = fields.s;
      message.table = fields.t;
      message.column = fields.c;
      message.dataType = fields.d;
      message.constraint = fields.n;
      message.file = fields.F;
      message.line = fields.L;
      message.routine = fields.R;
      return message;
    }
  }]);

  return Parser;
}();

exports.Parser = Parser;