"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BufferReader = void 0;
var emptyBuffer = Buffer.allocUnsafe(0);

var BufferReader =
/*#__PURE__*/
function () {
  function BufferReader() {
    var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    _classCallCheck(this, BufferReader);

    this.offset = offset;
    this.buffer = emptyBuffer; // TODO(bmc): support non-utf8 encoding?

    this.encoding = 'utf-8';
  }

  _createClass(BufferReader, [{
    key: "setBuffer",
    value: function setBuffer(offset, buffer) {
      this.offset = offset;
      this.buffer = buffer;
    }
  }, {
    key: "int16",
    value: function int16() {
      var result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
  }, {
    key: "byte",
    value: function byte() {
      var result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
  }, {
    key: "int32",
    value: function int32() {
      var result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
  }, {
    key: "string",
    value: function string(length) {
      var result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }, {
    key: "cstring",
    value: function cstring() {
      var start = this.offset;
      var end = start;

      while (this.buffer[end++] !== 0) {}

      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
  }, {
    key: "bytes",
    value: function bytes(length) {
      var result = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }]);

  return BufferReader;
}();

exports.BufferReader = BufferReader;