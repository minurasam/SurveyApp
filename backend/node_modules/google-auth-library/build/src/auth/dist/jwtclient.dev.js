"use strict"; // Copyright 2013 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JWT = void 0;

var gtoken_1 = require("gtoken");

var jwtaccess_1 = require("./jwtaccess");

var oauth2client_1 = require("./oauth2client");

var JWT =
/*#__PURE__*/
function (_oauth2client_1$OAuth) {
  _inherits(JWT, _oauth2client_1$OAuth);

  function JWT(optionsOrEmail, keyFile, key, scopes, subject, keyId) {
    var _this;

    _classCallCheck(this, JWT);

    var opts = optionsOrEmail && _typeof(optionsOrEmail) === 'object' ? optionsOrEmail : {
      email: optionsOrEmail,
      keyFile: keyFile,
      key: key,
      keyId: keyId,
      scopes: scopes,
      subject: subject
    };
    _this = _possibleConstructorReturn(this, _getPrototypeOf(JWT).call(this, {
      eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis,
      forceRefreshOnFailure: opts.forceRefreshOnFailure
    }));
    _this.email = opts.email;
    _this.keyFile = opts.keyFile;
    _this.key = opts.key;
    _this.keyId = opts.keyId;
    _this.scopes = opts.scopes;
    _this.subject = opts.subject;
    _this.additionalClaims = opts.additionalClaims;
    _this.credentials = {
      refresh_token: 'jwt-placeholder',
      expiry_date: 1
    };
    return _this;
  }
  /**
   * Creates a copy of the credential with the specified scopes.
   * @param scopes List of requested scopes or a single scope.
   * @return The cloned instance.
   */


  _createClass(JWT, [{
    key: "createScoped",
    value: function createScoped(scopes) {
      return new JWT({
        email: this.email,
        keyFile: this.keyFile,
        key: this.key,
        keyId: this.keyId,
        scopes: scopes,
        subject: this.subject,
        additionalClaims: this.additionalClaims
      });
    }
    /**
     * Obtains the metadata to be sent with the request.
     *
     * @param url the URI being authorized.
     */

  }, {
    key: "getRequestMetadataAsync",
    value: function getRequestMetadataAsync(url) {
      var _ref, tokens, headers;

      return regeneratorRuntime.async(function getRequestMetadataAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!this.apiKey && !this.hasUserScopes() && url)) {
                _context.next = 16;
                break;
              }

              if (!(this.additionalClaims && this.additionalClaims.target_audience)) {
                _context.next = 9;
                break;
              }

              _context.next = 4;
              return regeneratorRuntime.awrap(this.refreshToken());

            case 4:
              _ref = _context.sent;
              tokens = _ref.tokens;
              return _context.abrupt("return", {
                headers: this.addSharedMetadataHeaders({
                  Authorization: "Bearer ".concat(tokens.id_token)
                })
              });

            case 9:
              // no scopes have been set, but a uri has been provided. Use JWTAccess
              // credentials.
              if (!this.access) {
                this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);
              }

              _context.next = 12;
              return regeneratorRuntime.awrap(this.access.getRequestHeaders(url, this.additionalClaims));

            case 12:
              headers = _context.sent;
              return _context.abrupt("return", {
                headers: this.addSharedMetadataHeaders(headers)
              });

            case 14:
              _context.next = 21;
              break;

            case 16:
              if (!(this.hasAnyScopes() || this.apiKey)) {
                _context.next = 20;
                break;
              }

              return _context.abrupt("return", _get(_getPrototypeOf(JWT.prototype), "getRequestMetadataAsync", this).call(this, url));

            case 20:
              return _context.abrupt("return", {
                headers: {}
              });

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * Fetches an ID token.
     * @param targetAudience the audience for the fetched ID token.
     */

  }, {
    key: "fetchIdToken",
    value: function fetchIdToken(targetAudience) {
      var gtoken;
      return regeneratorRuntime.async(function fetchIdToken$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              // Create a new gToken for fetching an ID token
              gtoken = new gtoken_1.GoogleToken({
                iss: this.email,
                sub: this.subject,
                scope: this.scopes || this.defaultScopes,
                keyFile: this.keyFile,
                key: this.key,
                additionalClaims: {
                  target_audience: targetAudience
                }
              });
              _context2.next = 3;
              return regeneratorRuntime.awrap(gtoken.getToken({
                forceRefresh: true
              }));

            case 3:
              if (gtoken.idToken) {
                _context2.next = 5;
                break;
              }

              throw new Error('Unknown error: Failed to fetch ID token');

            case 5:
              return _context2.abrupt("return", gtoken.idToken);

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
    /**
     * Determine if there are currently scopes available.
     */

  }, {
    key: "hasUserScopes",
    value: function hasUserScopes() {
      if (!this.scopes) {
        return false;
      }

      return this.scopes.length > 0;
    }
    /**
     * Are there any default or user scopes defined.
     */

  }, {
    key: "hasAnyScopes",
    value: function hasAnyScopes() {
      if (this.scopes && this.scopes.length > 0) return true;
      if (this.defaultScopes && this.defaultScopes.length > 0) return true;
      return false;
    }
  }, {
    key: "authorize",
    value: function authorize(callback) {
      if (callback) {
        this.authorizeAsync().then(function (r) {
          return callback(null, r);
        }, callback);
      } else {
        return this.authorizeAsync();
      }
    }
  }, {
    key: "authorizeAsync",
    value: function authorizeAsync() {
      var result;
      return regeneratorRuntime.async(function authorizeAsync$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return regeneratorRuntime.awrap(this.refreshToken());

            case 2:
              result = _context3.sent;

              if (result) {
                _context3.next = 5;
                break;
              }

              throw new Error('No result returned');

            case 5:
              this.credentials = result.tokens;
              this.credentials.refresh_token = 'jwt-placeholder';
              this.key = this.gtoken.key;
              this.email = this.gtoken.iss;
              return _context3.abrupt("return", result.tokens);

            case 10:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
    /**
     * Refreshes the access token.
     * @param refreshToken ignored
     * @private
     */

  }, {
    key: "refreshTokenNoCache",
    value: function refreshTokenNoCache( // eslint-disable-next-line @typescript-eslint/no-unused-vars
    refreshToken) {
      var gtoken, token, tokens;
      return regeneratorRuntime.async(function refreshTokenNoCache$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              gtoken = this.createGToken();
              _context4.next = 3;
              return regeneratorRuntime.awrap(gtoken.getToken({
                forceRefresh: this.isTokenExpiring()
              }));

            case 3:
              token = _context4.sent;
              tokens = {
                access_token: token.access_token,
                token_type: 'Bearer',
                expiry_date: gtoken.expiresAt,
                id_token: gtoken.idToken
              };
              this.emit('tokens', tokens);
              return _context4.abrupt("return", {
                res: null,
                tokens: tokens
              });

            case 7:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
    /**
     * Create a gToken if it doesn't already exist.
     */

  }, {
    key: "createGToken",
    value: function createGToken() {
      if (!this.gtoken) {
        this.gtoken = new gtoken_1.GoogleToken({
          iss: this.email,
          sub: this.subject,
          scope: this.scopes || this.defaultScopes,
          keyFile: this.keyFile,
          key: this.key,
          additionalClaims: this.additionalClaims
        });
      }

      return this.gtoken;
    }
    /**
     * Create a JWT credentials instance using the given input options.
     * @param json The input object.
     */

  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      if (!json) {
        throw new Error('Must pass in a JSON object containing the service account auth settings.');
      }

      if (!json.client_email) {
        throw new Error('The incoming JSON object does not contain a client_email field');
      }

      if (!json.private_key) {
        throw new Error('The incoming JSON object does not contain a private_key field');
      } // Extract the relevant information from the json key file.


      this.email = json.client_email;
      this.key = json.private_key;
      this.keyId = json.private_key_id;
      this.projectId = json.project_id;
      this.quotaProjectId = json.quota_project_id;
    }
  }, {
    key: "fromStream",
    value: function fromStream(inputStream, callback) {
      if (callback) {
        this.fromStreamAsync(inputStream).then(function () {
          return callback();
        }, callback);
      } else {
        return this.fromStreamAsync(inputStream);
      }
    }
  }, {
    key: "fromStreamAsync",
    value: function fromStreamAsync(inputStream) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (!inputStream) {
          throw new Error('Must pass in a stream containing the service account auth settings.');
        }

        var s = '';
        inputStream.setEncoding('utf8').on('error', reject).on('data', function (chunk) {
          return s += chunk;
        }).on('end', function () {
          try {
            var data = JSON.parse(s);

            _this2.fromJSON(data);

            resolve();
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    /**
     * Creates a JWT credentials instance using an API Key for authentication.
     * @param apiKey The API Key in string form.
     */

  }, {
    key: "fromAPIKey",
    value: function fromAPIKey(apiKey) {
      if (typeof apiKey !== 'string') {
        throw new Error('Must provide an API Key string.');
      }

      this.apiKey = apiKey;
    }
    /**
     * Using the key or keyFile on the JWT client, obtain an object that contains
     * the key and the client email.
     */

  }, {
    key: "getCredentials",
    value: function getCredentials() {
      var gtoken, creds;
      return regeneratorRuntime.async(function getCredentials$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (!this.key) {
                _context5.next = 4;
                break;
              }

              return _context5.abrupt("return", {
                private_key: this.key,
                client_email: this.email
              });

            case 4:
              if (!this.keyFile) {
                _context5.next = 10;
                break;
              }

              gtoken = this.createGToken();
              _context5.next = 8;
              return regeneratorRuntime.awrap(gtoken.getCredentials(this.keyFile));

            case 8:
              creds = _context5.sent;
              return _context5.abrupt("return", {
                private_key: creds.privateKey,
                client_email: creds.clientEmail
              });

            case 10:
              throw new Error('A key or a keyFile must be provided to getCredentials.');

            case 11:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }]);

  return JWT;
}(oauth2client_1.OAuth2Client);

exports.JWT = JWT;