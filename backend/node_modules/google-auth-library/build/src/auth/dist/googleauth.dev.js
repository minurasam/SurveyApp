"use strict"; // Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;

var child_process_1 = require("child_process");

var fs = require("fs");

var gcpMetadata = require("gcp-metadata");

var os = require("os");

var path = require("path");

var crypto_1 = require("../crypto/crypto");

var transporters_1 = require("../transporters");

var computeclient_1 = require("./computeclient");

var idtokenclient_1 = require("./idtokenclient");

var envDetect_1 = require("./envDetect");

var jwtclient_1 = require("./jwtclient");

var refreshclient_1 = require("./refreshclient");

var externalclient_1 = require("./externalclient");

var baseexternalclient_1 = require("./baseexternalclient");

exports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';

var GoogleAuth =
/*#__PURE__*/
function () {
  function GoogleAuth(opts) {
    _classCallCheck(this, GoogleAuth);

    /**
     * Caches a value indicating whether the auth layer is running on Google
     * Compute Engine.
     * @private
     */
    this.checkIsGCE = undefined; // To save the contents of the JSON credential file

    this.jsonContent = null;
    this.cachedCredential = null;
    opts = opts || {};
    this._cachedProjectId = opts.projectId || null;
    this.keyFilename = opts.keyFilename || opts.keyFile;
    this.scopes = opts.scopes;
    this.jsonContent = opts.credentials || null;
    this.clientOptions = opts.clientOptions;
  } // Note:  this properly is only public to satisify unit tests.
  // https://github.com/Microsoft/TypeScript/issues/5228


  _createClass(GoogleAuth, [{
    key: "getProjectId",
    value: function getProjectId(callback) {
      if (callback) {
        this.getProjectIdAsync().then(function (r) {
          return callback(null, r);
        }, callback);
      } else {
        return this.getProjectIdAsync();
      }
    }
  }, {
    key: "getProjectIdAsync",
    value: function getProjectIdAsync() {
      var _this = this;

      if (this._cachedProjectId) {
        return Promise.resolve(this._cachedProjectId);
      } // In implicit case, supports three environments. In order of precedence,
      // the implicit environments are:
      // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable
      // - GOOGLE_APPLICATION_CREDENTIALS JSON file
      // - Cloud SDK: `gcloud config config-helper --format json`
      // - GCE project ID from metadata server)


      if (!this._getDefaultProjectIdPromise) {
        // TODO: refactor the below code so that it doesn't mix and match
        // promises and async/await.
        this._getDefaultProjectIdPromise = new Promise( // eslint-disable-next-line no-async-promise-executor
        function _callee(resolve, reject) {
          var projectId;
          return regeneratorRuntime.async(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.t3 = _this.getProductionProjectId();

                  if (_context.t3) {
                    _context.next = 6;
                    break;
                  }

                  _context.next = 5;
                  return regeneratorRuntime.awrap(_this.getFileProjectId());

                case 5:
                  _context.t3 = _context.sent;

                case 6:
                  _context.t2 = _context.t3;

                  if (_context.t2) {
                    _context.next = 11;
                    break;
                  }

                  _context.next = 10;
                  return regeneratorRuntime.awrap(_this.getDefaultServiceProjectId());

                case 10:
                  _context.t2 = _context.sent;

                case 11:
                  _context.t1 = _context.t2;

                  if (_context.t1) {
                    _context.next = 16;
                    break;
                  }

                  _context.next = 15;
                  return regeneratorRuntime.awrap(_this.getGCEProjectId());

                case 15:
                  _context.t1 = _context.sent;

                case 16:
                  _context.t0 = _context.t1;

                  if (_context.t0) {
                    _context.next = 21;
                    break;
                  }

                  _context.next = 20;
                  return regeneratorRuntime.awrap(_this.getExternalAccountClientProjectId());

                case 20:
                  _context.t0 = _context.sent;

                case 21:
                  projectId = _context.t0;
                  _this._cachedProjectId = projectId;

                  if (projectId) {
                    _context.next = 25;
                    break;
                  }

                  throw new Error('Unable to detect a Project Id in the current environment. \n' + 'To learn more about authentication and Google APIs, visit: \n' + 'https://cloud.google.com/docs/authentication/getting-started');

                case 25:
                  resolve(projectId);
                  _context.next = 31;
                  break;

                case 28:
                  _context.prev = 28;
                  _context.t4 = _context["catch"](0);
                  reject(_context.t4);

                case 31:
                case "end":
                  return _context.stop();
              }
            }
          }, null, null, [[0, 28]]);
        });
      }

      return this._getDefaultProjectIdPromise;
    }
    /**
     * @returns Any scopes (user-specified or default scopes specified by the
     *   client library) that need to be set on the current Auth client.
     */

  }, {
    key: "getAnyScopes",
    value: function getAnyScopes() {
      return this.scopes || this.defaultScopes;
    }
  }, {
    key: "getApplicationDefault",
    value: function getApplicationDefault() {
      var optionsOrCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;
      var options;

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
      } else {
        options = optionsOrCallback;
      }

      if (callback) {
        this.getApplicationDefaultAsync(options).then(function (r) {
          return callback(null, r.credential, r.projectId);
        }, callback);
      } else {
        return this.getApplicationDefaultAsync(options);
      }
    }
  }, {
    key: "getApplicationDefaultAsync",
    value: function getApplicationDefaultAsync() {
      var options,
          credential,
          projectId,
          isGCE,
          _args2 = arguments;
      return regeneratorRuntime.async(function getApplicationDefaultAsync$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};

              if (!this.cachedCredential) {
                _context2.next = 7;
                break;
              }

              _context2.t0 = this.cachedCredential;
              _context2.next = 5;
              return regeneratorRuntime.awrap(this.getProjectIdAsync());

            case 5:
              _context2.t1 = _context2.sent;
              return _context2.abrupt("return", {
                credential: _context2.t0,
                projectId: _context2.t1
              });

            case 7:
              _context2.next = 9;
              return regeneratorRuntime.awrap(this._tryGetApplicationCredentialsFromEnvironmentVariable(options));

            case 9:
              credential = _context2.sent;

              if (!credential) {
                _context2.next = 17;
                break;
              }

              if (credential instanceof jwtclient_1.JWT) {
                credential.defaultScopes = this.defaultScopes;
                credential.scopes = this.scopes;
              } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {
                credential.scopes = this.getAnyScopes();
              }

              this.cachedCredential = credential;
              _context2.next = 15;
              return regeneratorRuntime.awrap(this.getProjectId());

            case 15:
              projectId = _context2.sent;
              return _context2.abrupt("return", {
                credential: credential,
                projectId: projectId
              });

            case 17:
              _context2.next = 19;
              return regeneratorRuntime.awrap(this._tryGetApplicationCredentialsFromWellKnownFile(options));

            case 19:
              credential = _context2.sent;

              if (!credential) {
                _context2.next = 27;
                break;
              }

              if (credential instanceof jwtclient_1.JWT) {
                credential.defaultScopes = this.defaultScopes;
                credential.scopes = this.scopes;
              } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {
                credential.scopes = this.getAnyScopes();
              }

              this.cachedCredential = credential;
              _context2.next = 25;
              return regeneratorRuntime.awrap(this.getProjectId());

            case 25:
              projectId = _context2.sent;
              return _context2.abrupt("return", {
                credential: credential,
                projectId: projectId
              });

            case 27:
              _context2.prev = 27;
              _context2.next = 30;
              return regeneratorRuntime.awrap(this._checkIsGCE());

            case 30:
              isGCE = _context2.sent;
              _context2.next = 37;
              break;

            case 33:
              _context2.prev = 33;
              _context2.t2 = _context2["catch"](27);
              _context2.t2.message = "Unexpected error determining execution environment: ".concat(_context2.t2.message);
              throw _context2.t2;

            case 37:
              if (isGCE) {
                _context2.next = 39;
                break;
              }

              throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');

            case 39:
              // For GCE, just return a default ComputeClient. It will take care of
              // the rest.
              options.scopes = this.getAnyScopes();
              this.cachedCredential = new computeclient_1.Compute(options);
              _context2.next = 43;
              return regeneratorRuntime.awrap(this.getProjectId());

            case 43:
              projectId = _context2.sent;
              return _context2.abrupt("return", {
                projectId: projectId,
                credential: this.cachedCredential
              });

            case 45:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[27, 33]]);
    }
    /**
     * Determines whether the auth layer is running on Google Compute Engine.
     * @returns A promise that resolves with the boolean.
     * @api private
     */

  }, {
    key: "_checkIsGCE",
    value: function _checkIsGCE() {
      return regeneratorRuntime.async(function _checkIsGCE$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(this.checkIsGCE === undefined)) {
                _context3.next = 4;
                break;
              }

              _context3.next = 3;
              return regeneratorRuntime.awrap(gcpMetadata.isAvailable());

            case 3:
              this.checkIsGCE = _context3.sent;

            case 4:
              return _context3.abrupt("return", this.checkIsGCE);

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
    /**
     * Attempts to load default credentials from the environment variable path..
     * @returns Promise that resolves with the OAuth2Client or null.
     * @api private
     */

  }, {
    key: "_tryGetApplicationCredentialsFromEnvironmentVariable",
    value: function _tryGetApplicationCredentialsFromEnvironmentVariable(options) {
      var credentialsPath;
      return regeneratorRuntime.async(function _tryGetApplicationCredentialsFromEnvironmentVariable$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] || process.env['google_application_credentials'];

              if (!(!credentialsPath || credentialsPath.length === 0)) {
                _context4.next = 3;
                break;
              }

              return _context4.abrupt("return", null);

            case 3:
              _context4.prev = 3;
              return _context4.abrupt("return", this._getApplicationCredentialsFromFilePath(credentialsPath, options));

            case 7:
              _context4.prev = 7;
              _context4.t0 = _context4["catch"](3);
              _context4.t0.message = "Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ".concat(_context4.t0.message);
              throw _context4.t0;

            case 11:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this, [[3, 7]]);
    }
    /**
     * Attempts to load default credentials from a well-known file location
     * @return Promise that resolves with the OAuth2Client or null.
     * @api private
     */

  }, {
    key: "_tryGetApplicationCredentialsFromWellKnownFile",
    value: function _tryGetApplicationCredentialsFromWellKnownFile(options) {
      var location, home, client;
      return regeneratorRuntime.async(function _tryGetApplicationCredentialsFromWellKnownFile$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              // First, figure out the location of the file, depending upon the OS type.
              location = null;

              if (this._isWindows()) {
                // Windows
                location = process.env['APPDATA'];
              } else {
                // Linux or Mac
                home = process.env['HOME'];

                if (home) {
                  location = path.join(home, '.config');
                }
              } // If we found the root path, expand it.


              if (location) {
                location = path.join(location, 'gcloud', 'application_default_credentials.json');

                if (!fs.existsSync(location)) {
                  location = null;
                }
              } // The file does not exist.


              if (location) {
                _context5.next = 5;
                break;
              }

              return _context5.abrupt("return", null);

            case 5:
              _context5.next = 7;
              return regeneratorRuntime.awrap(this._getApplicationCredentialsFromFilePath(location, options));

            case 7:
              client = _context5.sent;
              return _context5.abrupt("return", client);

            case 9:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
    /**
     * Attempts to load default credentials from a file at the given path..
     * @param filePath The path to the file to read.
     * @returns Promise that resolves with the OAuth2Client
     * @api private
     */

  }, {
    key: "_getApplicationCredentialsFromFilePath",
    value: function _getApplicationCredentialsFromFilePath(filePath) {
      var options,
          readStream,
          _args6 = arguments;
      return regeneratorRuntime.async(function _getApplicationCredentialsFromFilePath$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};

              if (!(!filePath || filePath.length === 0)) {
                _context6.next = 3;
                break;
              }

              throw new Error('The file path is invalid.');

            case 3:
              _context6.prev = 3;
              // Resolve path to actual file in case of symlink. Expect a thrown error
              // if not resolvable.
              filePath = fs.realpathSync(filePath);

              if (fs.lstatSync(filePath).isFile()) {
                _context6.next = 7;
                break;
              }

              throw new Error();

            case 7:
              _context6.next = 13;
              break;

            case 9:
              _context6.prev = 9;
              _context6.t0 = _context6["catch"](3);
              _context6.t0.message = "The file at ".concat(filePath, " does not exist, or it is not a file. ").concat(_context6.t0.message);
              throw _context6.t0;

            case 13:
              // Now open a read stream on the file, and parse it.
              readStream = fs.createReadStream(filePath);
              return _context6.abrupt("return", this.fromStream(readStream, options));

            case 15:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this, [[3, 9]]);
    }
    /**
     * Create a credentials instance using the given input options.
     * @param json The input object.
     * @param options The JWT or UserRefresh options for the client
     * @returns JWT or UserRefresh Client with data
     */

  }, {
    key: "fromJSON",
    value: function fromJSON(json, options) {
      var client;

      if (!json) {
        throw new Error('Must pass in a JSON object containing the Google auth settings.');
      }

      options = options || {};

      if (json.type === 'authorized_user') {
        client = new refreshclient_1.UserRefreshClient(options);
        client.fromJSON(json);
      } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
        client = externalclient_1.ExternalAccountClient.fromJSON(json, options);
        client.scopes = this.getAnyScopes();
      } else {
        options.scopes = this.scopes;
        client = new jwtclient_1.JWT(options);
        client.defaultScopes = this.defaultScopes;
        client.fromJSON(json);
      }

      return client;
    }
    /**
     * Return a JWT or UserRefreshClient from JavaScript object, caching both the
     * object used to instantiate and the client.
     * @param json The input object.
     * @param options The JWT or UserRefresh options for the client
     * @returns JWT or UserRefresh Client with data
     */

  }, {
    key: "_cacheClientFromJSON",
    value: function _cacheClientFromJSON(json, options) {
      var client; // create either a UserRefreshClient or JWT client.

      options = options || {};

      if (json.type === 'authorized_user') {
        client = new refreshclient_1.UserRefreshClient(options);
        client.fromJSON(json);
      } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
        client = externalclient_1.ExternalAccountClient.fromJSON(json, options);
        client.scopes = this.getAnyScopes();
      } else {
        options.scopes = this.scopes;
        client = new jwtclient_1.JWT(options);
        client.defaultScopes = this.defaultScopes;
        client.fromJSON(json);
      } // cache both raw data used to instantiate client and client itself.


      this.jsonContent = json;
      this.cachedCredential = client;
      return this.cachedCredential;
    }
  }, {
    key: "fromStream",
    value: function fromStream(inputStream) {
      var optionsOrCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var callback = arguments.length > 2 ? arguments[2] : undefined;
      var options = {};

      if (typeof optionsOrCallback === 'function') {
        callback = optionsOrCallback;
      } else {
        options = optionsOrCallback;
      }

      if (callback) {
        this.fromStreamAsync(inputStream, options).then(function (r) {
          return callback(null, r);
        }, callback);
      } else {
        return this.fromStreamAsync(inputStream, options);
      }
    }
  }, {
    key: "fromStreamAsync",
    value: function fromStreamAsync(inputStream, options) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (!inputStream) {
          throw new Error('Must pass in a stream containing the Google auth settings.');
        }

        var s = '';
        inputStream.setEncoding('utf8').on('error', reject).on('data', function (chunk) {
          return s += chunk;
        }).on('end', function () {
          try {
            try {
              var data = JSON.parse(s);

              var r = _this2._cacheClientFromJSON(data, options);

              return resolve(r);
            } catch (err) {
              // If we failed parsing this.keyFileName, assume that it
              // is a PEM or p12 certificate:
              if (!_this2.keyFilename) throw err;
              var client = new jwtclient_1.JWT(_objectSpread({}, _this2.clientOptions, {
                keyFile: _this2.keyFilename
              }));
              _this2.cachedCredential = client;
              return resolve(client);
            }
          } catch (err) {
            return reject(err);
          }
        });
      });
    }
    /**
     * Create a credentials instance using the given API key string.
     * @param apiKey The API key string
     * @param options An optional options object.
     * @returns A JWT loaded from the key
     */

  }, {
    key: "fromAPIKey",
    value: function fromAPIKey(apiKey, options) {
      options = options || {};
      var client = new jwtclient_1.JWT(options);
      client.fromAPIKey(apiKey);
      return client;
    }
    /**
     * Determines whether the current operating system is Windows.
     * @api private
     */

  }, {
    key: "_isWindows",
    value: function _isWindows() {
      var sys = os.platform();

      if (sys && sys.length >= 3) {
        if (sys.substring(0, 3).toLowerCase() === 'win') {
          return true;
        }
      }

      return false;
    }
    /**
     * Run the Google Cloud SDK command that prints the default project ID
     */

  }, {
    key: "getDefaultServiceProjectId",
    value: function getDefaultServiceProjectId() {
      return regeneratorRuntime.async(function getDefaultServiceProjectId$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              return _context7.abrupt("return", new Promise(function (resolve) {
                child_process_1.exec('gcloud config config-helper --format json', function (err, stdout) {
                  if (!err && stdout) {
                    try {
                      var projectId = JSON.parse(stdout).configuration.properties.core.project;
                      resolve(projectId);
                      return;
                    } catch (e) {// ignore errors
                    }
                  }

                  resolve(null);
                });
              }));

            case 1:
            case "end":
              return _context7.stop();
          }
        }
      });
    }
    /**
     * Loads the project id from environment variables.
     * @api private
     */

  }, {
    key: "getProductionProjectId",
    value: function getProductionProjectId() {
      return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'] || process.env['gcloud_project'] || process.env['google_cloud_project'];
    }
    /**
     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.
     * @api private
     */

  }, {
    key: "getFileProjectId",
    value: function getFileProjectId() {
      var creds, r;
      return regeneratorRuntime.async(function getFileProjectId$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (!this.cachedCredential) {
                _context8.next = 2;
                break;
              }

              return _context8.abrupt("return", this.cachedCredential.projectId);

            case 2:
              if (!this.keyFilename) {
                _context8.next = 8;
                break;
              }

              _context8.next = 5;
              return regeneratorRuntime.awrap(this.getClient());

            case 5:
              creds = _context8.sent;

              if (!(creds && creds.projectId)) {
                _context8.next = 8;
                break;
              }

              return _context8.abrupt("return", creds.projectId);

            case 8:
              _context8.next = 10;
              return regeneratorRuntime.awrap(this._tryGetApplicationCredentialsFromEnvironmentVariable());

            case 10:
              r = _context8.sent;

              if (!r) {
                _context8.next = 15;
                break;
              }

              return _context8.abrupt("return", r.projectId);

            case 15:
              return _context8.abrupt("return", null);

            case 16:
            case "end":
              return _context8.stop();
          }
        }
      }, null, this);
    }
    /**
     * Gets the project ID from external account client if available.
     */

  }, {
    key: "getExternalAccountClientProjectId",
    value: function getExternalAccountClientProjectId() {
      var creds;
      return regeneratorRuntime.async(function getExternalAccountClientProjectId$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (!(!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE)) {
                _context9.next = 2;
                break;
              }

              return _context9.abrupt("return", null);

            case 2:
              _context9.next = 4;
              return regeneratorRuntime.awrap(this.getClient());

            case 4:
              creds = _context9.sent;
              _context9.next = 7;
              return regeneratorRuntime.awrap(creds.getProjectId());

            case 7:
              return _context9.abrupt("return", _context9.sent);

            case 8:
            case "end":
              return _context9.stop();
          }
        }
      }, null, this);
    }
    /**
     * Gets the Compute Engine project ID if it can be inferred.
     */

  }, {
    key: "getGCEProjectId",
    value: function getGCEProjectId() {
      var r;
      return regeneratorRuntime.async(function getGCEProjectId$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.prev = 0;
              _context10.next = 3;
              return regeneratorRuntime.awrap(gcpMetadata.project('project-id'));

            case 3:
              r = _context10.sent;
              return _context10.abrupt("return", r);

            case 7:
              _context10.prev = 7;
              _context10.t0 = _context10["catch"](0);
              return _context10.abrupt("return", null);

            case 10:
            case "end":
              return _context10.stop();
          }
        }
      }, null, null, [[0, 7]]);
    }
  }, {
    key: "getCredentials",
    value: function getCredentials(callback) {
      if (callback) {
        this.getCredentialsAsync().then(function (r) {
          return callback(null, r);
        }, callback);
      } else {
        return this.getCredentialsAsync();
      }
    }
  }, {
    key: "getCredentialsAsync",
    value: function getCredentialsAsync() {
      var credential, isGCE, data;
      return regeneratorRuntime.async(function getCredentialsAsync$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return regeneratorRuntime.awrap(this.getClient());

            case 2:
              if (!this.jsonContent) {
                _context11.next = 5;
                break;
              }

              credential = {
                client_email: this.jsonContent.client_email,
                private_key: this.jsonContent.private_key
              };
              return _context11.abrupt("return", credential);

            case 5:
              _context11.next = 7;
              return regeneratorRuntime.awrap(this._checkIsGCE());

            case 7:
              isGCE = _context11.sent;

              if (isGCE) {
                _context11.next = 10;
                break;
              }

              throw new Error('Unknown error.');

            case 10:
              _context11.next = 12;
              return regeneratorRuntime.awrap(gcpMetadata.instance({
                property: 'service-accounts/',
                params: {
                  recursive: 'true'
                }
              }));

            case 12:
              data = _context11.sent;

              if (!(!data || !data["default"] || !data["default"].email)) {
                _context11.next = 15;
                break;
              }

              throw new Error('Failure from metadata server.');

            case 15:
              return _context11.abrupt("return", {
                client_email: data["default"].email
              });

            case 16:
            case "end":
              return _context11.stop();
          }
        }
      }, null, this);
    }
    /**
     * Automatically obtain a client based on the provided configuration.  If no
     * options were passed, use Application Default Credentials.
     */

  }, {
    key: "getClient",
    value: function getClient(options) {
      var filePath, stream;
      return regeneratorRuntime.async(function getClient$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              if (!options) {
                _context12.next = 2;
                break;
              }

              throw new Error('Passing options to getClient is forbidden in v5.0.0. Use new GoogleAuth(opts) instead.');

            case 2:
              if (this.cachedCredential) {
                _context12.next = 16;
                break;
              }

              if (!this.jsonContent) {
                _context12.next = 7;
                break;
              }

              this._cacheClientFromJSON(this.jsonContent, this.clientOptions);

              _context12.next = 16;
              break;

            case 7:
              if (!this.keyFilename) {
                _context12.next = 14;
                break;
              }

              filePath = path.resolve(this.keyFilename);
              stream = fs.createReadStream(filePath);
              _context12.next = 12;
              return regeneratorRuntime.awrap(this.fromStreamAsync(stream, this.clientOptions));

            case 12:
              _context12.next = 16;
              break;

            case 14:
              _context12.next = 16;
              return regeneratorRuntime.awrap(this.getApplicationDefaultAsync(this.clientOptions));

            case 16:
              return _context12.abrupt("return", this.cachedCredential);

            case 17:
            case "end":
              return _context12.stop();
          }
        }
      }, null, this);
    }
    /**
     * Creates a client which will fetch an ID token for authorization.
     * @param targetAudience the audience for the fetched ID token.
     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.
     */

  }, {
    key: "getIdTokenClient",
    value: function getIdTokenClient(targetAudience) {
      var client;
      return regeneratorRuntime.async(function getIdTokenClient$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return regeneratorRuntime.awrap(this.getClient());

            case 2:
              client = _context13.sent;

              if ('fetchIdToken' in client) {
                _context13.next = 5;
                break;
              }

              throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');

            case 5:
              return _context13.abrupt("return", new idtokenclient_1.IdTokenClient({
                targetAudience: targetAudience,
                idTokenProvider: client
              }));

            case 6:
            case "end":
              return _context13.stop();
          }
        }
      }, null, this);
    }
    /**
     * Automatically obtain application default credentials, and return
     * an access token for making requests.
     */

  }, {
    key: "getAccessToken",
    value: function getAccessToken() {
      var client;
      return regeneratorRuntime.async(function getAccessToken$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return regeneratorRuntime.awrap(this.getClient());

            case 2:
              client = _context14.sent;
              _context14.next = 5;
              return regeneratorRuntime.awrap(client.getAccessToken());

            case 5:
              return _context14.abrupt("return", _context14.sent.token);

            case 6:
            case "end":
              return _context14.stop();
          }
        }
      }, null, this);
    }
    /**
     * Obtain the HTTP headers that will provide authorization for a given
     * request.
     */

  }, {
    key: "getRequestHeaders",
    value: function getRequestHeaders(url) {
      var client;
      return regeneratorRuntime.async(function getRequestHeaders$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              _context15.next = 2;
              return regeneratorRuntime.awrap(this.getClient());

            case 2:
              client = _context15.sent;
              return _context15.abrupt("return", client.getRequestHeaders(url));

            case 4:
            case "end":
              return _context15.stop();
          }
        }
      }, null, this);
    }
    /**
     * Obtain credentials for a request, then attach the appropriate headers to
     * the request options.
     * @param opts Axios or Request options on which to attach the headers
     */

  }, {
    key: "authorizeRequest",
    value: function authorizeRequest(opts) {
      var url, client, headers;
      return regeneratorRuntime.async(function authorizeRequest$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              opts = opts || {};
              url = opts.url || opts.uri;
              _context16.next = 4;
              return regeneratorRuntime.awrap(this.getClient());

            case 4:
              client = _context16.sent;
              _context16.next = 7;
              return regeneratorRuntime.awrap(client.getRequestHeaders(url));

            case 7:
              headers = _context16.sent;
              opts.headers = Object.assign(opts.headers || {}, headers);
              return _context16.abrupt("return", opts);

            case 10:
            case "end":
              return _context16.stop();
          }
        }
      }, null, this);
    }
    /**
     * Automatically obtain application default credentials, and make an
     * HTTP request using the given options.
     * @param opts Axios request options for the HTTP request.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any

  }, {
    key: "request",
    value: function request(opts) {
      var client;
      return regeneratorRuntime.async(function request$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return regeneratorRuntime.awrap(this.getClient());

            case 2:
              client = _context17.sent;
              return _context17.abrupt("return", client.request(opts));

            case 4:
            case "end":
              return _context17.stop();
          }
        }
      }, null, this);
    }
    /**
     * Determine the compute environment in which the code is running.
     */

  }, {
    key: "getEnv",
    value: function getEnv() {
      return envDetect_1.getEnv();
    }
    /**
     * Sign the given data with the current private key, or go out
     * to the IAM API to sign it.
     * @param data The data to be signed.
     */

  }, {
    key: "sign",
    value: function sign(data) {
      var client, crypto, sign, projectId, creds, url, res;
      return regeneratorRuntime.async(function sign$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              _context18.next = 2;
              return regeneratorRuntime.awrap(this.getClient());

            case 2:
              client = _context18.sent;
              crypto = crypto_1.createCrypto();

              if (!(client instanceof jwtclient_1.JWT && client.key)) {
                _context18.next = 9;
                break;
              }

              _context18.next = 7;
              return regeneratorRuntime.awrap(crypto.sign(client.key, data));

            case 7:
              sign = _context18.sent;
              return _context18.abrupt("return", sign);

            case 9:
              _context18.next = 11;
              return regeneratorRuntime.awrap(this.getProjectId());

            case 11:
              projectId = _context18.sent;

              if (projectId) {
                _context18.next = 14;
                break;
              }

              throw new Error('Cannot sign data without a project ID.');

            case 14:
              _context18.next = 16;
              return regeneratorRuntime.awrap(this.getCredentials());

            case 16:
              creds = _context18.sent;

              if (creds.client_email) {
                _context18.next = 19;
                break;
              }

              throw new Error('Cannot sign data without `client_email`.');

            case 19:
              url = "https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/".concat(creds.client_email, ":signBlob");
              _context18.next = 22;
              return regeneratorRuntime.awrap(this.request({
                method: 'POST',
                url: url,
                data: {
                  payload: crypto.encodeBase64StringUtf8(data)
                }
              }));

            case 22:
              res = _context18.sent;
              return _context18.abrupt("return", res.data.signedBlob);

            case 24:
            case "end":
              return _context18.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "isGCE",
    get: function get() {
      return this.checkIsGCE;
    }
  }]);

  return GoogleAuth;
}();

exports.GoogleAuth = GoogleAuth;
/**
 * Export DefaultTransporter as a static property of the class.
 */

GoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;