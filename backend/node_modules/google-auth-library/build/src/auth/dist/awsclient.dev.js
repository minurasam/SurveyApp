"use strict"; // Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AwsClient = void 0;

var awsrequestsigner_1 = require("./awsrequestsigner");

var baseexternalclient_1 = require("./baseexternalclient");
/**
 * AWS external account client. This is used for AWS workloads, where
 * AWS STS GetCallerIdentity serialized signed requests are exchanged for
 * GCP access token.
 */


var AwsClient =
/*#__PURE__*/
function (_baseexternalclient_) {
  _inherits(AwsClient, _baseexternalclient_);

  /**
   * Instantiates an AwsClient instance using the provided JSON
   * object loaded from an external account credentials file.
   * An error is thrown if the credential is not a valid AWS credential.
   * @param options The external account options object typically loaded
   *   from the external account JSON credential file.
   * @param additionalOptions Optional additional behavior customization
   *   options. These currently customize expiration threshold time and
   *   whether to retry on 401/403 API request errors.
   */
  function AwsClient(options, additionalOptions) {
    var _this;

    _classCallCheck(this, AwsClient);

    var _a;

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AwsClient).call(this, options, additionalOptions));
    _this.environmentId = options.credential_source.environment_id; // This is only required if the AWS region is not available in the
    // AWS_REGION or AWS_DEFAULT_REGION environment variables.

    _this.regionUrl = options.credential_source.region_url; // This is only required if AWS security credentials are not available in
    // environment variables.

    _this.securityCredentialsUrl = options.credential_source.url;
    _this.regionalCredVerificationUrl = options.credential_source.regional_cred_verification_url;
    var match = (_a = _this.environmentId) === null || _a === void 0 ? void 0 : _a.match(/^(aws)(\d+)$/);

    if (!match || !_this.regionalCredVerificationUrl) {
      throw new Error('No valid AWS "credential_source" provided');
    } else if (parseInt(match[2], 10) !== 1) {
      throw new Error("aws version \"".concat(match[2], "\" is not supported in the current build."));
    }

    _this.awsRequestSigner = null;
    _this.region = '';
    return _this;
  }
  /**
   * Triggered when an external subject token is needed to be exchanged for a
   * GCP access token via GCP STS endpoint.
   * This uses the `options.credential_source` object to figure out how
   * to retrieve the token using the current environment. In this case,
   * this uses a serialized AWS signed request to the STS GetCallerIdentity
   * endpoint.
   * The logic is summarized as:
   * 1. Retrieve AWS region from availability-zone.
   * 2a. Check AWS credentials in environment variables. If not found, get
   *     from security-credentials endpoint.
   * 2b. Get AWS credentials from security-credentials endpoint. In order
   *     to retrieve this, the AWS role needs to be determined by calling
   *     security-credentials endpoint without any argument. Then the
   *     credentials can be retrieved via: security-credentials/role_name
   * 3. Generate the signed request to AWS STS GetCallerIdentity action.
   * 4. Inject x-goog-cloud-target-resource into header and serialize the
   *    signed request. This will be the subject-token to pass to GCP STS.
   * @return A promise that resolves with the external subject token.
   */


  _createClass(AwsClient, [{
    key: "retrieveSubjectToken",
    value: function retrieveSubjectToken() {
      var _this2 = this;

      var options, reformattedHeader, extendedHeaders, key;
      return regeneratorRuntime.async(function retrieveSubjectToken$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (this.awsRequestSigner) {
                _context2.next = 5;
                break;
              }

              _context2.next = 3;
              return regeneratorRuntime.awrap(this.getAwsRegion());

            case 3:
              this.region = _context2.sent;
              this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(function _callee() {
                var roleName, awsCreds;
                return regeneratorRuntime.async(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (!(process.env['AWS_ACCESS_KEY_ID'] && process.env['AWS_SECRET_ACCESS_KEY'])) {
                          _context.next = 2;
                          break;
                        }

                        return _context.abrupt("return", {
                          accessKeyId: process.env['AWS_ACCESS_KEY_ID'],
                          secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'],
                          // This is normally not available for permanent credentials.
                          token: process.env['AWS_SESSION_TOKEN']
                        });

                      case 2:
                        _context.next = 4;
                        return regeneratorRuntime.awrap(_this2.getAwsRoleName());

                      case 4:
                        roleName = _context.sent;
                        _context.next = 7;
                        return regeneratorRuntime.awrap(_this2.getAwsSecurityCredentials(roleName));

                      case 7:
                        awsCreds = _context.sent;
                        return _context.abrupt("return", {
                          accessKeyId: awsCreds.AccessKeyId,
                          secretAccessKey: awsCreds.SecretAccessKey,
                          token: awsCreds.Token
                        });

                      case 9:
                      case "end":
                        return _context.stop();
                    }
                  }
                });
              }, this.region);

            case 5:
              _context2.next = 7;
              return regeneratorRuntime.awrap(this.awsRequestSigner.getRequestOptions({
                url: this.regionalCredVerificationUrl.replace('{region}', this.region),
                method: 'POST'
              }));

            case 7:
              options = _context2.sent;
              // The GCP STS endpoint expects the headers to be formatted as:
              // [
              //   {key: 'x-amz-date', value: '...'},
              //   {key: 'Authorization', value: '...'},
              //   ...
              // ]
              // And then serialized as:
              // encodeURIComponent(JSON.stringify({
              //   url: '...',
              //   method: 'POST',
              //   headers: [{key: 'x-amz-date', value: '...'}, ...]
              // }))
              reformattedHeader = [];
              extendedHeaders = Object.assign({
                // The full, canonical resource name of the workload identity pool
                // provider, with or without the HTTPS prefix.
                // Including this header as part of the signature is recommended to
                // ensure data integrity.
                'x-goog-cloud-target-resource': this.audience
              }, options.headers); // Reformat header to GCP STS expected format.

              for (key in extendedHeaders) {
                reformattedHeader.push({
                  key: key,
                  value: extendedHeaders[key]
                });
              } // Serialize the reformatted signed request.


              return _context2.abrupt("return", encodeURIComponent(JSON.stringify({
                url: options.url,
                method: options.method,
                headers: reformattedHeader
              })));

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
    /**
     * @return A promise that resolves with the current AWS region.
     */

  }, {
    key: "getAwsRegion",
    value: function getAwsRegion() {
      var opts, response;
      return regeneratorRuntime.async(function getAwsRegion$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION'])) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION']);

            case 2:
              if (this.regionUrl) {
                _context3.next = 4;
                break;
              }

              throw new Error('Unable to determine AWS region due to missing ' + '"options.credential_source.region_url"');

            case 4:
              opts = {
                url: this.regionUrl,
                method: 'GET',
                responseType: 'text'
              };
              _context3.next = 7;
              return regeneratorRuntime.awrap(this.transporter.request(opts));

            case 7:
              response = _context3.sent;
              return _context3.abrupt("return", response.data.substr(0, response.data.length - 1));

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
    /**
     * @return A promise that resolves with the assigned role to the current
     *   AWS VM. This is needed for calling the security-credentials endpoint.
     */

  }, {
    key: "getAwsRoleName",
    value: function getAwsRoleName() {
      var opts, response;
      return regeneratorRuntime.async(function getAwsRoleName$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (this.securityCredentialsUrl) {
                _context4.next = 2;
                break;
              }

              throw new Error('Unable to determine AWS role name due to missing ' + '"options.credential_source.url"');

            case 2:
              opts = {
                url: this.securityCredentialsUrl,
                method: 'GET',
                responseType: 'text'
              };
              _context4.next = 5;
              return regeneratorRuntime.awrap(this.transporter.request(opts));

            case 5:
              response = _context4.sent;
              return _context4.abrupt("return", response.data);

            case 7:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
    /**
     * Retrieves the temporary AWS credentials by calling the security-credentials
     * endpoint as specified in the `credential_source` object.
     * @param roleName The role attached to the current VM.
     * @return A promise that resolves with the temporary AWS credentials
     *   needed for creating the GetCallerIdentity signed request.
     */

  }, {
    key: "getAwsSecurityCredentials",
    value: function getAwsSecurityCredentials(roleName) {
      var response;
      return regeneratorRuntime.async(function getAwsSecurityCredentials$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return regeneratorRuntime.awrap(this.transporter.request({
                url: "".concat(this.securityCredentialsUrl, "/").concat(roleName),
                responseType: 'json'
              }));

            case 2:
              response = _context5.sent;
              return _context5.abrupt("return", response.data);

            case 4:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }]);

  return AwsClient;
}(baseexternalclient_1.BaseExternalAccountClient);

exports.AwsClient = AwsClient;