"use strict"; // Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;

var stream = require("stream");

var authclient_1 = require("./authclient");

var sts = require("./stscredentials");
/**
 * The required token exchange grant_type: rfc8693#section-2.1
 */


var STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';
/**
 * The requested token exchange requested_token_type: rfc8693#section-2.1
 */

var STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';
/** The default OAuth scope to request when none is provided. */

var DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';
/**
 * Offset to take into account network delays and server clock skews.
 */

exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;
/**
 * The credentials JSON file type for external account clients.
 * There are 3 types of JSON configs:
 * 1. authorized_user => Google end user credential
 * 2. service_account => Google service account credential
 * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)
 */

exports.EXTERNAL_ACCOUNT_TYPE = 'external_account';
/** Cloud resource manager URL used to retrieve project information. */

exports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';
/**
 * Base external account client. This is used to instantiate AuthClients for
 * exchanging external account credentials for GCP access token and authorizing
 * requests to GCP APIs.
 * The base class implements common logic for exchanging various type of
 * external credentials for GCP access token. The logic of determining and
 * retrieving the external credential based on the environment and
 * credential_source will be left for the subclasses.
 */

var BaseExternalAccountClient =
/*#__PURE__*/
function (_authclient_1$AuthCli) {
  _inherits(BaseExternalAccountClient, _authclient_1$AuthCli);

  /**
   * Instantiate a BaseExternalAccountClient instance using the provided JSON
   * object loaded from an external account credentials file.
   * @param options The external account options object typically loaded
   *   from the external account JSON credential file.
   * @param additionalOptions Optional additional behavior customization
   *   options. These currently customize expiration threshold time and
   *   whether to retry on 401/403 API request errors.
   */
  function BaseExternalAccountClient(options, additionalOptions) {
    var _this;

    _classCallCheck(this, BaseExternalAccountClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseExternalAccountClient).call(this));

    if (options.type !== exports.EXTERNAL_ACCOUNT_TYPE) {
      throw new Error("Expected \"".concat(exports.EXTERNAL_ACCOUNT_TYPE, "\" type but ") + "received \"".concat(options.type, "\""));
    }

    var clientAuth = options.client_id ? {
      confidentialClientType: 'basic',
      clientId: options.client_id,
      clientSecret: options.client_secret
    } : undefined;
    _this.stsCredential = new sts.StsCredentials(options.token_url, clientAuth); // Default OAuth scope. This could be overridden via public property.

    _this.scopes = [DEFAULT_OAUTH_SCOPE];
    _this.cachedAccessToken = null;
    _this.audience = options.audience;
    _this.subjectTokenType = options.subject_token_type;
    _this.quotaProjectId = options.quota_project_id;
    _this.serviceAccountImpersonationUrl = options.service_account_impersonation_url; // As threshold could be zero,
    // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the
    // zero value.

    if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {
      _this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;
    } else {
      _this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;
    }

    _this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);
    _this.projectId = null;
    _this.projectNumber = _this.getProjectNumber(_this.audience);
    return _this;
  }
  /**
   * Provides a mechanism to inject GCP access tokens directly.
   * When the provided credential expires, a new credential, using the
   * external account options, is retrieved.
   * @param credentials The Credentials object to set on the current client.
   */


  _createClass(BaseExternalAccountClient, [{
    key: "setCredentials",
    value: function setCredentials(credentials) {
      _get(_getPrototypeOf(BaseExternalAccountClient.prototype), "setCredentials", this).call(this, credentials);

      this.cachedAccessToken = credentials;
    }
    /**
     * @return A promise that resolves with the current GCP access token
     *   response. If the current credential is expired, a new one is retrieved.
     */

  }, {
    key: "getAccessToken",
    value: function getAccessToken() {
      return regeneratorRuntime.async(function getAccessToken$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!this.cachedAccessToken || this.isExpired(this.cachedAccessToken))) {
                _context.next = 3;
                break;
              }

              _context.next = 3;
              return regeneratorRuntime.awrap(this.refreshAccessTokenAsync());

            case 3:
              return _context.abrupt("return", {
                token: this.cachedAccessToken.access_token,
                res: this.cachedAccessToken.res
              });

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * The main authentication interface. It takes an optional url which when
     * present is the endpoint> being accessed, and returns a Promise which
     * resolves with authorization header fields.
     *
     * The result has the form:
     * { Authorization: 'Bearer <access_token_value>' }
     */

  }, {
    key: "getRequestHeaders",
    value: function getRequestHeaders() {
      var accessTokenResponse, headers;
      return regeneratorRuntime.async(function getRequestHeaders$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return regeneratorRuntime.awrap(this.getAccessToken());

            case 2:
              accessTokenResponse = _context2.sent;
              headers = {
                Authorization: "Bearer ".concat(accessTokenResponse.token)
              };
              return _context2.abrupt("return", this.addSharedMetadataHeaders(headers));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "request",
    value: function request(opts, callback) {
      if (callback) {
        this.requestAsync(opts).then(function (r) {
          return callback(null, r);
        }, function (e) {
          return callback(e, e.response);
        });
      } else {
        return this.requestAsync(opts);
      }
    }
    /**
     * @return A promise that resolves with the project ID corresponding to the
     *   current workload identity pool. When not determinable, this resolves with
     *   null.
     *   This is introduced to match the current pattern of using the Auth
     *   library:
     *   const projectId = await auth.getProjectId();
     *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;
     *   const res = await client.request({ url });
     *   The resource may not have permission
     *   (resourcemanager.projects.get) to call this API or the required
     *   scopes may not be selected:
     *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes
     */

  }, {
    key: "getProjectId",
    value: function getProjectId() {
      var headers, response;
      return regeneratorRuntime.async(function getProjectId$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!this.projectId) {
                _context3.next = 4;
                break;
              }

              return _context3.abrupt("return", this.projectId);

            case 4:
              if (!this.projectNumber) {
                _context3.next = 13;
                break;
              }

              _context3.next = 7;
              return regeneratorRuntime.awrap(this.getRequestHeaders());

            case 7:
              headers = _context3.sent;
              _context3.next = 10;
              return regeneratorRuntime.awrap(this.transporter.request({
                headers: headers,
                url: "".concat(exports.CLOUD_RESOURCE_MANAGER).concat(this.projectNumber),
                responseType: 'json'
              }));

            case 10:
              response = _context3.sent;
              this.projectId = response.data.projectId;
              return _context3.abrupt("return", this.projectId);

            case 13:
              return _context3.abrupt("return", null);

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
    /**
     * Authenticates the provided HTTP request, processes it and resolves with the
     * returned response.
     * @param opts The HTTP request options.
     * @param retry Whether the current attempt is a retry after a failed attempt.
     * @return A promise that resolves with the successful response.
     */

  }, {
    key: "requestAsync",
    value: function requestAsync(opts) {
      var retry,
          response,
          requestHeaders,
          res,
          statusCode,
          isReadableStream,
          isAuthErr,
          _args4 = arguments;
      return regeneratorRuntime.async(function requestAsync$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              retry = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : false;
              _context4.prev = 1;
              _context4.next = 4;
              return regeneratorRuntime.awrap(this.getRequestHeaders());

            case 4:
              requestHeaders = _context4.sent;
              opts.headers = opts.headers || {};

              if (requestHeaders && requestHeaders['x-goog-user-project']) {
                opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];
              }

              if (requestHeaders && requestHeaders.Authorization) {
                opts.headers.Authorization = requestHeaders.Authorization;
              }

              _context4.next = 10;
              return regeneratorRuntime.awrap(this.transporter.request(opts));

            case 10:
              response = _context4.sent;
              _context4.next = 27;
              break;

            case 13:
              _context4.prev = 13;
              _context4.t0 = _context4["catch"](1);
              res = _context4.t0.response;

              if (!res) {
                _context4.next = 26;
                break;
              }

              statusCode = res.status; // Retry the request for metadata if the following criteria are true:
              // - We haven't already retried.  It only makes sense to retry once.
              // - The response was a 401 or a 403
              // - The request didn't send a readableStream
              // - forceRefreshOnFailure is true

              isReadableStream = res.config.data instanceof stream.Readable;
              isAuthErr = statusCode === 401 || statusCode === 403;

              if (!(!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure)) {
                _context4.next = 26;
                break;
              }

              _context4.next = 23;
              return regeneratorRuntime.awrap(this.refreshAccessTokenAsync());

            case 23:
              _context4.next = 25;
              return regeneratorRuntime.awrap(this.requestAsync(opts, true));

            case 25:
              return _context4.abrupt("return", _context4.sent);

            case 26:
              throw _context4.t0;

            case 27:
              return _context4.abrupt("return", response);

            case 28:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this, [[1, 13]]);
    }
    /**
     * Forces token refresh, even if unexpired tokens are currently cached.
     * External credentials are exchanged for GCP access tokens via the token
     * exchange endpoint and other settings provided in the client options
     * object.
     * If the service_account_impersonation_url is provided, an additional
     * step to exchange the external account GCP access token for a service
     * account impersonated token is performed.
     * @return A promise that resolves with the fresh GCP access tokens.
     */

  }, {
    key: "refreshAccessTokenAsync",
    value: function refreshAccessTokenAsync() {
      var subjectToken, stsCredentialsOptions, stsResponse;
      return regeneratorRuntime.async(function refreshAccessTokenAsync$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return regeneratorRuntime.awrap(this.retrieveSubjectToken());

            case 2:
              subjectToken = _context5.sent;
              // Construct the STS credentials options.
              stsCredentialsOptions = {
                grantType: STS_GRANT_TYPE,
                audience: this.audience,
                requestedTokenType: STS_REQUEST_TOKEN_TYPE,
                subjectToken: subjectToken,
                subjectTokenType: this.subjectTokenType,
                // generateAccessToken requires the provided access token to have
                // scopes:
                // https://www.googleapis.com/auth/iam or
                // https://www.googleapis.com/auth/cloud-platform
                // The new service account access token scopes will match the user
                // provided ones.
                scope: this.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : this.getScopesArray()
              }; // Exchange the external credentials for a GCP access token.

              _context5.next = 6;
              return regeneratorRuntime.awrap(this.stsCredential.exchangeToken(stsCredentialsOptions));

            case 6:
              stsResponse = _context5.sent;

              if (!this.serviceAccountImpersonationUrl) {
                _context5.next = 13;
                break;
              }

              _context5.next = 10;
              return regeneratorRuntime.awrap(this.getImpersonatedAccessToken(stsResponse.access_token));

            case 10:
              this.cachedAccessToken = _context5.sent;
              _context5.next = 14;
              break;

            case 13:
              // Save response in cached access token.
              this.cachedAccessToken = {
                access_token: stsResponse.access_token,
                expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,
                res: stsResponse.res
              };

            case 14:
              // Save credentials.
              this.credentials = {};
              Object.assign(this.credentials, this.cachedAccessToken);
              delete this.credentials.res; // Trigger tokens event to notify external listeners.

              this.emit('tokens', {
                refresh_token: null,
                expiry_date: this.cachedAccessToken.expiry_date,
                access_token: this.cachedAccessToken.access_token,
                token_type: 'Bearer',
                id_token: null
              }); // Return the cached access token.

              return _context5.abrupt("return", this.cachedAccessToken);

            case 19:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
    /**
     * Returns the workload identity pool project number if it is determinable
     * from the audience resource name.
     * @param audience The STS audience used to determine the project number.
     * @return The project number associated with the workload identity pool, if
     *   this can be determined from the STS audience field. Otherwise, null is
     *   returned.
     */

  }, {
    key: "getProjectNumber",
    value: function getProjectNumber(audience) {
      // STS audience pattern:
      // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...
      var match = audience.match(/\/projects\/([^/]+)/);

      if (!match) {
        return null;
      }

      return match[1];
    }
    /**
     * Exchanges an external account GCP access token for a service
     * account impersonated access token using iamcredentials
     * GenerateAccessToken API.
     * @param token The access token to exchange for a service account access
     *   token.
     * @return A promise that resolves with the service account impersonated
     *   credentials response.
     */

  }, {
    key: "getImpersonatedAccessToken",
    value: function getImpersonatedAccessToken(token) {
      var opts, response, successResponse;
      return regeneratorRuntime.async(function getImpersonatedAccessToken$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              opts = {
                url: this.serviceAccountImpersonationUrl,
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  Authorization: "Bearer ".concat(token)
                },
                data: {
                  scope: this.getScopesArray()
                },
                responseType: 'json'
              };
              _context6.next = 3;
              return regeneratorRuntime.awrap(this.transporter.request(opts));

            case 3:
              response = _context6.sent;
              successResponse = response.data;
              return _context6.abrupt("return", {
                access_token: successResponse.accessToken,
                // Convert from ISO format to timestamp.
                expiry_date: new Date(successResponse.expireTime).getTime(),
                res: response
              });

            case 6:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
    /**
     * Returns whether the provided credentials are expired or not.
     * If there is no expiry time, assumes the token is not expired or expiring.
     * @param accessToken The credentials to check for expiration.
     * @return Whether the credentials are expired or not.
     */

  }, {
    key: "isExpired",
    value: function isExpired(accessToken) {
      var now = new Date().getTime();
      return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
    }
    /**
     * @return The list of scopes for the requested GCP access token.
     */

  }, {
    key: "getScopesArray",
    value: function getScopesArray() {
      // Since scopes can be provided as string or array, the type should
      // be normalized.
      if (typeof this.scopes === 'string') {
        return [this.scopes];
      } else if (typeof this.scopes === 'undefined') {
        return [DEFAULT_OAUTH_SCOPE];
      } else {
        return this.scopes;
      }
    }
  }]);

  return BaseExternalAccountClient;
}(authclient_1.AuthClient);

exports.BaseExternalAccountClient = BaseExternalAccountClient;