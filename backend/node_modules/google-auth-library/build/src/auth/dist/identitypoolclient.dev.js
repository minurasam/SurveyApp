"use strict"; // Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _a, _b, _c;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IdentityPoolClient = void 0;

var fs = require("fs");

var util_1 = require("util");

var baseexternalclient_1 = require("./baseexternalclient"); // fs.readfile is undefined in browser karma tests causing
// `npm run browser-test` to fail as test.oauth2.ts imports this file via
// src/index.ts.
// Fallback to void function to avoid promisify throwing a TypeError.


var readFile = util_1.promisify((_a = fs.readFile) !== null && _a !== void 0 ? _a : function () {});
var realpath = util_1.promisify((_b = fs.realpath) !== null && _b !== void 0 ? _b : function () {});
var lstat = util_1.promisify((_c = fs.lstat) !== null && _c !== void 0 ? _c : function () {});
/**
 * Defines the Url-sourced and file-sourced external account clients mainly
 * used for K8s and Azure workloads.
 */

var IdentityPoolClient =
/*#__PURE__*/
function (_baseexternalclient_) {
  _inherits(IdentityPoolClient, _baseexternalclient_);

  /**
   * Instantiate an IdentityPoolClient instance using the provided JSON
   * object loaded from an external account credentials file.
   * An error is thrown if the credential is not a valid file-sourced or
   * url-sourced credential.
   * @param options The external account options object typically loaded
   *   from the external account JSON credential file.
   * @param additionalOptions Optional additional behavior customization
   *   options. These currently customize expiration threshold time and
   *   whether to retry on 401/403 API request errors.
   */
  function IdentityPoolClient(options, additionalOptions) {
    var _this;

    _classCallCheck(this, IdentityPoolClient);

    var _a, _b;

    _this = _possibleConstructorReturn(this, _getPrototypeOf(IdentityPoolClient).call(this, options, additionalOptions));
    _this.file = options.credential_source.file;
    _this.url = options.credential_source.url;
    _this.headers = options.credential_source.headers;

    if (!_this.file && !_this.url) {
      throw new Error('No valid Identity Pool "credential_source" provided');
    } // Text is the default format type.


    _this.formatType = ((_a = options.credential_source.format) === null || _a === void 0 ? void 0 : _a.type) || 'text';
    _this.formatSubjectTokenFieldName = (_b = options.credential_source.format) === null || _b === void 0 ? void 0 : _b.subject_token_field_name;

    if (_this.formatType !== 'json' && _this.formatType !== 'text') {
      throw new Error("Invalid credential_source format \"".concat(_this.formatType, "\""));
    }

    if (_this.formatType === 'json' && !_this.formatSubjectTokenFieldName) {
      throw new Error('Missing subject_token_field_name for JSON credential_source format');
    }

    return _this;
  }
  /**
   * Triggered when a external subject token is needed to be exchanged for a GCP
   * access token via GCP STS endpoint.
   * This uses the `options.credential_source` object to figure out how
   * to retrieve the token using the current environment. In this case,
   * this either retrieves the local credential from a file location (k8s
   * workload) or by sending a GET request to a local metadata server (Azure
   * workloads).
   * @return A promise that resolves with the external subject token.
   */


  _createClass(IdentityPoolClient, [{
    key: "retrieveSubjectToken",
    value: function retrieveSubjectToken() {
      return regeneratorRuntime.async(function retrieveSubjectToken$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this.file) {
                _context.next = 4;
                break;
              }

              _context.next = 3;
              return regeneratorRuntime.awrap(this.getTokenFromFile(this.file, this.formatType, this.formatSubjectTokenFieldName));

            case 3:
              return _context.abrupt("return", _context.sent);

            case 4:
              _context.next = 6;
              return regeneratorRuntime.awrap(this.getTokenFromUrl(this.url, this.formatType, this.formatSubjectTokenFieldName, this.headers));

            case 6:
              return _context.abrupt("return", _context.sent);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * Looks up the external subject token in the file path provided and
     * resolves with that token.
     * @param file The file path where the external credential is located.
     * @param formatType The token file or URL response type (JSON or text).
     * @param formatSubjectTokenFieldName For JSON response types, this is the
     *   subject_token field name. For Azure, this is access_token. For text
     *   response types, this is ignored.
     * @return A promise that resolves with the external subject token.
     */

  }, {
    key: "getTokenFromFile",
    value: function getTokenFromFile(filePath, formatType, formatSubjectTokenFieldName) {
      var subjectToken, rawText, json;
      return regeneratorRuntime.async(function getTokenFromFile$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return regeneratorRuntime.awrap(realpath(filePath));

            case 3:
              filePath = _context2.sent;
              _context2.next = 6;
              return regeneratorRuntime.awrap(lstat(filePath));

            case 6:
              if (_context2.sent.isFile()) {
                _context2.next = 8;
                break;
              }

              throw new Error();

            case 8:
              _context2.next = 14;
              break;

            case 10:
              _context2.prev = 10;
              _context2.t0 = _context2["catch"](0);
              _context2.t0.message = "The file at ".concat(filePath, " does not exist, or it is not a file. ").concat(_context2.t0.message);
              throw _context2.t0;

            case 14:
              _context2.next = 16;
              return regeneratorRuntime.awrap(readFile(filePath, {
                encoding: 'utf8'
              }));

            case 16:
              rawText = _context2.sent;

              if (formatType === 'text') {
                subjectToken = rawText;
              } else if (formatType === 'json' && formatSubjectTokenFieldName) {
                json = JSON.parse(rawText);
                subjectToken = json[formatSubjectTokenFieldName];
              }

              if (subjectToken) {
                _context2.next = 20;
                break;
              }

              throw new Error('Unable to parse the subject_token from the credential_source file');

            case 20:
              return _context2.abrupt("return", subjectToken);

            case 21:
            case "end":
              return _context2.stop();
          }
        }
      }, null, null, [[0, 10]]);
    }
    /**
     * Sends a GET request to the URL provided and resolves with the returned
     * external subject token.
     * @param url The URL to call to retrieve the subject token. This is typically
     *   a local metadata server.
     * @param formatType The token file or URL response type (JSON or text).
     * @param formatSubjectTokenFieldName For JSON response types, this is the
     *   subject_token field name. For Azure, this is access_token. For text
     *   response types, this is ignored.
     * @param headers The optional additional headers to send with the request to
     *   the metadata server url.
     * @return A promise that resolves with the external subject token.
     */

  }, {
    key: "getTokenFromUrl",
    value: function getTokenFromUrl(url, formatType, formatSubjectTokenFieldName, headers) {
      var opts, subjectToken, response, _response;

      return regeneratorRuntime.async(function getTokenFromUrl$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              opts = {
                url: url,
                method: 'GET',
                headers: headers,
                responseType: formatType
              };

              if (!(formatType === 'text')) {
                _context3.next = 8;
                break;
              }

              _context3.next = 4;
              return regeneratorRuntime.awrap(this.transporter.request(opts));

            case 4:
              response = _context3.sent;
              subjectToken = response.data;
              _context3.next = 13;
              break;

            case 8:
              if (!(formatType === 'json' && formatSubjectTokenFieldName)) {
                _context3.next = 13;
                break;
              }

              _context3.next = 11;
              return regeneratorRuntime.awrap(this.transporter.request(opts));

            case 11:
              _response = _context3.sent;
              subjectToken = _response.data[formatSubjectTokenFieldName];

            case 13:
              if (subjectToken) {
                _context3.next = 15;
                break;
              }

              throw new Error('Unable to parse the subject_token from the credential_source URL');

            case 15:
              return _context3.abrupt("return", subjectToken);

            case 16:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
  }]);

  return IdentityPoolClient;
}(baseexternalclient_1.BaseExternalAccountClient);

exports.IdentityPoolClient = IdentityPoolClient;