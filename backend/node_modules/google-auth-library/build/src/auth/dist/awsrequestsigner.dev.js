"use strict"; // Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AwsRequestSigner = void 0;

var crypto_1 = require("../crypto/crypto");
/** AWS Signature Version 4 signing algorithm identifier.  */


var AWS_ALGORITHM = 'AWS4-HMAC-SHA256';
/**
 * The termination string for the AWS credential scope value as defined in
 * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html
 */

var AWS_REQUEST_TYPE = 'aws4_request';
/**
 * Implements an AWS API request signer based on the AWS Signature Version 4
 * signing process.
 * https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
 */

var AwsRequestSigner =
/*#__PURE__*/
function () {
  /**
   * Instantiates an AWS API request signer used to send authenticated signed
   * requests to AWS APIs based on the AWS Signature Version 4 signing process.
   * This also provides a mechanism to generate the signed request without
   * sending it.
   * @param getCredentials A mechanism to retrieve AWS security credentials
   *   when needed.
   * @param region The AWS region to use.
   */
  function AwsRequestSigner(getCredentials, region) {
    _classCallCheck(this, AwsRequestSigner);

    this.getCredentials = getCredentials;
    this.region = region;
    this.crypto = crypto_1.createCrypto();
  }
  /**
   * Generates the signed request for the provided HTTP request for calling
   * an AWS API. This follows the steps described at:
   * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html
   * @param amzOptions The AWS request options that need to be signed.
   * @return A promise that resolves with the GaxiosOptions containing the
   *   signed HTTP request parameters.
   */


  _createClass(AwsRequestSigner, [{
    key: "getRequestOptions",
    value: function getRequestOptions(amzOptions) {
      var requestPayloadData, url, method, requestPayload, additionalAmzHeaders, awsSecurityCredentials, uri, headerMap, headers, awsSignedReq;
      return regeneratorRuntime.async(function getRequestOptions$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (amzOptions.url) {
                _context.next = 2;
                break;
              }

              throw new Error('"url" is required in "amzOptions"');

            case 2:
              // Stringify JSON requests. This will be set in the request body of the
              // generated signed request.
              requestPayloadData = _typeof(amzOptions.data) === 'object' ? JSON.stringify(amzOptions.data) : amzOptions.data;
              url = amzOptions.url;
              method = amzOptions.method || 'GET';
              requestPayload = amzOptions.body || requestPayloadData;
              additionalAmzHeaders = amzOptions.headers;
              _context.next = 9;
              return regeneratorRuntime.awrap(this.getCredentials());

            case 9:
              awsSecurityCredentials = _context.sent;
              uri = new URL(url);
              _context.next = 13;
              return regeneratorRuntime.awrap(generateAuthenticationHeaderMap({
                crypto: this.crypto,
                host: uri.host,
                canonicalUri: uri.pathname,
                canonicalQuerystring: uri.search.substr(1),
                method: method,
                region: this.region,
                securityCredentials: awsSecurityCredentials,
                requestPayload: requestPayload,
                additionalAmzHeaders: additionalAmzHeaders
              }));

            case 13:
              headerMap = _context.sent;
              // Append additional optional headers, eg. X-Amz-Target, Content-Type, etc.
              headers = Object.assign( // Add x-amz-date if available.
              headerMap.amzDate ? {
                'x-amz-date': headerMap.amzDate
              } : {}, {
                Authorization: headerMap.authorizationHeader,
                host: uri.host
              }, additionalAmzHeaders || {});

              if (awsSecurityCredentials.token) {
                Object.assign(headers, {
                  'x-amz-security-token': awsSecurityCredentials.token
                });
              }

              awsSignedReq = {
                url: url,
                method: method,
                headers: headers
              };

              if (typeof requestPayload !== 'undefined') {
                awsSignedReq.body = requestPayload;
              }

              return _context.abrupt("return", awsSignedReq);

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }]);

  return AwsRequestSigner;
}();

exports.AwsRequestSigner = AwsRequestSigner;
/**
 * Creates the HMAC-SHA256 hash of the provided message using the
 * provided key.
 *
 * @param crypto The crypto instance used to facilitate cryptographic
 *   operations.
 * @param key The HMAC-SHA256 key to use.
 * @param msg The message to hash.
 * @return The computed hash bytes.
 */

function sign(crypto, key, msg) {
  return regeneratorRuntime.async(function sign$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return regeneratorRuntime.awrap(crypto.signWithHmacSha256(key, msg));

        case 2:
          return _context2.abrupt("return", _context2.sent);

        case 3:
        case "end":
          return _context2.stop();
      }
    }
  });
}
/**
 * Calculates the signing key used to calculate the signature for
 * AWS Signature Version 4 based on:
 * https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html
 *
 * @param crypto The crypto instance used to facilitate cryptographic
 *   operations.
 * @param key The AWS secret access key.
 * @param dateStamp The '%Y%m%d' date format.
 * @param region The AWS region.
 * @param serviceName The AWS service name, eg. sts.
 * @return The signing key bytes.
 */


function getSigningKey(crypto, key, dateStamp, region, serviceName) {
  var kDate, kRegion, kService, kSigning;
  return regeneratorRuntime.async(function getSigningKey$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap(sign(crypto, "AWS4".concat(key), dateStamp));

        case 2:
          kDate = _context3.sent;
          _context3.next = 5;
          return regeneratorRuntime.awrap(sign(crypto, kDate, region));

        case 5:
          kRegion = _context3.sent;
          _context3.next = 8;
          return regeneratorRuntime.awrap(sign(crypto, kRegion, serviceName));

        case 8:
          kService = _context3.sent;
          _context3.next = 11;
          return regeneratorRuntime.awrap(sign(crypto, kService, 'aws4_request'));

        case 11:
          kSigning = _context3.sent;
          return _context3.abrupt("return", kSigning);

        case 13:
        case "end":
          return _context3.stop();
      }
    }
  });
}
/**
 * Generates the authentication header map needed for generating the AWS
 * Signature Version 4 signed request.
 *
 * @param option The options needed to compute the authentication header map.
 * @return The AWS authentication header map which constitutes of the following
 *   components: amz-date, authorization header and canonical query string.
 */


function generateAuthenticationHeaderMap(options) {
  var additionalAmzHeaders, requestPayload, serviceName, now, amzDate, dateStamp, reformattedAdditionalAmzHeaders, amzHeaders, canonicalHeaders, signedHeadersList, signedHeaders, payloadHash, canonicalRequest, credentialScope, stringToSign, signingKey, signature, authorizationHeader;
  return regeneratorRuntime.async(function generateAuthenticationHeaderMap$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          additionalAmzHeaders = options.additionalAmzHeaders || {};
          requestPayload = options.requestPayload || ''; // iam.amazonaws.com host => iam service.
          // sts.us-east-2.amazonaws.com => sts service.

          serviceName = options.host.split('.')[0];
          now = new Date(); // Format: '%Y%m%dT%H%M%SZ'.

          amzDate = now.toISOString().replace(/[-:]/g, '').replace(/\.[0-9]+/, ''); // Format: '%Y%m%d'.

          dateStamp = now.toISOString().replace(/[-]/g, '').replace(/T.*/, ''); // Change all additional headers to be lower case.

          reformattedAdditionalAmzHeaders = {};
          Object.keys(additionalAmzHeaders).forEach(function (key) {
            reformattedAdditionalAmzHeaders[key.toLowerCase()] = additionalAmzHeaders[key];
          }); // Add AWS token if available.

          if (options.securityCredentials.token) {
            reformattedAdditionalAmzHeaders['x-amz-security-token'] = options.securityCredentials.token;
          } // Header keys need to be sorted alphabetically.


          amzHeaders = Object.assign({
            host: options.host
          }, // Previously the date was not fixed with x-amz- and could be provided manually.
          // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req
          reformattedAdditionalAmzHeaders.date ? {} : {
            'x-amz-date': amzDate
          }, reformattedAdditionalAmzHeaders);
          canonicalHeaders = '';
          signedHeadersList = Object.keys(amzHeaders).sort();
          signedHeadersList.forEach(function (key) {
            canonicalHeaders += "".concat(key, ":").concat(amzHeaders[key], "\n");
          });
          signedHeaders = signedHeadersList.join(';');
          _context4.next = 16;
          return regeneratorRuntime.awrap(options.crypto.sha256DigestHex(requestPayload));

        case 16:
          payloadHash = _context4.sent;
          // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html
          canonicalRequest = "".concat(options.method, "\n") + "".concat(options.canonicalUri, "\n") + "".concat(options.canonicalQuerystring, "\n") + "".concat(canonicalHeaders, "\n") + "".concat(signedHeaders, "\n") + "".concat(payloadHash);
          credentialScope = "".concat(dateStamp, "/").concat(options.region, "/").concat(serviceName, "/").concat(AWS_REQUEST_TYPE); // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html

          _context4.t0 = "".concat(AWS_ALGORITHM, "\n") + "".concat(amzDate, "\n") + "".concat(credentialScope, "\n");
          _context4.next = 22;
          return regeneratorRuntime.awrap(options.crypto.sha256DigestHex(canonicalRequest));

        case 22:
          _context4.t1 = _context4.sent;
          stringToSign = _context4.t0 + _context4.t1;
          _context4.next = 26;
          return regeneratorRuntime.awrap(getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName));

        case 26:
          signingKey = _context4.sent;
          _context4.next = 29;
          return regeneratorRuntime.awrap(sign(options.crypto, signingKey, stringToSign));

        case 29:
          signature = _context4.sent;
          // https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html
          authorizationHeader = "".concat(AWS_ALGORITHM, " Credential=").concat(options.securityCredentials.accessKeyId, "/") + "".concat(credentialScope, ", SignedHeaders=").concat(signedHeaders, ", ") + "Signature=".concat(crypto_1.fromArrayBufferToHex(signature));
          return _context4.abrupt("return", {
            // Do not return x-amz-date if date is available.
            amzDate: reformattedAdditionalAmzHeaders.date ? undefined : amzDate,
            authorizationHeader: authorizationHeader,
            canonicalQuerystring: options.canonicalQuerystring
          });

        case 32:
        case "end":
          return _context4.stop();
      }
    }
  });
}