"use strict"; // Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;

var querystring = require("querystring");

var stream = require("stream");

var formatEcdsa = require("ecdsa-sig-formatter");

var crypto_1 = require("../crypto/crypto");

var authclient_1 = require("./authclient");

var loginticket_1 = require("./loginticket");

var CodeChallengeMethod;

(function (CodeChallengeMethod) {
  CodeChallengeMethod["Plain"] = "plain";
  CodeChallengeMethod["S256"] = "S256";
})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));

var CertificateFormat;

(function (CertificateFormat) {
  CertificateFormat["PEM"] = "PEM";
  CertificateFormat["JWK"] = "JWK";
})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));

var OAuth2Client =
/*#__PURE__*/
function (_authclient_1$AuthCli) {
  _inherits(OAuth2Client, _authclient_1$AuthCli);

  function OAuth2Client(optionsOrClientId, clientSecret, redirectUri) {
    var _this;

    _classCallCheck(this, OAuth2Client);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(OAuth2Client).call(this));
    _this.certificateCache = {};
    _this.certificateExpiry = null;
    _this.certificateCacheFormat = CertificateFormat.PEM;
    _this.refreshTokenPromises = new Map();
    var opts = optionsOrClientId && _typeof(optionsOrClientId) === 'object' ? optionsOrClientId : {
      clientId: optionsOrClientId,
      clientSecret: clientSecret,
      redirectUri: redirectUri
    };
    _this._clientId = opts.clientId;
    _this._clientSecret = opts.clientSecret;
    _this.redirectUri = opts.redirectUri;
    _this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;
    _this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;
    return _this;
  }
  /**
   * Generates URL for consent page landing.
   * @param opts Options.
   * @return URL to consent page.
   */


  _createClass(OAuth2Client, [{
    key: "generateAuthUrl",
    value: function generateAuthUrl() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (opts.code_challenge_method && !opts.code_challenge) {
        throw new Error('If a code_challenge_method is provided, code_challenge must be included.');
      }

      opts.response_type = opts.response_type || 'code';
      opts.client_id = opts.client_id || this._clientId;
      opts.redirect_uri = opts.redirect_uri || this.redirectUri; // Allow scopes to be passed either as array or a string

      if (opts.scope instanceof Array) {
        opts.scope = opts.scope.join(' ');
      }

      var rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;
      return rootUrl + '?' + querystring.stringify(opts);
    }
  }, {
    key: "generateCodeVerifier",
    value: function generateCodeVerifier() {
      // To make the code compatible with browser SubtleCrypto we need to make
      // this method async.
      throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');
    }
    /**
     * Convenience method to automatically generate a code_verifier, and its
     * resulting SHA256. If used, this must be paired with a S256
     * code_challenge_method.
     *
     * For a full example see:
     * https://github.com/googleapis/google-auth-library-nodejs/blob/master/samples/oauth2-codeVerifier.js
     */

  }, {
    key: "generateCodeVerifierAsync",
    value: function generateCodeVerifierAsync() {
      var crypto, randomString, codeVerifier, unencodedCodeChallenge, codeChallenge;
      return regeneratorRuntime.async(function generateCodeVerifierAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // base64 encoding uses 6 bits per character, and we want to generate128
              // characters. 6*128/8 = 96.
              crypto = crypto_1.createCrypto();
              randomString = crypto.randomBytesBase64(96); // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/
              // "-"/"."/"_"/"~". Base64 encoded strings are pretty close, so we're just
              // swapping out a few chars.

              codeVerifier = randomString.replace(/\+/g, '~').replace(/=/g, '_').replace(/\//g, '-'); // Generate the base64 encoded SHA256

              _context.next = 5;
              return regeneratorRuntime.awrap(crypto.sha256DigestBase64(codeVerifier));

            case 5:
              unencodedCodeChallenge = _context.sent;
              // We need to use base64UrlEncoding instead of standard base64
              codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\+/g, '-').replace(/\//g, '_');
              return _context.abrupt("return", {
                codeVerifier: codeVerifier,
                codeChallenge: codeChallenge
              });

            case 8:
            case "end":
              return _context.stop();
          }
        }
      });
    }
  }, {
    key: "getToken",
    value: function getToken(codeOrOptions, callback) {
      var options = typeof codeOrOptions === 'string' ? {
        code: codeOrOptions
      } : codeOrOptions;

      if (callback) {
        this.getTokenAsync(options).then(function (r) {
          return callback(null, r.tokens, r.res);
        }, function (e) {
          return callback(e, null, e.response);
        });
      } else {
        return this.getTokenAsync(options);
      }
    }
  }, {
    key: "getTokenAsync",
    value: function getTokenAsync(options) {
      var url, values, res, tokens;
      return regeneratorRuntime.async(function getTokenAsync$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;
              values = {
                code: options.code,
                client_id: options.client_id || this._clientId,
                client_secret: this._clientSecret,
                redirect_uri: options.redirect_uri || this.redirectUri,
                grant_type: 'authorization_code',
                code_verifier: options.codeVerifier
              };
              _context2.next = 4;
              return regeneratorRuntime.awrap(this.transporter.request({
                method: 'POST',
                url: url,
                data: querystring.stringify(values),
                headers: {
                  'Content-Type': 'application/x-www-form-urlencoded'
                }
              }));

            case 4:
              res = _context2.sent;
              tokens = res.data;

              if (res.data && res.data.expires_in) {
                tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;
                delete tokens.expires_in;
              }

              this.emit('tokens', tokens);
              return _context2.abrupt("return", {
                tokens: tokens,
                res: res
              });

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
    /**
     * Refreshes the access token.
     * @param refresh_token Existing refresh token.
     * @private
     */

  }, {
    key: "refreshToken",
    value: function refreshToken(_refreshToken) {
      var _this2 = this;

      var p;
      return regeneratorRuntime.async(function refreshToken$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (_refreshToken) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", this.refreshTokenNoCache(_refreshToken));

            case 2:
              if (!this.refreshTokenPromises.has(_refreshToken)) {
                _context3.next = 4;
                break;
              }

              return _context3.abrupt("return", this.refreshTokenPromises.get(_refreshToken));

            case 4:
              p = this.refreshTokenNoCache(_refreshToken).then(function (r) {
                _this2.refreshTokenPromises["delete"](_refreshToken);

                return r;
              }, function (e) {
                _this2.refreshTokenPromises["delete"](_refreshToken);

                throw e;
              });
              this.refreshTokenPromises.set(_refreshToken, p);
              return _context3.abrupt("return", p);

            case 7:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "refreshTokenNoCache",
    value: function refreshTokenNoCache(refreshToken) {
      var url, data, res, tokens;
      return regeneratorRuntime.async(function refreshTokenNoCache$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (refreshToken) {
                _context4.next = 2;
                break;
              }

              throw new Error('No refresh token is set.');

            case 2:
              url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;
              data = {
                refresh_token: refreshToken,
                client_id: this._clientId,
                client_secret: this._clientSecret,
                grant_type: 'refresh_token'
              }; // request for new token

              _context4.next = 6;
              return regeneratorRuntime.awrap(this.transporter.request({
                method: 'POST',
                url: url,
                data: querystring.stringify(data),
                headers: {
                  'Content-Type': 'application/x-www-form-urlencoded'
                }
              }));

            case 6:
              res = _context4.sent;
              tokens = res.data; // TODO: de-duplicate this code from a few spots

              if (res.data && res.data.expires_in) {
                tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;
                delete tokens.expires_in;
              }

              this.emit('tokens', tokens);
              return _context4.abrupt("return", {
                tokens: tokens,
                res: res
              });

            case 11:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "refreshAccessToken",
    value: function refreshAccessToken(callback) {
      if (callback) {
        this.refreshAccessTokenAsync().then(function (r) {
          return callback(null, r.credentials, r.res);
        }, callback);
      } else {
        return this.refreshAccessTokenAsync();
      }
    }
  }, {
    key: "refreshAccessTokenAsync",
    value: function refreshAccessTokenAsync() {
      var r, tokens;
      return regeneratorRuntime.async(function refreshAccessTokenAsync$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return regeneratorRuntime.awrap(this.refreshToken(this.credentials.refresh_token));

            case 2:
              r = _context5.sent;
              tokens = r.tokens;
              tokens.refresh_token = this.credentials.refresh_token;
              this.credentials = tokens;
              return _context5.abrupt("return", {
                credentials: this.credentials,
                res: r.res
              });

            case 7:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "getAccessToken",
    value: function getAccessToken(callback) {
      if (callback) {
        this.getAccessTokenAsync().then(function (r) {
          return callback(null, r.token, r.res);
        }, callback);
      } else {
        return this.getAccessTokenAsync();
      }
    }
  }, {
    key: "getAccessTokenAsync",
    value: function getAccessTokenAsync() {
      var shouldRefresh, r;
      return regeneratorRuntime.async(function getAccessTokenAsync$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();

              if (!shouldRefresh) {
                _context6.next = 12;
                break;
              }

              if (this.credentials.refresh_token) {
                _context6.next = 4;
                break;
              }

              throw new Error('No refresh token is set.');

            case 4:
              _context6.next = 6;
              return regeneratorRuntime.awrap(this.refreshAccessTokenAsync());

            case 6:
              r = _context6.sent;

              if (!(!r.credentials || r.credentials && !r.credentials.access_token)) {
                _context6.next = 9;
                break;
              }

              throw new Error('Could not refresh access token.');

            case 9:
              return _context6.abrupt("return", {
                token: r.credentials.access_token,
                res: r.res
              });

            case 12:
              return _context6.abrupt("return", {
                token: this.credentials.access_token
              });

            case 13:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
    /**
     * The main authentication interface.  It takes an optional url which when
     * present is the endpoint being accessed, and returns a Promise which
     * resolves with authorization header fields.
     *
     * In OAuth2Client, the result has the form:
     * { Authorization: 'Bearer <access_token_value>' }
     * @param url The optional url being authorized
     */

  }, {
    key: "getRequestHeaders",
    value: function getRequestHeaders(url) {
      var headers;
      return regeneratorRuntime.async(function getRequestHeaders$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return regeneratorRuntime.awrap(this.getRequestMetadataAsync(url));

            case 2:
              headers = _context7.sent.headers;
              return _context7.abrupt("return", headers);

            case 4:
            case "end":
              return _context7.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "getRequestMetadataAsync",
    value: function getRequestMetadataAsync( // eslint-disable-next-line @typescript-eslint/no-unused-vars
    url) {
      var thisCreds, _headers, r, tokens, e, credentials, headers;

      return regeneratorRuntime.async(function getRequestMetadataAsync$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              thisCreds = this.credentials;

              if (!(!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey)) {
                _context8.next = 3;
                break;
              }

              throw new Error('No access, refresh token or API key is set.');

            case 3:
              if (!(thisCreds.access_token && !this.isTokenExpiring())) {
                _context8.next = 7;
                break;
              }

              thisCreds.token_type = thisCreds.token_type || 'Bearer';
              _headers = {
                Authorization: thisCreds.token_type + ' ' + thisCreds.access_token
              };
              return _context8.abrupt("return", {
                headers: this.addSharedMetadataHeaders(_headers)
              });

            case 7:
              if (!this.apiKey) {
                _context8.next = 9;
                break;
              }

              return _context8.abrupt("return", {
                headers: {
                  'X-Goog-Api-Key': this.apiKey
                }
              });

            case 9:
              r = null;
              tokens = null;
              _context8.prev = 11;
              _context8.next = 14;
              return regeneratorRuntime.awrap(this.refreshToken(thisCreds.refresh_token));

            case 14:
              r = _context8.sent;
              tokens = r.tokens;
              _context8.next = 23;
              break;

            case 18:
              _context8.prev = 18;
              _context8.t0 = _context8["catch"](11);
              e = _context8.t0;

              if (e.response && (e.response.status === 403 || e.response.status === 404)) {
                e.message = "Could not refresh access token: ".concat(e.message);
              }

              throw e;

            case 23:
              credentials = this.credentials;
              credentials.token_type = credentials.token_type || 'Bearer';
              tokens.refresh_token = credentials.refresh_token;
              this.credentials = tokens;
              headers = {
                Authorization: credentials.token_type + ' ' + tokens.access_token
              };
              return _context8.abrupt("return", {
                headers: this.addSharedMetadataHeaders(headers),
                res: r.res
              });

            case 29:
            case "end":
              return _context8.stop();
          }
        }
      }, null, this, [[11, 18]]);
    }
    /**
     * Generates an URL to revoke the given token.
     * @param token The existing token to be revoked.
     */

  }, {
    key: "revokeToken",
    value: function revokeToken(token, callback) {
      var opts = {
        url: OAuth2Client.getRevokeTokenUrl(token),
        method: 'POST'
      };

      if (callback) {
        this.transporter.request(opts).then(function (r) {
          return callback(null, r);
        }, callback);
      } else {
        return this.transporter.request(opts);
      }
    }
  }, {
    key: "revokeCredentials",
    value: function revokeCredentials(callback) {
      if (callback) {
        this.revokeCredentialsAsync().then(function (res) {
          return callback(null, res);
        }, callback);
      } else {
        return this.revokeCredentialsAsync();
      }
    }
  }, {
    key: "revokeCredentialsAsync",
    value: function revokeCredentialsAsync() {
      var token;
      return regeneratorRuntime.async(function revokeCredentialsAsync$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              token = this.credentials.access_token;
              this.credentials = {};

              if (!token) {
                _context9.next = 6;
                break;
              }

              return _context9.abrupt("return", this.revokeToken(token));

            case 6:
              throw new Error('No access token to revoke.');

            case 7:
            case "end":
              return _context9.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "request",
    value: function request(opts, callback) {
      if (callback) {
        this.requestAsync(opts).then(function (r) {
          return callback(null, r);
        }, function (e) {
          return callback(e, e.response);
        });
      } else {
        return this.requestAsync(opts);
      }
    }
  }, {
    key: "requestAsync",
    value: function requestAsync(opts) {
      var retry,
          r2,
          r,
          res,
          statusCode,
          mayRequireRefresh,
          isReadableStream,
          isAuthErr,
          _args10 = arguments;
      return regeneratorRuntime.async(function requestAsync$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              retry = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : false;
              _context10.prev = 1;
              _context10.next = 4;
              return regeneratorRuntime.awrap(this.getRequestMetadataAsync(opts.url));

            case 4:
              r = _context10.sent;
              opts.headers = opts.headers || {};

              if (r.headers && r.headers['x-goog-user-project']) {
                opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];
              }

              if (r.headers && r.headers.Authorization) {
                opts.headers.Authorization = r.headers.Authorization;
              }

              if (this.apiKey) {
                opts.headers['X-Goog-Api-Key'] = this.apiKey;
              }

              _context10.next = 11;
              return regeneratorRuntime.awrap(this.transporter.request(opts));

            case 11:
              r2 = _context10.sent;
              _context10.next = 27;
              break;

            case 14:
              _context10.prev = 14;
              _context10.t0 = _context10["catch"](1);
              res = _context10.t0.response;

              if (!res) {
                _context10.next = 26;
                break;
              }

              statusCode = res.status; // Retry the request for metadata if the following criteria are true:
              // - We haven't already retried.  It only makes sense to retry once.
              // - The response was a 401 or a 403
              // - The request didn't send a readableStream
              // - An access_token and refresh_token were available, but either no
              //   expiry_date was available or the forceRefreshOnFailure flag is set.
              //   The absent expiry_date case can happen when developers stash the
              //   access_token and refresh_token for later use, but the access_token
              //   fails on the first try because it's expired. Some developers may
              //   choose to enable forceRefreshOnFailure to mitigate time-related
              //   errors.

              mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);
              isReadableStream = res.config.data instanceof stream.Readable;
              isAuthErr = statusCode === 401 || statusCode === 403;

              if (!(!retry && isAuthErr && !isReadableStream && mayRequireRefresh)) {
                _context10.next = 26;
                break;
              }

              _context10.next = 25;
              return regeneratorRuntime.awrap(this.refreshAccessTokenAsync());

            case 25:
              return _context10.abrupt("return", this.requestAsync(opts, true));

            case 26:
              throw _context10.t0;

            case 27:
              return _context10.abrupt("return", r2);

            case 28:
            case "end":
              return _context10.stop();
          }
        }
      }, null, this, [[1, 14]]);
    }
  }, {
    key: "verifyIdToken",
    value: function verifyIdToken(options, callback) {
      // This function used to accept two arguments instead of an options object.
      // Check the types to help users upgrade with less pain.
      // This check can be removed after a 2.0 release.
      if (callback && typeof callback !== 'function') {
        throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');
      }

      if (callback) {
        this.verifyIdTokenAsync(options).then(function (r) {
          return callback(null, r);
        }, callback);
      } else {
        return this.verifyIdTokenAsync(options);
      }
    }
  }, {
    key: "verifyIdTokenAsync",
    value: function verifyIdTokenAsync(options) {
      var response, login;
      return regeneratorRuntime.async(function verifyIdTokenAsync$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (options.idToken) {
                _context11.next = 2;
                break;
              }

              throw new Error('The verifyIdToken method requires an ID Token');

            case 2:
              _context11.next = 4;
              return regeneratorRuntime.awrap(this.getFederatedSignonCertsAsync());

            case 4:
              response = _context11.sent;
              _context11.next = 7;
              return regeneratorRuntime.awrap(this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry));

            case 7:
              login = _context11.sent;
              return _context11.abrupt("return", login);

            case 9:
            case "end":
              return _context11.stop();
          }
        }
      }, null, this);
    }
    /**
     * Obtains information about the provisioned access token.  Especially useful
     * if you want to check the scopes that were provisioned to a given token.
     *
     * @param accessToken Required.  The Access Token for which you want to get
     * user info.
     */

  }, {
    key: "getTokenInfo",
    value: function getTokenInfo(accessToken) {
      var _ref, data, info;

      return regeneratorRuntime.async(function getTokenInfo$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return regeneratorRuntime.awrap(this.transporter.request({
                method: 'POST',
                headers: {
                  'Content-Type': 'application/x-www-form-urlencoded',
                  Authorization: "Bearer ".concat(accessToken)
                },
                url: OAuth2Client.GOOGLE_TOKEN_INFO_URL
              }));

            case 2:
              _ref = _context12.sent;
              data = _ref.data;
              info = Object.assign({
                expiry_date: new Date().getTime() + data.expires_in * 1000,
                scopes: data.scope.split(' ')
              }, data);
              delete info.expires_in;
              delete info.scope;
              return _context12.abrupt("return", info);

            case 8:
            case "end":
              return _context12.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "getFederatedSignonCerts",
    value: function getFederatedSignonCerts(callback) {
      if (callback) {
        this.getFederatedSignonCertsAsync().then(function (r) {
          return callback(null, r.certs, r.res);
        }, callback);
      } else {
        return this.getFederatedSignonCertsAsync();
      }
    }
  }, {
    key: "getFederatedSignonCertsAsync",
    value: function getFederatedSignonCertsAsync() {
      var nowTime, format, res, url, cacheControl, cacheAge, pattern, regexResult, certificates, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key, now;

      return regeneratorRuntime.async(function getFederatedSignonCertsAsync$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              nowTime = new Date().getTime();
              format = crypto_1.hasBrowserCrypto() ? CertificateFormat.JWK : CertificateFormat.PEM;

              if (!(this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format)) {
                _context13.next = 4;
                break;
              }

              return _context13.abrupt("return", {
                certs: this.certificateCache,
                format: format
              });

            case 4:
              _context13.t0 = format;
              _context13.next = _context13.t0 === CertificateFormat.PEM ? 7 : _context13.t0 === CertificateFormat.JWK ? 9 : 11;
              break;

            case 7:
              url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;
              return _context13.abrupt("break", 12);

            case 9:
              url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;
              return _context13.abrupt("break", 12);

            case 11:
              throw new Error("Unsupported certificate format ".concat(format));

            case 12:
              _context13.prev = 12;
              _context13.next = 15;
              return regeneratorRuntime.awrap(this.transporter.request({
                url: url
              }));

            case 15:
              res = _context13.sent;
              _context13.next = 22;
              break;

            case 18:
              _context13.prev = 18;
              _context13.t1 = _context13["catch"](12);
              _context13.t1.message = "Failed to retrieve verification certificates: ".concat(_context13.t1.message);
              throw _context13.t1;

            case 22:
              cacheControl = res ? res.headers['cache-control'] : undefined;
              cacheAge = -1;

              if (cacheControl) {
                pattern = new RegExp('max-age=([0-9]*)');
                regexResult = pattern.exec(cacheControl);

                if (regexResult && regexResult.length === 2) {
                  // Cache results with max-age (in seconds)
                  cacheAge = Number(regexResult[1]) * 1000; // milliseconds
                }
              }

              certificates = {};
              _context13.t2 = format;
              _context13.next = _context13.t2 === CertificateFormat.PEM ? 29 : _context13.t2 === CertificateFormat.JWK ? 31 : 51;
              break;

            case 29:
              certificates = res.data;
              return _context13.abrupt("break", 52);

            case 31:
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context13.prev = 34;

              for (_iterator = res.data.keys[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                key = _step.value;
                certificates[key.kid] = key;
              }

              _context13.next = 42;
              break;

            case 38:
              _context13.prev = 38;
              _context13.t3 = _context13["catch"](34);
              _didIteratorError = true;
              _iteratorError = _context13.t3;

            case 42:
              _context13.prev = 42;
              _context13.prev = 43;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 45:
              _context13.prev = 45;

              if (!_didIteratorError) {
                _context13.next = 48;
                break;
              }

              throw _iteratorError;

            case 48:
              return _context13.finish(45);

            case 49:
              return _context13.finish(42);

            case 50:
              return _context13.abrupt("break", 52);

            case 51:
              throw new Error("Unsupported certificate format ".concat(format));

            case 52:
              now = new Date();
              this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);
              this.certificateCache = certificates;
              this.certificateCacheFormat = format;
              return _context13.abrupt("return", {
                certs: certificates,
                format: format,
                res: res
              });

            case 57:
            case "end":
              return _context13.stop();
          }
        }
      }, null, this, [[12, 18], [34, 38, 42, 50], [43,, 45, 49]]);
    }
  }, {
    key: "getIapPublicKeys",
    value: function getIapPublicKeys(callback) {
      if (callback) {
        this.getIapPublicKeysAsync().then(function (r) {
          return callback(null, r.pubkeys, r.res);
        }, callback);
      } else {
        return this.getIapPublicKeysAsync();
      }
    }
  }, {
    key: "getIapPublicKeysAsync",
    value: function getIapPublicKeysAsync() {
      var res, url;
      return regeneratorRuntime.async(function getIapPublicKeysAsync$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;
              _context14.prev = 1;
              _context14.next = 4;
              return regeneratorRuntime.awrap(this.transporter.request({
                url: url
              }));

            case 4:
              res = _context14.sent;
              _context14.next = 11;
              break;

            case 7:
              _context14.prev = 7;
              _context14.t0 = _context14["catch"](1);
              _context14.t0.message = "Failed to retrieve verification certificates: ".concat(_context14.t0.message);
              throw _context14.t0;

            case 11:
              return _context14.abrupt("return", {
                pubkeys: res.data,
                res: res
              });

            case 12:
            case "end":
              return _context14.stop();
          }
        }
      }, null, this, [[1, 7]]);
    }
  }, {
    key: "verifySignedJwtWithCerts",
    value: function verifySignedJwtWithCerts() {
      // To make the code compatible with browser SubtleCrypto we need to make
      // this method async.
      throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');
    }
    /**
     * Verify the id token is signed with the correct certificate
     * and is from the correct audience.
     * @param jwt The jwt to verify (The ID Token in this case).
     * @param certs The array of certs to test the jwt against.
     * @param requiredAudience The audience to test the jwt against.
     * @param issuers The allowed issuers of the jwt (Optional).
     * @param maxExpiry The max expiry the certificate can be (Optional).
     * @return Returns a promise resolving to LoginTicket on verification.
     */

  }, {
    key: "verifySignedJwtWithCertsAsync",
    value: function verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {
      var crypto, segments, signed, signature, envelope, payload, cert, verified, iat, exp, now, earliest, latest, aud, audVerified;
      return regeneratorRuntime.async(function verifySignedJwtWithCertsAsync$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              crypto = crypto_1.createCrypto();

              if (!maxExpiry) {
                maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;
              }

              segments = jwt.split('.');

              if (!(segments.length !== 3)) {
                _context15.next = 5;
                break;
              }

              throw new Error('Wrong number of segments in token: ' + jwt);

            case 5:
              signed = segments[0] + '.' + segments[1];
              signature = segments[2];
              _context15.prev = 7;
              envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));
              _context15.next = 15;
              break;

            case 11:
              _context15.prev = 11;
              _context15.t0 = _context15["catch"](7);
              _context15.t0.message = "Can't parse token envelope: ".concat(segments[0], "': ").concat(_context15.t0.message);
              throw _context15.t0;

            case 15:
              if (envelope) {
                _context15.next = 17;
                break;
              }

              throw new Error("Can't parse token envelope: " + segments[0]);

            case 17:
              _context15.prev = 17;
              payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));
              _context15.next = 25;
              break;

            case 21:
              _context15.prev = 21;
              _context15.t1 = _context15["catch"](17);
              _context15.t1.message = "Can't parse token payload '".concat(segments[0]);
              throw _context15.t1;

            case 25:
              if (payload) {
                _context15.next = 27;
                break;
              }

              throw new Error("Can't parse token payload: " + segments[1]);

            case 27:
              if (Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {
                _context15.next = 29;
                break;
              }

              throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));

            case 29:
              cert = certs[envelope.kid];

              if (envelope.alg === 'ES256') {
                signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');
              }

              _context15.next = 33;
              return regeneratorRuntime.awrap(crypto.verify(cert, signed, signature));

            case 33:
              verified = _context15.sent;

              if (verified) {
                _context15.next = 36;
                break;
              }

              throw new Error('Invalid token signature: ' + jwt);

            case 36:
              if (payload.iat) {
                _context15.next = 38;
                break;
              }

              throw new Error('No issue time in token: ' + JSON.stringify(payload));

            case 38:
              if (payload.exp) {
                _context15.next = 40;
                break;
              }

              throw new Error('No expiration time in token: ' + JSON.stringify(payload));

            case 40:
              iat = Number(payload.iat);

              if (!isNaN(iat)) {
                _context15.next = 43;
                break;
              }

              throw new Error('iat field using invalid format');

            case 43:
              exp = Number(payload.exp);

              if (!isNaN(exp)) {
                _context15.next = 46;
                break;
              }

              throw new Error('exp field using invalid format');

            case 46:
              now = new Date().getTime() / 1000;

              if (!(exp >= now + maxExpiry)) {
                _context15.next = 49;
                break;
              }

              throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));

            case 49:
              earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;
              latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;

              if (!(now < earliest)) {
                _context15.next = 53;
                break;
              }

              throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));

            case 53:
              if (!(now > latest)) {
                _context15.next = 55;
                break;
              }

              throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));

            case 55:
              if (!(issuers && issuers.indexOf(payload.iss) < 0)) {
                _context15.next = 57;
                break;
              }

              throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);

            case 57:
              if (!(typeof requiredAudience !== 'undefined' && requiredAudience !== null)) {
                _context15.next = 63;
                break;
              }

              aud = payload.aud;
              audVerified = false; // If the requiredAudience is an array, check if it contains token
              // audience

              if (requiredAudience.constructor === Array) {
                audVerified = requiredAudience.indexOf(aud) > -1;
              } else {
                audVerified = aud === requiredAudience;
              }

              if (audVerified) {
                _context15.next = 63;
                break;
              }

              throw new Error('Wrong recipient, payload audience != requiredAudience');

            case 63:
              return _context15.abrupt("return", new loginticket_1.LoginTicket(envelope, payload));

            case 64:
            case "end":
              return _context15.stop();
          }
        }
      }, null, null, [[7, 11], [17, 21]]);
    }
    /**
     * Returns true if a token is expired or will expire within
     * eagerRefreshThresholdMillismilliseconds.
     * If there is no expiry time, assumes the token is not expired or expiring.
     */

  }, {
    key: "isTokenExpiring",
    value: function isTokenExpiring() {
      var expiryDate = this.credentials.expiry_date;
      return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;
    }
  }], [{
    key: "getRevokeTokenUrl",
    value: function getRevokeTokenUrl(token) {
      var parameters = querystring.stringify({
        token: token
      });
      return "".concat(OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_, "?").concat(parameters);
    }
  }]);

  return OAuth2Client;
}(authclient_1.AuthClient);

exports.OAuth2Client = OAuth2Client;
OAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';
/**
 * The base URL for auth endpoints.
 */

OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';
/**
 * The base endpoint for token retrieval.
 */

OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';
/**
 * The base endpoint to revoke tokens.
 */

OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';
/**
 * Google Sign on certificates in PEM format.
 */

OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';
/**
 * Google Sign on certificates in JWK format.
 */

OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';
/**
 * Google Sign on certificates in JWK format.
 */

OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';
/**
 * Clock skew - five minutes in seconds
 */

OAuth2Client.CLOCK_SKEW_SECS_ = 300;
/**
 * Max Token Lifetime is one day in seconds
 */

OAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;
/**
 * The allowed oauth token issuers.
 */

OAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];