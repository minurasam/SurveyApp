"use strict"; // Copyright 2015 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JWTAccess = void 0;

var jws = require("jws");

var LRU = require("lru-cache");

var DEFAULT_HEADER = {
  alg: 'RS256',
  typ: 'JWT'
};

var JWTAccess =
/*#__PURE__*/
function () {
  /**
   * JWTAccess service account credentials.
   *
   * Create a new access token by using the credential to create a new JWT token
   * that's recognized as the access token.
   *
   * @param email the service account email address.
   * @param key the private key that will be used to sign the token.
   * @param keyId the ID of the private key used to sign the token.
   */
  function JWTAccess(email, key, keyId, eagerRefreshThresholdMillis) {
    _classCallCheck(this, JWTAccess);

    this.cache = new LRU({
      max: 500,
      maxAge: 60 * 60 * 1000
    });
    this.email = email;
    this.key = key;
    this.keyId = keyId;
    this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1000;
  }
  /**
   * Get a non-expired access token, after refreshing if necessary.
   *
   * @param url The URI being authorized.
   * @param additionalClaims An object with a set of additional claims to
   * include in the payload.
   * @returns An object that includes the authorization header.
   */


  _createClass(JWTAccess, [{
    key: "getRequestHeaders",
    value: function getRequestHeaders(url, additionalClaims) {
      // Return cached authorization headers, unless we are within
      // eagerRefreshThresholdMillis ms of them expiring:
      var cachedToken = this.cache.get(url);
      var now = Date.now();

      if (cachedToken && cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {
        return cachedToken.headers;
      }

      var iat = Math.floor(Date.now() / 1000);
      var exp = JWTAccess.getExpirationTime(iat); // The payload used for signed JWT headers has:
      // iss == sub == <client email>
      // aud == <the authorization uri>

      var defaultClaims = {
        iss: this.email,
        sub: this.email,
        aud: url,
        exp: exp,
        iat: iat
      }; // if additionalClaims are provided, ensure they do not collide with
      // other required claims.

      if (additionalClaims) {
        for (var claim in defaultClaims) {
          if (additionalClaims[claim]) {
            throw new Error("The '".concat(claim, "' property is not allowed when passing additionalClaims. This claim is included in the JWT by default."));
          }
        }
      }

      var header = this.keyId ? _objectSpread({}, DEFAULT_HEADER, {
        kid: this.keyId
      }) : DEFAULT_HEADER;
      var payload = Object.assign(defaultClaims, additionalClaims); // Sign the jwt and add it to the cache

      var signedJWT = jws.sign({
        header: header,
        payload: payload,
        secret: this.key
      });
      var headers = {
        Authorization: "Bearer ".concat(signedJWT)
      };
      this.cache.set(url, {
        expiration: exp * 1000,
        headers: headers
      });
      return headers;
    }
    /**
     * Returns an expiration time for the JWT token.
     *
     * @param iat The issued at time for the JWT.
     * @returns An expiration time for the JWT.
     */

  }, {
    key: "fromJSON",

    /**
     * Create a JWTAccess credentials instance using the given input options.
     * @param json The input object.
     */
    value: function fromJSON(json) {
      if (!json) {
        throw new Error('Must pass in a JSON object containing the service account auth settings.');
      }

      if (!json.client_email) {
        throw new Error('The incoming JSON object does not contain a client_email field');
      }

      if (!json.private_key) {
        throw new Error('The incoming JSON object does not contain a private_key field');
      } // Extract the relevant information from the json key file.


      this.email = json.client_email;
      this.key = json.private_key;
      this.keyId = json.private_key_id;
      this.projectId = json.project_id;
    }
  }, {
    key: "fromStream",
    value: function fromStream(inputStream, callback) {
      if (callback) {
        this.fromStreamAsync(inputStream).then(function () {
          return callback();
        }, callback);
      } else {
        return this.fromStreamAsync(inputStream);
      }
    }
  }, {
    key: "fromStreamAsync",
    value: function fromStreamAsync(inputStream) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (!inputStream) {
          reject(new Error('Must pass in a stream containing the service account auth settings.'));
        }

        var s = '';
        inputStream.setEncoding('utf8').on('data', function (chunk) {
          return s += chunk;
        }).on('error', reject).on('end', function () {
          try {
            var data = JSON.parse(s);

            _this.fromJSON(data);

            resolve();
          } catch (err) {
            reject(err);
          }
        });
      });
    }
  }], [{
    key: "getExpirationTime",
    value: function getExpirationTime(iat) {
      var exp = iat + 3600; // 3600 seconds = 1 hour

      return exp;
    }
  }]);

  return JWTAccess;
}();

exports.JWTAccess = JWTAccess;