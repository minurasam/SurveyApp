"use strict"; // Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/* global window */

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BrowserCrypto = void 0; // This file implements crypto functions we need using in-browser
// SubtleCrypto interface `window.crypto.subtle`.

var base64js = require("base64-js"); // Not all browsers support `TextEncoder`. The following `require` will
// provide a fast UTF8-only replacement for those browsers that don't support
// text encoding natively.
// eslint-disable-next-line node/no-unsupported-features/node-builtins


if (typeof process === 'undefined' && typeof TextEncoder === 'undefined') {
  require('fast-text-encoding');
}

var crypto_1 = require("../crypto");

var BrowserCrypto =
/*#__PURE__*/
function () {
  function BrowserCrypto() {
    _classCallCheck(this, BrowserCrypto);

    if (typeof window === 'undefined' || window.crypto === undefined || window.crypto.subtle === undefined) {
      throw new Error("SubtleCrypto not found. Make sure it's an https:// website.");
    }
  }

  _createClass(BrowserCrypto, [{
    key: "sha256DigestBase64",
    value: function sha256DigestBase64(str) {
      var inputBuffer, outputBuffer;
      return regeneratorRuntime.async(function sha256DigestBase64$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // SubtleCrypto digest() method is async, so we must make
              // this method async as well.
              // To calculate SHA256 digest using SubtleCrypto, we first
              // need to convert an input string to an ArrayBuffer:
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              inputBuffer = new TextEncoder().encode(str); // Result is ArrayBuffer as well.

              _context.next = 3;
              return regeneratorRuntime.awrap(window.crypto.subtle.digest('SHA-256', inputBuffer));

            case 3:
              outputBuffer = _context.sent;
              return _context.abrupt("return", base64js.fromByteArray(new Uint8Array(outputBuffer)));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      });
    }
  }, {
    key: "randomBytesBase64",
    value: function randomBytesBase64(count) {
      var array = new Uint8Array(count);
      window.crypto.getRandomValues(array);
      return base64js.fromByteArray(array);
    }
  }, {
    key: "verify",
    value: function verify(pubkey, data, signature) {
      var algo, dataArray, signatureArray, cryptoKey, result;
      return regeneratorRuntime.async(function verify$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              algo = {
                name: 'RSASSA-PKCS1-v1_5',
                hash: {
                  name: 'SHA-256'
                }
              }; // eslint-disable-next-line node/no-unsupported-features/node-builtins

              dataArray = new TextEncoder().encode(data);
              signatureArray = base64js.toByteArray(BrowserCrypto.padBase64(signature));
              _context2.next = 5;
              return regeneratorRuntime.awrap(window.crypto.subtle.importKey('jwk', pubkey, algo, true, ['verify']));

            case 5:
              cryptoKey = _context2.sent;
              _context2.next = 8;
              return regeneratorRuntime.awrap(window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray));

            case 8:
              result = _context2.sent;
              return _context2.abrupt("return", result);

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      });
    }
  }, {
    key: "sign",
    value: function sign(privateKey, data) {
      var algo, dataArray, cryptoKey, result;
      return regeneratorRuntime.async(function sign$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              algo = {
                name: 'RSASSA-PKCS1-v1_5',
                hash: {
                  name: 'SHA-256'
                }
              }; // eslint-disable-next-line node/no-unsupported-features/node-builtins

              dataArray = new TextEncoder().encode(data);
              _context3.next = 4;
              return regeneratorRuntime.awrap(window.crypto.subtle.importKey('jwk', privateKey, algo, true, ['sign']));

            case 4:
              cryptoKey = _context3.sent;
              _context3.next = 7;
              return regeneratorRuntime.awrap(window.crypto.subtle.sign(algo, cryptoKey, dataArray));

            case 7:
              result = _context3.sent;
              return _context3.abrupt("return", base64js.fromByteArray(new Uint8Array(result)));

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      });
    }
  }, {
    key: "decodeBase64StringUtf8",
    value: function decodeBase64StringUtf8(base64) {
      var uint8array = base64js.toByteArray(BrowserCrypto.padBase64(base64)); // eslint-disable-next-line node/no-unsupported-features/node-builtins

      var result = new TextDecoder().decode(uint8array);
      return result;
    }
  }, {
    key: "encodeBase64StringUtf8",
    value: function encodeBase64StringUtf8(text) {
      // eslint-disable-next-line node/no-unsupported-features/node-builtins
      var uint8array = new TextEncoder().encode(text);
      var result = base64js.fromByteArray(uint8array);
      return result;
    }
    /**
     * Computes the SHA-256 hash of the provided string.
     * @param str The plain text string to hash.
     * @return A promise that resolves with the SHA-256 hash of the provided
     *   string in hexadecimal encoding.
     */

  }, {
    key: "sha256DigestHex",
    value: function sha256DigestHex(str) {
      var inputBuffer, outputBuffer;
      return regeneratorRuntime.async(function sha256DigestHex$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              // SubtleCrypto digest() method is async, so we must make
              // this method async as well.
              // To calculate SHA256 digest using SubtleCrypto, we first
              // need to convert an input string to an ArrayBuffer:
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              inputBuffer = new TextEncoder().encode(str); // Result is ArrayBuffer as well.

              _context4.next = 3;
              return regeneratorRuntime.awrap(window.crypto.subtle.digest('SHA-256', inputBuffer));

            case 3:
              outputBuffer = _context4.sent;
              return _context4.abrupt("return", crypto_1.fromArrayBufferToHex(outputBuffer));

            case 5:
            case "end":
              return _context4.stop();
          }
        }
      });
    }
    /**
     * Computes the HMAC hash of a message using the provided crypto key and the
     * SHA-256 algorithm.
     * @param key The secret crypto key in utf-8 or ArrayBuffer format.
     * @param msg The plain text message.
     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
     *   format.
     */

  }, {
    key: "signWithHmacSha256",
    value: function signWithHmacSha256(key, msg) {
      var rawKey, enc, cryptoKey;
      return regeneratorRuntime.async(function signWithHmacSha256$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              // Convert key, if provided in ArrayBuffer format, to string.
              rawKey = typeof key === 'string' ? key : String.fromCharCode.apply(String, _toConsumableArray(new Uint16Array(key))); // eslint-disable-next-line node/no-unsupported-features/node-builtins

              enc = new TextEncoder();
              _context5.next = 4;
              return regeneratorRuntime.awrap(window.crypto.subtle.importKey('raw', enc.encode(rawKey), {
                name: 'HMAC',
                hash: {
                  name: 'SHA-256'
                }
              }, false, ['sign']));

            case 4:
              cryptoKey = _context5.sent;
              return _context5.abrupt("return", window.crypto.subtle.sign('HMAC', cryptoKey, enc.encode(msg)));

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      });
    }
  }], [{
    key: "padBase64",
    value: function padBase64(base64) {
      // base64js requires padding, so let's add some '='
      while (base64.length % 4 !== 0) {
        base64 += '=';
      }

      return base64;
    }
  }]);

  return BrowserCrypto;
}();

exports.BrowserCrypto = BrowserCrypto;