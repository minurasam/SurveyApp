"use strict"; // Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NodeCrypto = void 0;

var crypto = require("crypto");

var NodeCrypto =
/*#__PURE__*/
function () {
  function NodeCrypto() {
    _classCallCheck(this, NodeCrypto);
  }

  _createClass(NodeCrypto, [{
    key: "sha256DigestBase64",
    value: function sha256DigestBase64(str) {
      return regeneratorRuntime.async(function sha256DigestBase64$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", crypto.createHash('sha256').update(str).digest('base64'));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      });
    }
  }, {
    key: "randomBytesBase64",
    value: function randomBytesBase64(count) {
      return crypto.randomBytes(count).toString('base64');
    }
  }, {
    key: "verify",
    value: function verify(pubkey, data, signature) {
      var verifier;
      return regeneratorRuntime.async(function verify$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              verifier = crypto.createVerify('sha256');
              verifier.update(data);
              verifier.end();
              return _context2.abrupt("return", verifier.verify(pubkey, signature, 'base64'));

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      });
    }
  }, {
    key: "sign",
    value: function sign(privateKey, data) {
      var signer;
      return regeneratorRuntime.async(function sign$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              signer = crypto.createSign('RSA-SHA256');
              signer.update(data);
              signer.end();
              return _context3.abrupt("return", signer.sign(privateKey, 'base64'));

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      });
    }
  }, {
    key: "decodeBase64StringUtf8",
    value: function decodeBase64StringUtf8(base64) {
      return Buffer.from(base64, 'base64').toString('utf-8');
    }
  }, {
    key: "encodeBase64StringUtf8",
    value: function encodeBase64StringUtf8(text) {
      return Buffer.from(text, 'utf-8').toString('base64');
    }
    /**
     * Computes the SHA-256 hash of the provided string.
     * @param str The plain text string to hash.
     * @return A promise that resolves with the SHA-256 hash of the provided
     *   string in hexadecimal encoding.
     */

  }, {
    key: "sha256DigestHex",
    value: function sha256DigestHex(str) {
      return regeneratorRuntime.async(function sha256DigestHex$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", crypto.createHash('sha256').update(str).digest('hex'));

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      });
    }
    /**
     * Computes the HMAC hash of a message using the provided crypto key and the
     * SHA-256 algorithm.
     * @param key The secret crypto key in utf-8 or ArrayBuffer format.
     * @param msg The plain text message.
     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
     *   format.
     */

  }, {
    key: "signWithHmacSha256",
    value: function signWithHmacSha256(key, msg) {
      var cryptoKey;
      return regeneratorRuntime.async(function signWithHmacSha256$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              cryptoKey = typeof key === 'string' ? key : toBuffer(key);
              return _context5.abrupt("return", toArrayBuffer(crypto.createHmac('sha256', cryptoKey).update(msg).digest()));

            case 2:
            case "end":
              return _context5.stop();
          }
        }
      });
    }
  }]);

  return NodeCrypto;
}();

exports.NodeCrypto = NodeCrypto;
/**
 * Converts a Node.js Buffer to an ArrayBuffer.
 * https://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer
 * @param buffer The Buffer input to covert.
 * @return The ArrayBuffer representation of the input.
 */

function toArrayBuffer(buffer) {
  return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
}
/**
 * Converts an ArrayBuffer to a Node.js Buffer.
 * @param arrayBuffer The ArrayBuffer input to covert.
 * @return The Buffer representation of the input.
 */


function toBuffer(arrayBuffer) {
  return Buffer.from(arrayBuffer);
}