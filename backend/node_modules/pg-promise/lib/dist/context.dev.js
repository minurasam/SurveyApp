"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
 * Copyright (c) 2015-present, Vitaly Tomilov
 *
 * See the LICENSE file at the top-level directory of this distribution
 * for licensing information.
 *
 * Removal or modification of this copyright notice is prohibited.
 */

/**
 * @class ConnectionContext
 * @private
 * @summary Internal connection context.
 *
 * @param {object} cc
 * Connection Context.
 *
 * @param {object} cc.cn
 * Connection details
 *
 * @param {*} cc.dc
 * Database Context
 *
 * @param {object} cc.options
 * Library's Initialization Options
 *
 * @param {object} cc.db
 * Database Session we're attached to, if any.
 *
 * @param {number} cc.level
 * Task Level
 *
 * @param {number} cc.txLevel
 * Transaction Level
 *
 * @param {object} cc.parentCtx
 * Connection Context of the parent operation, if any.
 *
 */
var ConnectionContext =
/*#__PURE__*/
function () {
  function ConnectionContext(cc) {
    _classCallCheck(this, ConnectionContext);

    this.cn = cc.cn; // connection details;

    this.dc = cc.dc; // database context;

    this.options = cc.options; // library options;

    this.db = cc.db; // database session;

    this.level = cc.level; // task level;

    this.txLevel = cc.txLevel; // transaction level;

    this.parentCtx = null; // parent context

    this.taskCtx = null; // task context

    this.start = null; // Date/Time when connected

    this.txCount = 0;
  }

  _createClass(ConnectionContext, [{
    key: "connect",
    value: function connect(db) {
      this.db = db;
      this.start = new Date();
    }
  }, {
    key: "disconnect",
    value: function disconnect(kill) {
      if (this.db) {
        var p = this.db.release(kill);
        this.db = null;
        return p;
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      var obj = new ConnectionContext(this);
      obj.parent = this;
      obj.parentCtx = this.taskCtx;
      return obj;
    }
  }, {
    key: "nextTxCount",
    get: function get() {
      var txCurrent = this,
          txTop = this;

      while (txCurrent.parent) {
        txCurrent = txCurrent.parent;

        if (txCurrent.taskCtx && txCurrent.taskCtx.isTX) {
          txTop = txCurrent;
        }
      }

      return txTop.txCount++;
    }
  }]);

  return ConnectionContext;
}();
/**
 * Connection Context
 * @module context
 * @author Vitaly Tomilov
 * @private
 */


module.exports = {
  ConnectionContext: ConnectionContext
};