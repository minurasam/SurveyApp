"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * Copyright (c) 2015-present, Vitaly Tomilov
 *
 * See the LICENSE file at the top-level directory of this distribution
 * for licensing information.
 *
 * Removal or modification of this copyright notice is prohibited.
 */
var _require = require("./promise-adapter"),
    PromiseAdapter = _require.PromiseAdapter; //////////////////////////////////////////
// Parses and validates a promise library;


function parse(pl) {
  var promise;

  if (pl instanceof PromiseAdapter) {
    promise = function promise(func) {
      return pl.create(func);
    };

    promise.resolve = pl.resolve;
    promise.reject = pl.reject;
    promise.all = pl.all;
    return promise;
  }

  var t = _typeof(pl);

  if (t === "function" || t === "object") {
    var Root = typeof pl.Promise === "function" ? pl.Promise : pl;

    promise = function promise(func) {
      return new Root(func);
    };

    promise.resolve = Root.resolve;
    promise.reject = Root.reject;
    promise.all = Root.all;

    if (typeof promise.resolve === "function" && typeof promise.reject === "function" && typeof promise.all === "function") {
      return promise;
    }
  }

  throw new TypeError("Invalid promise library specified.");
}

function parsePromise(promiseLib) {
  var result = {
    promiseLib: promiseLib
  };

  if (promiseLib) {
    result.promise = parse(promiseLib);
  } else {
    result.promise = parse(Promise);
    result.promiseLib = Promise;
  }

  return result;
}

module.exports = {
  parsePromise: parsePromise
};