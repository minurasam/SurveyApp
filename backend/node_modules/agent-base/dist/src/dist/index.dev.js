"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var events_1 = require("events");

var debug_1 = __importDefault(require("debug"));

var promisify_1 = __importDefault(require("./promisify"));

var debug = debug_1["default"]('agent-base');

function isAgent(v) {
  return Boolean(v) && typeof v.addRequest === 'function';
}

function isSecureEndpoint() {
  var _ref = new Error(),
      stack = _ref.stack;

  if (typeof stack !== 'string') return false;
  return stack.split('\n').some(function (l) {
    return l.indexOf('(https.js:') !== -1 || l.indexOf('node:https:') !== -1;
  });
}

function createAgent(callback, opts) {
  return new createAgent.Agent(callback, opts);
}

(function (createAgent) {
  /**
   * Base `http.Agent` implementation.
   * No pooling/keep-alive is implemented by default.
   *
   * @param {Function} callback
   * @api public
   */
  var Agent =
  /*#__PURE__*/
  function (_events_1$EventEmitte) {
    _inherits(Agent, _events_1$EventEmitte);

    function Agent(callback, _opts) {
      var _this;

      _classCallCheck(this, Agent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Agent).call(this));
      var opts = _opts;

      if (typeof callback === 'function') {
        _this.callback = callback;
      } else if (callback) {
        opts = callback;
      } // Timeout for the socket to be returned from the callback


      _this.timeout = null;

      if (opts && typeof opts.timeout === 'number') {
        _this.timeout = opts.timeout;
      } // These aren't actually used by `agent-base`, but are required
      // for the TypeScript definition files in `@types/node` :/


      _this.maxFreeSockets = 1;
      _this.maxSockets = 1;
      _this.maxTotalSockets = Infinity;
      _this.sockets = {};
      _this.freeSockets = {};
      _this.requests = {};
      _this.options = {};
      return _this;
    }

    _createClass(Agent, [{
      key: "callback",
      value: function callback(req, opts, fn) {
        throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
      }
      /**
       * Called by node-core's "_http_client.js" module when creating
       * a new HTTP request with this Agent instance.
       *
       * @api public
       */

    }, {
      key: "addRequest",
      value: function addRequest(req, _opts) {
        var _this2 = this;

        var opts = Object.assign({}, _opts);

        if (typeof opts.secureEndpoint !== 'boolean') {
          opts.secureEndpoint = isSecureEndpoint();
        }

        if (opts.host == null) {
          opts.host = 'localhost';
        }

        if (opts.port == null) {
          opts.port = opts.secureEndpoint ? 443 : 80;
        }

        if (opts.protocol == null) {
          opts.protocol = opts.secureEndpoint ? 'https:' : 'http:';
        }

        if (opts.host && opts.path) {
          // If both a `host` and `path` are specified then it's most
          // likely the result of a `url.parse()` call... we need to
          // remove the `path` portion so that `net.connect()` doesn't
          // attempt to open that as a unix socket file.
          delete opts.path;
        }

        delete opts.agent;
        delete opts.hostname;
        delete opts._defaultAgent;
        delete opts.defaultPort;
        delete opts.createConnection; // Hint to use "Connection: close"
        // XXX: non-documented `http` module API :(

        req._last = true;
        req.shouldKeepAlive = false;
        var timedOut = false;
        var timeoutId = null;
        var timeoutMs = opts.timeout || this.timeout;

        var onerror = function onerror(err) {
          if (req._hadError) return;
          req.emit('error', err); // For Safety. Some additional errors might fire later on
          // and we need to make sure we don't double-fire the error event.

          req._hadError = true;
        };

        var ontimeout = function ontimeout() {
          timeoutId = null;
          timedOut = true;
          var err = new Error("A \"socket\" was not created for HTTP request before ".concat(timeoutMs, "ms"));
          err.code = 'ETIMEOUT';
          onerror(err);
        };

        var callbackError = function callbackError(err) {
          if (timedOut) return;

          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }

          onerror(err);
        };

        var onsocket = function onsocket(socket) {
          if (timedOut) return;

          if (timeoutId != null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }

          if (isAgent(socket)) {
            // `socket` is actually an `http.Agent` instance, so
            // relinquish responsibility for this `req` to the Agent
            // from here on
            debug('Callback returned another Agent instance %o', socket.constructor.name);
            socket.addRequest(req, opts);
            return;
          }

          if (socket) {
            socket.once('free', function () {
              _this2.freeSocket(socket, opts);
            });
            req.onSocket(socket);
            return;
          }

          var err = new Error("no Duplex stream was returned to agent-base for `".concat(req.method, " ").concat(req.path, "`"));
          onerror(err);
        };

        if (typeof this.callback !== 'function') {
          onerror(new Error('`callback` is not defined'));
          return;
        }

        if (!this.promisifiedCallback) {
          if (this.callback.length >= 3) {
            debug('Converting legacy callback function to promise');
            this.promisifiedCallback = promisify_1["default"](this.callback);
          } else {
            this.promisifiedCallback = this.callback;
          }
        }

        if (typeof timeoutMs === 'number' && timeoutMs > 0) {
          timeoutId = setTimeout(ontimeout, timeoutMs);
        }

        if ('port' in opts && typeof opts.port !== 'number') {
          opts.port = Number(opts.port);
        }

        try {
          debug('Resolving socket for %o request: %o', opts.protocol, "".concat(req.method, " ").concat(req.path));
          Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
        } catch (err) {
          Promise.reject(err)["catch"](callbackError);
        }
      }
    }, {
      key: "freeSocket",
      value: function freeSocket(socket, opts) {
        debug('Freeing socket %o %o', socket.constructor.name, opts);
        socket.destroy();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        debug('Destroying agent %o', this.constructor.name);
      }
    }, {
      key: "defaultPort",
      get: function get() {
        if (typeof this.explicitDefaultPort === 'number') {
          return this.explicitDefaultPort;
        }

        return isSecureEndpoint() ? 443 : 80;
      },
      set: function set(v) {
        this.explicitDefaultPort = v;
      }
    }, {
      key: "protocol",
      get: function get() {
        if (typeof this.explicitProtocol === 'string') {
          return this.explicitProtocol;
        }

        return isSecureEndpoint() ? 'https:' : 'http:';
      },
      set: function set(v) {
        this.explicitProtocol = v;
      }
    }]);

    return Agent;
  }(events_1.EventEmitter);

  createAgent.Agent = Agent; // So that `instanceof` works correctly

  createAgent.prototype = createAgent.Agent.prototype;
})(createAgent || (createAgent = {}));

module.exports = createAgent;