'use strict';
/*!
 * Module dependencies.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var ValidationError = require('../error/validation');

var cleanPositionalOperators = require('./schema/cleanPositionalOperators');

var flatten = require('./common').flatten;

var modifiedPaths = require('./common').modifiedPaths;
/**
 * Applies validators and defaults to update and findOneAndUpdate operations,
 * specifically passing a null doc as `this` to validators and defaults
 *
 * @param {Query} query
 * @param {Schema} schema
 * @param {Object} castedDoc
 * @param {Object} options
 * @method runValidatorsOnUpdate
 * @api private
 */


module.exports = function (query, schema, castedDoc, options, callback) {
  var _keys;

  var keys = Object.keys(castedDoc || {});
  var updatedKeys = {};
  var updatedValues = {};
  var isPull = {};
  var arrayAtomicUpdates = {};
  var numKeys = keys.length;
  var hasDollarUpdate = false;
  var modified = {};
  var currentUpdate;
  var key;
  var i;

  for (i = 0; i < numKeys; ++i) {
    if (keys[i].startsWith('$')) {
      hasDollarUpdate = true;

      if (keys[i] === '$push' || keys[i] === '$addToSet') {
        _keys = Object.keys(castedDoc[keys[i]]);

        for (var ii = 0; ii < _keys.length; ++ii) {
          currentUpdate = castedDoc[keys[i]][_keys[ii]];

          if (currentUpdate && currentUpdate.$each) {
            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);
          } else {
            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([currentUpdate]);
          }
        }

        continue;
      }

      modifiedPaths(castedDoc[keys[i]], '', modified);
      var flat = flatten(castedDoc[keys[i]], null, null, schema);
      var paths = Object.keys(flat);
      var numPaths = paths.length;

      for (var j = 0; j < numPaths; ++j) {
        var updatedPath = cleanPositionalOperators(paths[j]);
        key = keys[i]; // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`
        // for the rest of the logic, it will get handled later.

        if (updatedPath.includes('$')) {
          continue;
        }

        if (key === '$set' || key === '$setOnInsert' || key === '$pull' || key === '$pullAll') {
          updatedValues[updatedPath] = flat[paths[j]];
          isPull[updatedPath] = key === '$pull' || key === '$pullAll';
        } else if (key === '$unset') {
          updatedValues[updatedPath] = undefined;
        }

        updatedKeys[updatedPath] = true;
      }
    }
  }

  if (!hasDollarUpdate) {
    modifiedPaths(castedDoc, '', modified);
    updatedValues = flatten(castedDoc, null, null, schema);
    updatedKeys = Object.keys(updatedValues);
  }

  var updates = Object.keys(updatedValues);
  var numUpdates = updates.length;
  var validatorsToExecute = [];
  var validationErrors = [];
  var alreadyValidated = [];
  var context = options && options.context === 'query' ? query : null;

  function iter(i, v) {
    var schemaPath = schema._getSchema(updates[i]);

    if (schemaPath == null) {
      return;
    }

    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {
      return;
    }

    if (v && Array.isArray(v.$in)) {
      v.$in.forEach(function (v, i) {
        validatorsToExecute.push(function (callback) {
          schemaPath.doValidate(v, function (err) {
            if (err) {
              err.path = updates[i] + '.$in.' + i;
              validationErrors.push(err);
            }

            callback(null);
          }, context, {
            updateValidator: true
          });
        });
      });
    } else {
      if (isPull[updates[i]] && schemaPath.$isMongooseArray) {
        return;
      }

      if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {
        alreadyValidated.push(updates[i]);
        validatorsToExecute.push(function (callback) {
          schemaPath.doValidate(v, function (err) {
            if (err) {
              err.path = updates[i];
              validationErrors.push(err);
              return callback(null);
            }

            v.validate(function (err) {
              if (err) {
                if (err.errors) {
                  for (var _i = 0, _Object$keys = Object.keys(err.errors); _i < _Object$keys.length; _i++) {
                    var _key = _Object$keys[_i];
                    var _err = err.errors[_key];
                    _err.path = updates[i] + '.' + _key;
                    validationErrors.push(_err);
                  }
                } else {
                  err.path = updates[i];
                  validationErrors.push(err);
                }
              }

              callback(null);
            });
          }, context, {
            updateValidator: true
          });
        });
      } else {
        validatorsToExecute.push(function (callback) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = alreadyValidated[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var path = _step.value;

              if (updates[i].startsWith(path + '.')) {
                return callback(null);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          schemaPath.doValidate(v, function (err) {
            if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err instanceof ValidationError) {
              return callback(null);
            }

            if (err) {
              err.path = updates[i];
              validationErrors.push(err);
            }

            callback(null);
          }, context, {
            updateValidator: true
          });
        });
      }
    }
  }

  for (i = 0; i < numUpdates; ++i) {
    iter(i, updatedValues[updates[i]]);
  }

  var arrayUpdates = Object.keys(arrayAtomicUpdates);

  var _loop = function _loop() {
    var arrayUpdate = _arrayUpdates[_i2];

    var schemaPath = schema._getSchema(arrayUpdate);

    if (schemaPath && schemaPath.$isMongooseDocumentArray) {
      validatorsToExecute.push(function (callback) {
        schemaPath.doValidate(arrayAtomicUpdates[arrayUpdate], getValidationCallback(arrayUpdate, validationErrors, callback), options && options.context === 'query' ? query : null);
      });
    } else {
      schemaPath = schema._getSchema(arrayUpdate + '.0');
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        var _loop2 = function _loop2() {
          var atomicUpdate = _step5.value;
          validatorsToExecute.push(function (callback) {
            schemaPath.doValidate(atomicUpdate, getValidationCallback(arrayUpdate, validationErrors, callback), options && options.context === 'query' ? query : null, {
              updateValidator: true
            });
          });
        };

        for (var _iterator5 = arrayAtomicUpdates[arrayUpdate][Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          _loop2();
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
  };

  for (var _i2 = 0, _arrayUpdates = arrayUpdates; _i2 < _arrayUpdates.length; _i2++) {
    _loop();
  }

  if (callback != null) {
    var _ret = function () {
      var numValidators = validatorsToExecute.length;

      if (numValidators === 0) {
        return {
          v: _done(callback)
        };
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = validatorsToExecute[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var validator = _step2.value;
          validator(function () {
            if (--numValidators <= 0) {
              _done(callback);
            }
          });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return {
        v: void 0
      };
    }();

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return function (callback) {
    var numValidators = validatorsToExecute.length;

    if (numValidators === 0) {
      return _done(callback);
    }

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = validatorsToExecute[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var validator = _step3.value;
        validator(function () {
          if (--numValidators <= 0) {
            _done(callback);
          }
        });
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  };

  function _done(callback) {
    if (validationErrors.length) {
      var err = new ValidationError(null);
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = validationErrors[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var validationError = _step4.value;
          err.addError(validationError.path, validationError);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return callback(err);
    }

    callback(null);
  }

  function getValidationCallback(arrayUpdate, validationErrors, callback) {
    return function (err) {
      if (err) {
        err.path = arrayUpdate;
        validationErrors.push(err);
      }

      callback(null);
    };
  }
};