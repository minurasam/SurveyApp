'use strict';
/*!
 * Module dependencies.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Binary = require('../driver').get().Binary;

var Decimal128 = require('../types/decimal128');

var ObjectId = require('../types/objectid');

var isMongooseObject = require('./isMongooseObject');

exports.flatten = flatten;
exports.modifiedPaths = modifiedPaths;
/*!
 * ignore
 */

function flatten(update, path, options, schema) {
  var keys;

  if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {
    keys = Object.keys(update.toObject({
      transform: false,
      virtuals: false
    }));
  } else {
    keys = Object.keys(update || {});
  }

  var numKeys = keys.length;
  var result = {};
  path = path ? path + '.' : '';

  for (var i = 0; i < numKeys; ++i) {
    var key = keys[i];
    var val = update[key];
    result[path + key] = val; // Avoid going into mixed paths if schema is specified

    var keySchema = schema && schema.path && schema.path(path + key);
    var isNested = schema && schema.nested && schema.nested[path + key];
    if (keySchema && keySchema.instance === 'Mixed') continue;

    if (shouldFlatten(val)) {
      if (options && options.skipArrays && Array.isArray(val)) {
        continue;
      }

      var flat = flatten(val, path + key, options, schema);

      for (var k in flat) {
        result[k] = flat[k];
      }

      if (Array.isArray(val)) {
        result[path + key] = val;
      }
    }

    if (isNested) {
      var paths = Object.keys(schema.paths);

      for (var _i = 0, _paths = paths; _i < _paths.length; _i++) {
        var p = _paths[_i];

        if (p.startsWith(path + key + '.') && !result.hasOwnProperty(p)) {
          result[p] = void 0;
        }
      }
    }
  }

  return result;
}
/*!
 * ignore
 */


function modifiedPaths(update, path, result) {
  var keys = Object.keys(update || {});
  var numKeys = keys.length;
  result = result || {};
  path = path ? path + '.' : '';

  for (var i = 0; i < numKeys; ++i) {
    var key = keys[i];
    var val = update[key];
    result[path + key] = true;

    if (isMongooseObject(val) && !Buffer.isBuffer(val)) {
      val = val.toObject({
        transform: false,
        virtuals: false
      });
    }

    if (shouldFlatten(val)) {
      modifiedPaths(val, path + key, result);
    }
  }

  return result;
}
/*!
 * ignore
 */


function shouldFlatten(val) {
  return val && _typeof(val) === 'object' && !(val instanceof Date) && !(val instanceof ObjectId) && (!Array.isArray(val) || val.length > 0) && !(val instanceof Buffer) && !(val instanceof Decimal128) && !(val instanceof Binary);
}