'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var modifiedPaths = require('./common').modifiedPaths;

var get = require('./get');
/**
 * Applies defaults to update and findOneAndUpdate operations.
 *
 * @param {Object} filter
 * @param {Schema} schema
 * @param {Object} castedDoc
 * @param {Object} options
 * @method setDefaultsOnInsert
 * @api private
 */


module.exports = function (filter, schema, castedDoc, options) {
  options = options || {};
  var shouldSetDefaultsOnInsert = options.setDefaultsOnInsert != null ? options.setDefaultsOnInsert : schema.base.options.setDefaultsOnInsert;

  if (!options.upsert || !shouldSetDefaultsOnInsert) {
    return castedDoc;
  }

  var keys = Object.keys(castedDoc || {});
  var updatedKeys = {};
  var updatedValues = {};
  var numKeys = keys.length;
  var modified = {};
  var hasDollarUpdate = false;

  for (var i = 0; i < numKeys; ++i) {
    if (keys[i].startsWith('$')) {
      modifiedPaths(castedDoc[keys[i]], '', modified);
      hasDollarUpdate = true;
    }
  }

  if (!hasDollarUpdate) {
    modifiedPaths(castedDoc, '', modified);
  }

  var paths = Object.keys(filter);
  var numPaths = paths.length;

  for (var _i = 0; _i < numPaths; ++_i) {
    var path = paths[_i];
    var condition = filter[path];

    if (condition && _typeof(condition) === 'object') {
      var conditionKeys = Object.keys(condition);
      var numConditionKeys = conditionKeys.length;
      var hasDollarKey = false;

      for (var j = 0; j < numConditionKeys; ++j) {
        if (conditionKeys[j].startsWith('$')) {
          hasDollarKey = true;
          break;
        }
      }

      if (hasDollarKey) {
        continue;
      }
    }

    updatedKeys[path] = true;
    modified[path] = true;
  }

  if (options && options.overwrite && !hasDollarUpdate) {
    // Defaults will be set later, since we're overwriting we'll cast
    // the whole update to a document
    return castedDoc;
  }

  schema.eachPath(function (path, schemaType) {
    // Skip single nested paths if underneath a map
    var isUnderneathMap = schemaType.path.endsWith('.$*') || schemaType.path.indexOf('.$*.') !== -1;

    if (schemaType.$isSingleNested && !isUnderneathMap) {
      // Only handle nested schemas 1-level deep to avoid infinite
      // recursion re: https://github.com/mongodb-js/mongoose-autopopulate/issues/11
      schemaType.schema.eachPath(function (_path, _schemaType) {
        if (_path === '_id' && _schemaType.auto) {
          // Ignore _id if auto id so we don't create subdocs
          return;
        }

        var def = _schemaType.getDefault(null, true);

        if (!isModified(modified, path + '.' + _path) && typeof def !== 'undefined') {
          castedDoc = castedDoc || {};
          castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
          castedDoc.$setOnInsert[path + '.' + _path] = def;
          updatedValues[path + '.' + _path] = def;
        }
      });
    } else {
      var def = schemaType.getDefault(null, true);

      if (!isModified(modified, path) && typeof def !== 'undefined') {
        castedDoc = castedDoc || {};
        castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};

        if (get(castedDoc, path) == null) {
          castedDoc.$setOnInsert[path] = def;
        }

        updatedValues[path] = def;
      }
    }
  });
  return castedDoc;
};

function isModified(modified, path) {
  if (modified[path]) {
    return true;
  }

  var sp = path.split('.');
  var cur = sp[0];

  for (var i = 1; i < sp.length; ++i) {
    if (modified[cur]) {
      return true;
    }

    cur += '.' + sp[i];
  }

  return false;
}