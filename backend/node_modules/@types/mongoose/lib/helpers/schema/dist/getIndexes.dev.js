'use strict';

var get = require('../get');

var helperIsObject = require('../isObject');
/*!
 * Gather all indexes defined in the schema, including single nested,
 * document arrays, and embedded discriminators.
 */


module.exports = function getIndexes(schema) {
  var indexes = [];
  var schemaStack = new WeakMap();
  var indexTypes = schema.constructor.indexTypes;
  var indexByName = new Map();
  collectIndexes(schema);
  return indexes;

  function collectIndexes(schema, prefix, baseSchema) {
    // Ignore infinitely nested schemas, if we've already seen this schema
    // along this path there must be a cycle
    if (schemaStack.has(schema)) {
      return;
    }

    schemaStack.set(schema, true);
    prefix = prefix || '';
    var keys = Object.keys(schema.paths);

    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
      var key = _keys[_i];
      var path = schema.paths[key];

      if (baseSchema != null && baseSchema.paths[key]) {
        // If looking at an embedded discriminator schema, don't look at paths
        // that the
        continue;
      }

      if (path.$isMongooseDocumentArray || path.$isSingleNested) {
        if (get(path, 'options.excludeIndexes') !== true && get(path, 'schemaOptions.excludeIndexes') !== true && get(path, 'schema.options.excludeIndexes') !== true) {
          collectIndexes(path.schema, prefix + key + '.');
        }

        if (path.schema.discriminators != null) {
          var discriminators = path.schema.discriminators;
          var discriminatorKeys = Object.keys(discriminators);

          for (var _i2 = 0, _discriminatorKeys = discriminatorKeys; _i2 < _discriminatorKeys.length; _i2++) {
            var discriminatorKey = _discriminatorKeys[_i2];
            collectIndexes(discriminators[discriminatorKey], prefix + key + '.', path.schema);
          }
        } // Retained to minimize risk of backwards breaking changes due to
        // gh-6113


        if (path.$isMongooseDocumentArray) {
          continue;
        }
      }

      var index = path._index || path.caster && path.caster._index;

      if (index !== false && index !== null && index !== undefined) {
        var field = {};
        var isObject = helperIsObject(index);
        var options = isObject ? index : {};
        var type = typeof index === 'string' ? index : isObject ? index.type : false;

        if (type && indexTypes.indexOf(type) !== -1) {
          field[prefix + key] = type;
        } else if (options.text) {
          field[prefix + key] = 'text';
          delete options.text;
        } else {
          var isDescendingIndex = Number(index) === -1;
          field[prefix + key] = isDescendingIndex ? -1 : 1;
        }

        delete options.type;

        if (!('background' in options)) {
          options.background = true;
        }

        if (schema.options.autoIndex != null) {
          options._autoIndex = schema.options.autoIndex;
        }

        var indexName = options && options.name;

        if (typeof indexName === 'string') {
          if (indexByName.has(indexName)) {
            Object.assign(indexByName.get(indexName), field);
          } else {
            indexes.push([field, options]);
            indexByName.set(indexName, field);
          }
        } else {
          indexes.push([field, options]);
          indexByName.set(indexName, field);
        }
      }
    }

    schemaStack["delete"](schema);

    if (prefix) {
      fixSubIndexPaths(schema, prefix);
    } else {
      schema._indexes.forEach(function (index) {
        if (!('background' in index[1])) {
          index[1].background = true;
        }
      });

      indexes = indexes.concat(schema._indexes);
    }
  }
  /*!
   * Checks for indexes added to subdocs using Schema.index().
   * These indexes need their paths prefixed properly.
   *
   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]
   */


  function fixSubIndexPaths(schema, prefix) {
    var subindexes = schema._indexes;
    var len = subindexes.length;

    for (var i = 0; i < len; ++i) {
      var indexObj = subindexes[i][0];
      var indexOptions = subindexes[i][1];
      var keys = Object.keys(indexObj);
      var klen = keys.length;
      var newindex = {}; // use forward iteration, order matters

      for (var j = 0; j < klen; ++j) {
        var key = keys[j];
        newindex[prefix + key] = indexObj[key];
      }

      var newIndexOptions = Object.assign({}, indexOptions);

      if (indexOptions != null && indexOptions.partialFilterExpression != null) {
        newIndexOptions.partialFilterExpression = {};
        var partialFilterExpression = indexOptions.partialFilterExpression;

        for (var _i3 = 0, _Object$keys = Object.keys(partialFilterExpression); _i3 < _Object$keys.length; _i3++) {
          var _key = _Object$keys[_i3];
          newIndexOptions.partialFilterExpression[prefix + _key] = partialFilterExpression[_key];
        }
      }

      indexes.push([newindex, newIndexOptions]);
    }
  }
};