'use strict';

var middlewareFunctions = require('../query/applyQueryMiddleware').middlewareFunctions;

var promiseOrCallback = require('../promiseOrCallback');

module.exports = function applyStaticHooks(model, hooks, statics) {
  var kareemOptions = {
    useErrorHandlers: true,
    numCallbackParams: 1
  };
  hooks = hooks.filter(function (hook) {
    // If the custom static overwrites an existing query middleware, don't apply
    // middleware to it by default. This avoids a potential backwards breaking
    // change with plugins like `mongoose-delete` that use statics to overwrite
    // built-in Mongoose functions.
    if (middlewareFunctions.indexOf(hook.name) !== -1) {
      return !!hook.model;
    }

    return hook.model !== false;
  });
  model.$__insertMany = hooks.createWrapper('insertMany', model.$__insertMany, model, kareemOptions);

  var _loop = function _loop() {
    var key = _Object$keys[_i];

    if (hooks.hasHooks(key)) {
      var original = model[key];

      model[key] = function () {
        var numArgs = arguments.length;
        var lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;
        var cb = typeof lastArg === 'function' ? lastArg : null;
        var args = Array.prototype.slice.call(arguments, 0, cb == null ? numArgs : numArgs - 1); // Special case: can't use `Kareem#wrap()` because it doesn't currently
        // support wrapped functions that return a promise.

        return promiseOrCallback(cb, function (callback) {
          hooks.execPre(key, model, args, function (err) {
            if (err != null) {
              return callback(err);
            }

            var postCalled = 0;
            var ret = original.apply(model, args.concat(post));

            if (ret != null && typeof ret.then === 'function') {
              ret.then(function (res) {
                return post(null, res);
              }, function (err) {
                return post(err);
              });
            }

            function post(error, res) {
              if (postCalled++ > 0) {
                return;
              }

              if (error != null) {
                return callback(error);
              }

              hooks.execPost(key, model, [res], function (error) {
                if (error != null) {
                  return callback(error);
                }

                callback(null, res);
              });
            }
          });
        }, model.events);
      };
    }
  };

  for (var _i = 0, _Object$keys = Object.keys(statics); _i < _Object$keys.length; _i++) {
    _loop();
  }
};