'use strict';
/*!
 * ignore
 */

var get = require('../get');

module.exports = applyTimestampsToUpdate;
/*!
 * ignore
 */

function applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options) {
  var updates = currentUpdate;
  var _updates = updates;
  var overwrite = get(options, 'overwrite', false);
  var timestamps = get(options, 'timestamps', true); // Support skipping timestamps at the query level, see gh-6980

  if (!timestamps || updates == null) {
    return currentUpdate;
  }

  var skipCreatedAt = timestamps != null && timestamps.createdAt === false;
  var skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;

  if (overwrite) {
    if (currentUpdate && currentUpdate.$set) {
      currentUpdate = currentUpdate.$set;
      updates.$set = {};
      _updates = updates.$set;
    }

    if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {
      _updates[updatedAt] = now;
    }

    if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {
      _updates[createdAt] = now;
    }

    return updates;
  }

  currentUpdate = currentUpdate || {};

  if (Array.isArray(updates)) {
    // Update with aggregation pipeline
    updates.push({
      $set: {
        updatedAt: now
      }
    });
    return updates;
  }

  updates.$set = updates.$set || {};

  if (!skipUpdatedAt && updatedAt && (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {
    var timestampSet = false;

    if (updatedAt.indexOf('.') !== -1) {
      var pieces = updatedAt.split('.');

      for (var i = 1; i < pieces.length; ++i) {
        var remnant = pieces.slice(-i).join('.');
        var start = pieces.slice(0, -i).join('.');

        if (currentUpdate[start] != null) {
          currentUpdate[start][remnant] = now;
          timestampSet = true;
          break;
        } else if (currentUpdate.$set && currentUpdate.$set[start]) {
          currentUpdate.$set[start][remnant] = now;
          timestampSet = true;
          break;
        }
      }
    }

    if (!timestampSet) {
      updates.$set[updatedAt] = now;
    }

    if (updates.hasOwnProperty(updatedAt)) {
      delete updates[updatedAt];
    }
  }

  if (!skipCreatedAt && createdAt) {
    if (currentUpdate[createdAt]) {
      delete currentUpdate[createdAt];
    }

    if (currentUpdate.$set && currentUpdate.$set[createdAt]) {
      delete currentUpdate.$set[createdAt];
    }

    var _timestampSet = false;

    if (createdAt.indexOf('.') !== -1) {
      var _pieces = createdAt.split('.');

      for (var _i = 1; _i < _pieces.length; ++_i) {
        var _remnant = _pieces.slice(-_i).join('.');

        var _start = _pieces.slice(0, -_i).join('.');

        if (currentUpdate[_start] != null) {
          currentUpdate[_start][_remnant] = now;
          _timestampSet = true;
          break;
        } else if (currentUpdate.$set && currentUpdate.$set[_start]) {
          currentUpdate.$set[_start][_remnant] = now;
          _timestampSet = true;
          break;
        }
      }
    }

    if (!_timestampSet) {
      updates.$setOnInsert = updates.$setOnInsert || {};
      updates.$setOnInsert[createdAt] = now;
    }
  }

  if (Object.keys(updates.$set).length === 0) {
    delete updates.$set;
  }

  return updates;
}