'use strict';

var get = require('../get');

var utils = require('../../utils');
/**
 * Given a Mongoose index definition (key + options objects) and a MongoDB server
 * index definition, determine if the two indexes are equal.
 *
 * @param {Object} key the Mongoose index spec
 * @param {Object} options the Mongoose index definition's options
 * @param {Object} dbIndex the index in MongoDB as returned by `listIndexes()`
 * @api private
 */


module.exports = function isIndexEqual(key, options, dbIndex) {
  // Special case: text indexes have a special format in the db. For example,
  // `{ name: 'text' }` becomes:
  // {
  //   v: 2,
  //   key: { _fts: 'text', _ftsx: 1 },
  //   name: 'name_text',
  //   ns: 'test.tests',
  //   background: true,
  //   weights: { name: 1 },
  //   default_language: 'english',
  //   language_override: 'language',
  //   textIndexVersion: 3
  // }
  if (dbIndex.textIndexVersion != null) {
    var weights = dbIndex.weights;

    if (Object.keys(weights).length !== Object.keys(key).length) {
      return false;
    }

    for (var _i = 0, _Object$keys = Object.keys(weights); _i < _Object$keys.length; _i++) {
      var prop = _Object$keys[_i];

      if (!(prop in key)) {
        return false;
      }

      var weight = weights[prop];

      if (weight !== get(options, 'weights.' + prop) && !(weight === 1 && get(options, 'weights.' + prop) == null)) {
        return false;
      }
    }

    if (options['default_language'] !== dbIndex['default_language']) {
      return dbIndex['default_language'] === 'english' && options['default_language'] == null;
    }

    return true;
  }

  var optionKeys = ['unique', 'partialFilterExpression', 'sparse', 'expireAfterSeconds', 'collation'];

  for (var _i2 = 0, _optionKeys = optionKeys; _i2 < _optionKeys.length; _i2++) {
    var _key = _optionKeys[_i2];

    if (!(_key in options) && !(_key in dbIndex)) {
      continue;
    }

    if (_key === 'collation') {
      if (options[_key] == null || dbIndex[_key] == null) {
        return options[_key] == null && dbIndex[_key] == null;
      }

      var definedKeys = Object.keys(options.collation);
      var schemaCollation = options.collation;
      var dbCollation = dbIndex.collation;

      for (var _i3 = 0, _definedKeys = definedKeys; _i3 < _definedKeys.length; _i3++) {
        var opt = _definedKeys[_i3];

        if (get(schemaCollation, opt) !== get(dbCollation, opt)) {
          return false;
        }
      }
    } else if (!utils.deepEqual(options[_key], dbIndex[_key])) {
      return false;
    }
  }

  var schemaIndexKeys = Object.keys(key);
  var dbIndexKeys = Object.keys(dbIndex.key);

  if (schemaIndexKeys.length !== dbIndexKeys.length) {
    return false;
  }

  for (var i = 0; i < schemaIndexKeys.length; ++i) {
    if (schemaIndexKeys[i] !== dbIndexKeys[i]) {
      return false;
    }

    if (!utils.deepEqual(key[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {
      return false;
    }
  }

  return true;
};