'use strict';

var arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;

var sessionNewDocuments = require('../helpers/symbols').sessionNewDocuments;

module.exports = function trackTransaction(schema) {
  schema.pre('save', function () {
    var session = this.$session();

    if (session == null) {
      return;
    }

    if (session.transaction == null || session[sessionNewDocuments] == null) {
      return;
    }

    if (!session[sessionNewDocuments].has(this)) {
      var initialState = {};

      if (this.isNew) {
        initialState.isNew = true;
      }

      if (this.$__schema.options.versionKey) {
        initialState.versionKey = this.get(this.$__schema.options.versionKey);
      }

      initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.states.modify));
      initialState.atomics = _getAtomics(this);
      session[sessionNewDocuments].set(this, initialState);
    } else {
      var state = session[sessionNewDocuments].get(this);

      for (var _i = 0, _Object$keys = Object.keys(this.$__.activePaths.states.modify); _i < _Object$keys.length; _i++) {
        var path = _Object$keys[_i];
        state.modifiedPaths.add(path);
      }

      state.atomics = _getAtomics(this, state.atomics);
    }
  });
};

function _getAtomics(doc, previous) {
  var pathToAtomics = new Map();
  previous = previous || new Map();
  var pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = pathsToCheck[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var path = _step.value;
      var val = doc.$__getValue(path);

      if (val != null && val instanceof Array && val.isMongooseDocumentArray && val.length && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length > 0) {
        var existing = previous.get(path) || {};
        pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var dirty = doc.$__dirty();
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = dirty[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var dirt = _step2.value;
      var _path = dirt.path;
      var _val = dirt.value;

      if (_val != null && _val[arrayAtomicsSymbol] != null && Object.keys(_val[arrayAtomicsSymbol]).length > 0) {
        var _existing = previous.get(_path) || {};

        pathToAtomics.set(_path, mergeAtomics(_existing, _val[arrayAtomicsSymbol]));
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return pathToAtomics;
}

function mergeAtomics(destination, source) {
  destination = destination || {};

  if (source.$pullAll != null) {
    destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);
  }

  if (source.$push != null) {
    destination.$push = destination.$push || {};
    destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);
  }

  if (source.$addToSet != null) {
    destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);
  }

  if (source.$set != null) {
    destination.$set = Object.assign(destination.$set || {}, source.$set);
  }

  return destination;
}