"use strict"; // Copyright 2018 Google LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRetryConfig = void 0;

function getRetryConfig(err) {
  var _a, config, retryRanges, shouldRetryFn, retryDelay, delay, backoff;

  return regeneratorRuntime.async(function getRetryConfig$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          config = getConfig(err);

          if (!(!err || !err.config || !config && !err.config.retry)) {
            _context.next = 3;
            break;
          }

          return _context.abrupt("return", {
            shouldRetry: false
          });

        case 3:
          config = config || {};
          config.currentRetryAttempt = config.currentRetryAttempt || 0;
          config.retry = config.retry === undefined || config.retry === null ? 3 : config.retry;
          config.httpMethodsToRetry = config.httpMethodsToRetry || ['GET', 'HEAD', 'PUT', 'OPTIONS', 'DELETE'];
          config.noResponseRetries = config.noResponseRetries === undefined || config.noResponseRetries === null ? 2 : config.noResponseRetries; // If this wasn't in the list of status codes where we want
          // to automatically retry, return.

          retryRanges = [// https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
          // 1xx - Retry (Informational, request still processing)
          // 2xx - Do not retry (Success)
          // 3xx - Do not retry (Redirect)
          // 4xx - Do not retry (Client errors)
          // 429 - Retry ("Too Many Requests")
          // 5xx - Retry (Server errors)
          [100, 199], [429, 429], [500, 599]];
          config.statusCodesToRetry = config.statusCodesToRetry || retryRanges; // Put the config back into the err

          err.config.retryConfig = config; // Determine if we should retry the request

          shouldRetryFn = config.shouldRetry || shouldRetryRequest;
          _context.next = 14;
          return regeneratorRuntime.awrap(shouldRetryFn(err));

        case 14:
          if (_context.sent) {
            _context.next = 16;
            break;
          }

          return _context.abrupt("return", {
            shouldRetry: false,
            config: err.config
          });

        case 16:
          // Calculate time to wait with exponential backoff.
          // If this is the first retry, look for a configured retryDelay.
          retryDelay = config.currentRetryAttempt ? 0 : (_a = config.retryDelay) !== null && _a !== void 0 ? _a : 100; // Formula: retryDelay + ((2^c - 1 / 2) * 1000)

          delay = retryDelay + (Math.pow(2, config.currentRetryAttempt) - 1) / 2 * 1000; // We're going to retry!  Incremenent the counter.

          err.config.retryConfig.currentRetryAttempt += 1; // Create a promise that invokes the retry after the backOffDelay

          backoff = new Promise(function (resolve) {
            setTimeout(resolve, delay);
          }); // Notify the user if they added an `onRetryAttempt` handler

          if (config.onRetryAttempt) {
            config.onRetryAttempt(err);
          } // Return the promise in which recalls Gaxios to retry the request


          _context.next = 23;
          return regeneratorRuntime.awrap(backoff);

        case 23:
          return _context.abrupt("return", {
            shouldRetry: true,
            config: err.config
          });

        case 24:
        case "end":
          return _context.stop();
      }
    }
  });
}

exports.getRetryConfig = getRetryConfig;
/**
 * Determine based on config if we should retry the request.
 * @param err The GaxiosError passed to the interceptor.
 */

function shouldRetryRequest(err) {
  var config = getConfig(err); // node-fetch raises an AbortError if signaled:
  // https://github.com/bitinn/node-fetch#request-cancellation-with-abortsignal

  if (err.name === 'AbortError') {
    return false;
  } // If there's no config, or retries are disabled, return.


  if (!config || config.retry === 0) {
    return false;
  } // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)


  if (!err.response && (config.currentRetryAttempt || 0) >= config.noResponseRetries) {
    return false;
  } // Only retry with configured HttpMethods.


  if (!err.config.method || config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {
    return false;
  } // If this wasn't in the list of status codes where we want
  // to automatically retry, return.


  if (err.response && err.response.status) {
    var isInRange = false;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = config.statusCodesToRetry[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _slicedToArray(_step.value, 2),
            min = _step$value[0],
            max = _step$value[1];

        var status = err.response.status;

        if (status >= min && status <= max) {
          isInRange = true;
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!isInRange) {
      return false;
    }
  } // If we are out of retry attempts, return


  config.currentRetryAttempt = config.currentRetryAttempt || 0;

  if (config.currentRetryAttempt >= config.retry) {
    return false;
  }

  return true;
}
/**
 * Acquire the raxConfig object from an GaxiosError if available.
 * @param err The Gaxios error with a config object.
 */


function getConfig(err) {
  if (err && err.config && err.config.retryConfig) {
    return err.config.retryConfig;
  }

  return;
}